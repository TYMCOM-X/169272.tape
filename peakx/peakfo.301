!!Cnt];},
      !!ELC   = cvms(!!ELC  ) & {ELC;   integer array T!!ELC   [1:!!Cnt];},
      !!ILP   = cvms(!!ILP  ) & {ILP;   integer array T!!ILP   [1:!!Cnt];},
      !!ICP   = cvms(!!ICP  ) & {ICP;   integer array T!!ICP   [1:!!Cnt];};

    !!Term
    !!Alias
    !!Enum
    !!Lines
    !!MaxS
    !!Width
    !!CPC
    !!ELP
    !!ELC
    !!ILP
    !!ICP
  };
!! title Build Terminal Tables ;
! Now build the terminal tables.  If you change anything here be careful
! about not placing semicolons after the macro invocations.  Also, the
! last macro, and ONLY the last macro, MUST be a TTX().
!
!   Terminal Type Specification Acceptable as Input
!   |          Displayed Terminal Type Alias
!   |          |        Enumerated Terminal Type Class
!   |          |        |  Lines Per Screen
!   |          |        |  |   Maximum Scoll Region
!   |          |        |  |   |   Screen Width
!   |          |        |  |   |   |   Cost of Positioning Cursor
!   |          |        |  |   |   |   |  Can we Erase Lines?
!   |          |        |  |   |   |   |  |  Cost of Erasing Lines
!   |          |        |  |   |   |   |  |  |  Can We Insert Lines?
!   |          |        |  |   |   |   |  |  |  |  Cost of Inserting
!   |          |        |  |   |   |   |  |  |  |  |  Characters
!   |          |        |  |   |   |   |  |  |  |  ;
TTY("H19",     H19,     1, 24, 24, 80, 4, 1, 2, 1, 0)
TTY("Z19",     H19,     1, 24, 24, 80, 4, 1, 2, 1, 0)
TTY("VT52",    VT52,    1, 24, 24, 80, 4, 1, 2, 0, 0)
TTY("*15*",    VT52,    1, 24, 24, 80, 4, 1, 2, 0, 0)
TTY("*17*",    VT52,    1, 24, 24, 80, 4, 1, 2, 0, 0)

TTY("TYM444",  Tym444,  2, 24, 24, 80, 8, 1, 2, 1, 0)
TTY("444",     Tym444,  2, 24, 24, 80, 8, 1, 2, 1, 0)
TTY("HP2621",  Tym444,  2, 24, 24, 80, 8, 1, 2, 1, 0)
TTY("*5*",     Tym444,  2, 24, 24, 80, 8, 1, 2, 1, 0)
TTY("*33*",    Tym444,  2, 24, 24, 80, 8, 1, 2, 1, 0)

TTY("TYM425",  Tym425,  3, 24, 10, 80, 4, 1, 2, 1, 1)
TTY("425",     Tym425,  3, 24, 10, 80, 4, 1, 2, 1, 1)
TTY("ADM31",   Tym425,  3, 24, 10, 80, 4, 1, 2, 1, 1)
TTY("ADM31A",  Tym425,  3, 24, 10, 80, 4, 1, 2, 1, 1)
TTY("*4*",     Tym425,  3, 24, 10, 80, 4, 1, 2, 1, 1)

TTY("TYM420",  Tym420,  3, 24, 24, 80, 4, 1, 2, 0, 0)
TTY("420",     Tym420,  3, 24, 24, 80, 4, 1, 2, 0, 0)
TTY("ADM1",    Tym420,  3, 24, 24, 80, 4, 1, 2, 0, 0)
TTY("ADM1A",   Tym420,  3, 24, 24, 80, 4, 1, 2, 0, 0)

TTY("ADDS",    ADDS,    4, 24, 24, 80, 4, 1, 2, 0, 0)

TTY("VT100",   VT100,   5, 24, 10, 80, 8, 1, 3, 1, 0)
TTY("*20*",    VT100,   5, 24, 10, 80, 8, 1, 3, 1, 0)
TTY("VT102",   VT102,   6, 24, 10, 80, 8, 1, 3, 1, 1)
TTY("*37*",    VT102,   6, 24, 10, 80, 8, 1, 3, 1, 1)

TTY("Tym430",  Tym430,  7, 24,  0, 80, 4, 0, 0, 0, 0)
TTY("430",     Tym430,  7, 24,  0, 80, 4, 0, 0, 0, 0)
TTY("ADM3A",   Tym430,  7, 24,  0, 80, 4, 0, 0, 0, 0)

TTY("SCANSET", Scanset, 8, 24,  0, 80, 4, 1, 2, 0, 0)

TTY("940",     Ti940,   9, 24,  5, 80, 4, 1, 2, 1, 0)
TTX("Ti940",   Ti940,   9, 24,  5, 80, 4, 1, 2, 1, 0)
!! title Rtn DelStr ;
! Return some number of DELs.
;

simple string procedure DelStr (integer Cnt);
begin "DelStr"
  own string
    DelString;

  while (length(DelString) < Cnt) do
    DelString _ DelString & DEL & DelString;

  return(DelString[1 for Cnt]);
end "DelStr";
!! title Rtn TermIdx ;
! Determine the magic index if the supplied terminal type.  If none
! matches, return -1.
;

simple integer procedure TermIdx (string Term);
begin "TermIdx"
  integer
    I;

  for I _ 1 step 1 until !!Cnt do
    if (kequ(Term, T!!Term[I][1 for length(Term)])) then
      return(I);

  return(-1);
end "TermIdx";
!! title Rtn T!GetTermType ;
! Get the user's terminal type, and set up some information about the
! terminal, such as its screen size, capabalities, ... ;

forward internal integer procedure T!GetC;

internal simple procedure T!GetTermType (boolean AskTheMonitor(true));
begin "T!GetTermType"
  string
    Term;
  integer
    I;


  if (AskTheMonitor) then
  begin
    I _ -1;

    ifcr TymcomX thenc
      Term _ cv6str(auxclv(-1, I, '100));       ! get tty type ;

      if (equ(Term, "______")) then
        Term _ null;				! not implemented ;
    endc

    ifcr Tops20 thenc
      start!code
        movei     1, -1;
        gttyp;
        movem     2, I;
      end;

      Term _ "*" & cvos(I) & "*";
    endc
  end
  else
    Term _ null;

  while (true) do
  begin "ask for terminal type"
    if (Term = null) then
    begin
      print("Terminal Type? ");

      ifcr TymcomX thenc
        if (T!IntP) then
        begin
          integer
            C;

          while ((C _ T!GetC) neq CR and C neq ESC) do
          begin
            appnd(Term, C);
            auxclv(-1, C, '003);        ! .axo8 (image output)
                                        ;
          end;
        end
        else
          Term _ inchwl;
      endc

      ifcr Tops20 thenc
	Term _ InTTY;
      endc
    end;

    if ((I _ TermIdx(Term)) > 0) then
    begin
      T!Enum  _ T!!Enum[I];
      T!Name  _ T!!Alias[I];
      T!Lines _ T!!Lines[I];
      T!MaxS  _ T!!MaxS[I];
      T!Width _ T!!Width[I];
      T!CPC   _ T!!CPC[I];
      T!ELP   _ T!!ELP[I];
      T!ELC   _ T!!ELC[I];
      T!ILP   _ T!!ILP[I];
      T!ICP   _ T!!ICP[I];
      return;
    end;

    if (equ(Term, "?") or kequ(Term, "help")) then
    begin
      print(crlf & "Supported terminals are:" & crlf);

      for I _ 1 upto !!Cnt do
	if (not kequ(T!!Alias[I], Term)) then
	begin
	  print("  ", T!!Alias[I], crlf);
	  Term _ T!!Alias[I];
	end;

      print(crlf);
    end
    else
    begin
      print(crlf & "Unknown terminal type: ", Term, crlf);
      print("Type ? for a list of supported types." & crlf&crlf);
    end;

    Term _ NULL;
  end "ask for terminal type";
end "T!GetTermType";
!! title Rtn T!Init ;
! Initialize the module.  This involves saving the current state of
! the monitor with respect to the terminal, turning off the echo ... ;

internal procedure T!Init;
begin
  define
    AskTheMonitor = {true};

  T!GetTermType(AskTheMonitor);

  ifc TymcomX thenc
    begin!code
      seto	1, ;
      ttcall	6, 1;		! getlch 1;
      movem	1, T!LCH;	! save them ;
      tlo	1, '220;	! set some magic bits ;
      ttcall	7, 1;		! setlch 1;
      hrroi	1, '64;
      auxcal	1, '714;	! set no-echo, break on all bits ;
      setzm	T!XON;		! want the xon bit off ;
      hrroi	1, '55;
      auxcal	1, T!XON;	! turn it off, save old value ;
      jfcl;
    end;
  endc

  ifcr Tops20 thenc
    start!code
      movei	1, -5;
      rtiw;
      movem	2, SaveRTIW;
      tlz	2, '040004;		! turn off ^C, ^O interrupts ;
      trz	2, '100000;		! turn off ^T interrupt ;
      hrrzi	1, -5;
      stiw;
      hrrzi	1, -1;
      rfmod;
      movem	2, SaveRFMOD;
      hrrzi	1, -1;
      trz	2, '300;		! 8 bit image i/o ;
      sfmod;
    end;
  endc

  T!Buf!BP  _ point(7, T!Buffer[0], -1);
  T!Buf!Cnt _ 0;

  set(T!IntP);
end;
!! title Rtn T!FlshIBuf ;
! On Tops-20 (as of V5.0), there is a bug in the transition from image
! mode I/O to "normal", monitor-supervised I/O.  Basically, if the last
! character input in image mode was a CR, the monitor feels compelled to
! insert a LF into the terminal input buffer, regardless of whether the
! character has already been read.
!
! At the monitor level, upon exiting Peak, this is manifested as a repeat
! of the prompt.  At MAGNUM level, a LF causes the last command issued to
! be repeated (and naturally, this repeats the edit command).
!
! We therefore force another character (a space) into the terminal input
! buffer, and read it immediately.
;

ifcr Tops20 thenc
  internal simple procedure T!FlshIBuf;
  begin "T!FlshIBuf"
    start!code
      hrrzi     1, -1;
      hrrzi     2, '40;
      sti;
      hrrzi     1, -1;
      bin;
    end;
  end "T!FlshIBuf";
endc
!! title Rtn T!Fini ;
! Reset the terminal (or at least the line characteristics) to roughly
!  how we found it.  Position the cursor to the bottom of screen. ;

forward internal simple procedure T!CPos(integer Row, Col);
forward internal simple procedure T!Flush;

internal procedure T!Fini;
begin
  T!Cpos(T!Lines, 1);
  T!Flush;

  ifcr TymcomX thenc
    begin!code
      hrli	1, '41;		! wait for output to complete ;
      hrri	1, 5;		! wait 5 seconds before timeout ;
      calli	1, '72;		! hiber will send yellow ball ;
       jfcl;			! ignore timeout (so we lose...) ;
      move	1, T!LCH;	! restore original line characteristics ;
      ttcall	7, 1;		! setlch 1;
      hrroi	1, '64;		! turn off bits in file status word ;
      auxcal	1, 0;		! clear the bits ;
       jfcl;
      hrroi	1, '55;
      auxcal	1, T!XON;	! restore xon setting ;
       jfcl;
    end;
  endc

  ifcr Tops20 thenc
    start!code
      movei	1, - 5;
      move	2, SaveRTIW;
      stiw;
      hrrzi	1, -1;
      move	2, SaveRFMOD;
      sfmod;
    end;
  endc
end;
!! title Rtn T!RSet ;
! Oops, re-init the terminal ;

internal procedure T!RSet;
begin "rehe terminal"
  ifcr TymcomX thenc
    begin!code
      seto	1, ;
      ttcall	6, 1;			! getlch 1;
      tlo	1, '220;		! set some magic bits ;
      ttcall	7, 1;			! setlch 1;
      hrroi	1, '64;
      auxcal	1, '714;		! set no-echo, break on all bits ;
      setz	2, ;
      hrroi	1, '55;
      auxcal	1, 2;
      jfcl;
    end;
  endc

  ifcr Tops20 thenc
    start!code
      movei	1, -5;
      move	2, SaveRTIW;
      tlz	2, '040004;		! turn off ^C, ^O interrupts ;
      trz	2, '100000;		! turn off ^T interrupt ;
      stiw;
      hrrzi	1, -1;
      move	2, SaveRFMOD;
      trz	2, '300;		! 8 bit image i/o ;
      sfmod;
    end;
  endc
end "reset the terminal";
!! title Rtn T!ChrP ;
! Routine to tell if typeahead is present ;

internal boolean procedure T!ChrP;
begin "T!ChrP"
  own integer
    CharThere;

  ifcr TymcomX thenc
    start!code
      hrroi	1, '10;		! 1/  -1,,10 ;
      auxcal	1, ;		! skip if input ;
       tdca	1, 1;		!  zero t1 and skip ;
      seto	1, ;		! set 1 to -1 ;
      movem	1, CharThere;	! store the result ;
    end;
  endc

  ifcr Tops20 thenc
    start!code
      setzm	CharThere;
      hrrzi	1, -1;
      sibe;				! skip if buffer empty ;
      movem	2, CharThere;		!  not empty, save count ;
    end;
  endc

  return(CharThere);
end "T!ChrP";
!! title Rtn T!GetC ;
! Routine to get a 7 bit image character from the terminal. ;

internal integer procedure T!GetC;
begin "T!GetC"
  integer
    C;

  ifcr TymcomX thenc
    start!code
      label
	getc,
	waitc,
	gotc;

      getc:
	hrroi	1, 1;		! -1,,1 (.axi8s) ;
	auxcal	1, 2;		! input image character and skip ;
	  jrst	waitc;		! no character, block for one ;
	jrst	gotc;		! have a character, go home ;

      waitc:
	hrroi	1, 0;		! -1,,0 (.axi8c) ;
	auxcal	1, 2;		! block until input ;
	  jfcl;

      gotc:
	andi	2, '177;	! and to 7 bits ;
	movem	2, C;		! Save the character ;
    end;
  endc

  ifcr Tops20 thenc
    start!code
	hrrzi 1, -1;		! read from the console ;
	bin;			! get a byte ;
	andi 2, '177;		! mask to 7 bits ;
	movem 2, C;		! save ;
    end;
  endc

  return(C);
end "T!GetC";
!! title Rtn T!Flush ;
! Routine to flush the terminal buffer ;

internal simple procedure T!Flush;
begin "T!Flush"
  idpb(0, T!Buf!BP);

  ifcr TymcomX thenc
    auxclr(-1, T!Buffer[0], '52);	! pseudo outstr ;
  endc

  ifcr Tops20 thenc
    start!code
      hrroi     2,access(T!Buffer[0]);
      setz      3,;
      hrrzi     1,-1;			! write to our console ;
      sout;				! dump the string ;
    end;
  endc

  T!Buf!BP  _ point(7, T!Buffer[0], -1);
  T!Buf!Cnt _ 0;
end "T!Flush";
!! title Rtn T!SBuf ;
! Send a string of stuff to the terminal, regardless of size.
;

simple procedure T!SBuf (string Str);
begin "T!SBuf"
  if ((length(Str) + T!Buf!Cnt) < TERMBUFFERSIZE) then
  begin
    ! The string and the current contents of the buffer both fit in the
    ! buffer.
    ;

    while (length(Str)) do
    begin
      integer
        Char;

      idpb(Char _ lop(Str), T!Buf!BP);
      incr(T!Buf!Cnt);
    end;
  end
  else 
  begin
    ! String and buffer won't both fit in the buffer.
    ;

    define
      T1 = 1,
      T2 = 2,
      T3 = 3,
      Sp = '16;

      T!Flush;

        ! Output the buffer.
        ;

    ifcr TymcomX thenc
      begin
        own integer array
          ArgBlk [0:1];                 ! Argument block we give to
                                        ! auxclr. 
                                        ;
        start!code
          hrrz          T1, -1(Sp);
          movem         T1, ArgBlk[0];
          move          T1, (Sp);
          movem         T1, ArgBlk[1];
        end;

        auxclr(-1, ArgBlk[0], '67);

          ! Output the string, regardless of length.
          ;
      end;
    endc

    ifcr Tops20 thenc
      start!code
        hrrzi   T1, -1;                 ! Our console designator ;
        move    T2, (Sp);               ! Byte pointer ;
        hrrz    T3, -1(Sp);             ! -Byte Count ;
        movns   T3;
        sout;                           ! Output the string ;
      end;
    endc
  end;
end "T!SBuf";
!! title Rtn T!Buf ;
! Routine to buffer a character for output ;

internal simple procedure T!Buf(integer Char);
begin "T!Buf"
  if (T!Buf!Cnt = (TERMBUFFERSIZE - 1)) then
    T!Flush;

  idpb(Char, T!Buf!BP);
  incr(T!Buf!Cnt);
end "T!Buf";
!! title Rtn T!NBuf ;
! Convert the supplied integer into ascii characters and insert them into
! the terminal buffer.
;

simple procedure T!NBuf (integer N);
begin "T!NBuf"
  string
    Str;

  Str _ null;

  while (N) do
  begin
    Str _ ((N mod 10) + "0") & Str;
    N   _ N div 10;
  end;

  T!SBuf(Str);
end "T!NBuf";
!! title Rtn Vt100Region ;
! Set the VT100's scrolling region.
;

simple procedure Vt100Region (integer Top, Bottom);
begin "Vt100Region"
  T!SBuf(ESC & "[");

  if (Top > 1) then
    T!NBuf(Top);

  if (Bottom > 1) then
  begin
    T!Buf(";");
    T!NBuf(Bottom);
  end;

  T!Buf("r");
end "Vt100Region";
!! title Rtn T!OutC ;
! Routine to output a 7 bit character to the terminal ;

internal simple procedure T!OutC(integer Char);
begin "T!OutC"
  if (Char < " ") then
  begin
    if (Char = CR) then
      T!Col _ 1
    else if (Char = LF) then
      incr(T!Row)
    else if (Char = BS) then
      decr(T!Col);
  end
  else
  begin
    incr(T!Col);

    if (T!Col > T!Width) then		! we just got lost ;
      T!Col _ -999;
  end;

  T!Buf(Char);
end "T!OutC";
!! title Rtn T!Bell ;
! Routine to beep the bell
;

internal simple procedure T!Bell;
begin "T!Bell"

  ifcr TymcomX thenc
    auxclv(-1, '7, '3);
  endc

  ifcr Tops20 thenc
    start!code
      hrrzi 1, -1;		! aim at our console ;
      hrrzi 2, '7;		! with a bell ;
      bout;			! launch it ;
    end;
  endc
end "T!Bell";
!! title Rtn T!ES ;
! Routine to erase the screen for a T!Enum terminal.
;

internal simple procedure T!ES;
begin "T!ES"
  integer
    pad;

  T!Row _ 1;		! update state variables ;
  T!Col _ 1;

  case (T!Enum) of
  begin
    [Term!Idx!H19]
    [Term!Idx!Scanset]
    [Term!Idx!VT52]

        T!SBuf(ESC & "H" & ESC & "J");

    [Term!Idx!TYM444]

        T!SBuf(ESC & "&a0r0C" & ESC & "J");

    [Term!Idx!Tym425]
    [Term!Idx!Tym420]

        T!SBuf(('36) & ESC & "Y" & ESC & ":");

    [Term!Idx!Adds]

	T!Buf(FF);

    [Term!Idx!VT100]
    [Term!Idx!VT102]

        T!SBuf(ESC & "[H" & ESC & "[2J" & DelStr(16));

    [Term!Idx!Tym430]

      T!Buf('32);

    [Term!Idx!Ti940]

      T!SBuf(ESC & "p")
  end;
end "T!ES";
!! title Rtn T!EL ;
! Routine to erase to end of line. ;

internal simple procedure T!EL;
begin "T!EL"
  case (T!Enum) of
  begin
    [Term!Idx!H19]
    [Term!Idx!Tym444]
    [Term!Idx!Adds]

        T!SBuf(ESC & "K");

    [Term!Idx!Tym425]
    [Term!Idx!Tym420]

        T!SBuf(ESC & "T");

    [Term!Idx!VT100]
    [Term!Idx!VT102]

        T!SBuf(ESC & "[K" & DEL);

    [Term!Idx!Scanset]
    [Term!Idx!VT52]

      T!SBuf(ESC & "K");

    [Term!Idx!Ti940]

        T!SBuf(ESC & "I")
  end;
end "T!EL";
!! title Rtn T!CPos ;
! Routine to position the cursor. ;

internal simple procedure T!CPos(integer Row, Col);
begin "T!CPos"
  case (T!Enum) of
  begin
    [Term!Idx!Adds]
    [Term!Idx!H19]
    [Term!Idx!Scanset]
    [Term!Idx!Ti940]
    [Term!Idx!VT52]

        T!SBuf(ESC & "Y" & (Row + '37) & (Col + '37));

    [Term!Idx!Tym444]
      begin
        T!SBuf(ESC & "&a");

        T!NBuf(Row - 1);
        T!Buf("y");

        T!NBuf(Col - 1);
        T!Buf("C");
      end;

    [Term!Idx!Tym425]
    [Term!Idx!Tym420]
    [Term!Idx!Tym430]

        T!SBuf(ESC & "=" & (Row + '37) & (Col + '37));

    [Term!Idx!VT100]		! vt100 ;
    [Term!Idx!VT102]		! vt102 - rainbow 100, pro 350 ;
      begin
        T!SBuf(ESC & "[");
        T!NBuf(Row);
        T!Buf(";");

        T!NBuf(Col);
        T!Buf("H");
      end
  end;

  T!Row _ Row;
  T!Col _ Col;
end "T!CPos";
!! title Rtn T!IC ;
! Insert N spaces at the cursor ;

internal simple procedure T!IC(integer N);
begin "T!IC"
  case (T!Enum) of
  begin
    [Term!Idx!H19]
      begin
      end;

    [Term!Idx!Tym444]
      begin
        T!SBuf(ESC & "Q");

	while (N) do
	begin
	  T!Buf(SP);
	  decr(N);
	end;

        T!SBuf(ESC & "R");
      end;

    [Term!Idx!Tym425]
    [Term!Idx!Tym420]

      while (N) do
      begin
        T!SBuf(ESC & "Q");
	decr(N);
      end;

    [Term!Idx!VT102]
      begin
        T!SBuf(ESC & "[4h");

	while (N) do
	begin
	  T!Buf(SP);
	  decr(N);
	end;

        T!SBuf(ESC & "[4l");
      end
  end;
end "T!IC";
!! title Rtn T!DC ;
! Delete N characters at the cursor ;

internal simple procedure T!DC(integer N);
  begin "delete spaces"

    case T!Enum of
      begin

	[Term!Idx!H19]
          begin
          end;

	[Term!Idx!Tym444]
	    while (N) do
	      begin
                T!SBuf(ESC & "P");
		decr(N);
	      end;

	[Term!Idx!Tym425]
	[Term!Idx!Tym420]
	    while (N) do
	      begin
                T!SBuf(ESC & "W");
		decr(N);
	      end;

        [Term!Idx!VT102]
	    begin
              T!SBuf(ESC & "[");

              T!NBuf(N);
              T!Buf("P");
	    end
      end;

  end "delete spaces";
!! title Rtn T!IL ;
! Routine to insert a blank line at the cursor. ;

internal simple procedure T!IL;
begin "T!IL"
  case (T!Enum) of
  begin
    [Term!Idx!Tym444]
    [Term!Idx!H19]

        T!SBuf(ESC & "L");

    [Term!Idx!Tym425]
    [Term!Idx!Tym420]

        T!SBuf(ESC & "E");

    [Term!Idx!VT100]

      ! <<  This would benefit from a repeat count.
      ;

        begin
          T!SBuf(ESC & "7");
          Vt100Region(T!Row, T!Lines);
          T!SBuf(ESC & "8");

          T!SBuf(ESC & "M" & DelStr(2));

          Vt100Region(1, T!Lines);
          T!SBuf(ESC & "8");
        end;

    [Term!Idx!VT102]

        ! <<  This would benefit by a repeat count.
        ;

        T!SBuf(ESC & "[L" & DelStr(16)); 

    [Term!Idx!Ti940]

        T!SBuf(ESC & "N")
  end;
end "T!IL";
!! title Rtn T!DL ;
! Routine to delete the line at the cursor. ;

internal simple procedure T!DL;
begin "T!DL"
  case (T!Enum) of
  begin
    [Term!Idx!Tym444]
    [Term!Idx!H19]

        T!SBuf(ESC & "M");

    [Term!Idx!Tym425]
    [Term!Idx!Tym420]

        T!SBuf(ESC & "R");

    [Term!Idx!VT100]

        begin
          T!SBuf(ESC & "7");
          Vt100Region(T!Row, T!Lines);
          T!SBuf(ESC & "8");
          T!SBuf(ESC & "[");
          T!NBuf(T!Lines);
          T!Buf("H");

          T!SBuf(LF & DelStr(2));

          Vt100Region(1, T!Lines);
          T!SBuf(ESC & "8");
        end;


    [Term!Idx!VT102]

        T!SBuf(ESC & "[M" & DelStr(16));

    [Term!Idx!Ti940]

        T!SBuf(ESC & "O")
  end;
end "T!DL";
!! title The Redisplay Proper ;
! ************************  R E D I S P L A Y  *************************
! *                                                                    *
! *  Herein is an implementation of the D.W.S. Redisplay algorithm,    *
! *  which incorporates some of the ideas from the FINE redisplay,     *
! *  the UNIX EMACS redisplay, and from James Gosling's talk on re-    *
! *  displays at the 1981 ACM SIGPLAN conference on Text Manipulation, *
! *  but tries to be less CPU intensive, as people here in the "real   *
! *  world" get charged for the cycles they use.  So it goes.          *
! *                                                                    *
! *  Dave W. Smith,  September '81                                     *
! *                                                                    *
! **********************************************************************
!
! The Redisplay works roughly as follows:
!
! 1.  Slide the old hash vector along the new hash vector to find an
!     adjustment where the number of matches is a maximum.  (This will
!     be 0 is nothing has scrolled, -n if text is to be scrolled down,
!     +n if text is to be scrolled up).
!
! 2.  Adjust the physical screen vertically, using insert/delete line
!     operations if available.
!
! 3.  For each line do:
!
!     A.  Scan new and old lines to find the character position, if any,
!         where the lines begin to differ.  If the lines don't differ,
!         then proceed to the next line.
!
!     B.  Slide the remaining section of the old line along the remaining
!         section of the new line, looking an for an adjustment which
!         maximizes character matches.
!
!     C.  Adjust the line horizontally, using insert/delete character if
!         available.
!
!     D.  Proceeding from the point of initial difference, fix characters
!         as needed.
!
!     Various heuristics are applyed here and there to minimize the number
!     of characters which must be sent to fix the screen.
! ;
!! title Internal Data Structures ;
! *********************  Internal data structures *********************** ;

! The Redisplay's image of the screen is kept as a packed array of
! integers (with 5 characters packed into a word), which is accessed by
! pointing a byte pointer into it. ;

  safe integer array R!Buf[1 : 25, 1 : 27];

! Each line of text on the screen has an associated hash value which is
! used as an efficient way of telling when lines should be moved up or
! down on the screen by comparing it against the hash vector for the
! desired screen image. ;

  safe integer array R!Hash[1 : 25];
  safe integer array W!Hash[1 : 25];

! We want to keep the hash for a blank line around. ;

  integer BlankHash;

! Weights for hashes ;

  internal integer R!WB, R!WNB,		! weights for blank, non-blank ;
		   R!WX;		! threshold for scrolling ;

! we also want to keep track of the cursor ;

  internal integer R!Row, R!Col;
!! title Rtn R!Init ;
! (Re)Initialize the Redisplay by clearing the physical screen, setting
! the cursor pointers to home, filling the internal screen with <CR>s,
! and reinitializing the hash vector. ;

internal procedure R!Init;
  begin "init"
    integer I;

    R!WB _ 0;
    R!WNB _ 1;
    R!WX _ 1;

    T!ES;				! clear the screen ;

    for R!Row _ 1 upto 25 do
      for R!Col _ 1 upto 27 do
        R!Buf[R!Row, R!Col] _ cvasc("     ");

    for R!Row _ 1 upto 25 do R!Hash[R!Row] _ BlankHash;

  end "init";
!! title Rtn R!SetCursor ;
! routine to get the cursor to (R!Row, R!Col) by whatever devious and
!  nefarious means we see fit. ;

simple procedure R!SetCursor(integer array Buffer);
  begin "move cursor"
    own integer Dist, BP;

    ! If we're moving up, punt.  Few terminals can handle this. ;
    ! Also, if we're lost, punt. ;

    if ((R!Row < T!Row) or (T!Col < 0)) then
      begin
	T!CPos(R!Row, R!Col);
	return;
      end;

    ! if we want the cursor to move down, see if we can't get there
    ! using line feeds, then let the 'same row' code do the rest ;

    if (R!Row > T!Row) then
      begin
	Dist _ (R!Row - T!Row) + abs(R!Col - T!Col);
	if (Dist > T!CPC) then
	  begin
	    T!CPos(R!Row, R!Col);
	    return;
	  end;
	Dist _ R!Row - T!Row;		! get us to the correct row ;
	while (Dist) do
	  begin
	    T!OutC(LF);
	    Dist _ Dist - 1;
	  end;
      end;

    ! Here we handle cursor movement within a row.  Checks are made to
    ! see if it may be cheaper to use backspaces or character rewrites
    ! to get us where we want to go. ;

    if (T!Col = R!Col) then		! the trivial case ;
      return
    else if (R!Col < T!Col) then	! do the backspace check ;
      begin
	Dist _ T!Col - R!Col;
	if (Dist < T!CPC) then	! cheaper to backspace? ;
	  while (Dist) do		 ! yes - use backspaces ;
	    begin
	      T!OutC(BS);
	      Dist _ Dist - 1;
	    end
	else
	  T!CPos(R!Row, R!Col);	 ! no - punt ;
      end
    else  ! R!Col > T!Col ;
      begin
	Dist _ R!Col - T!Col;
	if (Dist < T!CPC) then	! cheaper to rewrite characters? ;
	  begin
	    BP _ point(7, Buffer[R!Row, 1], -1);	 ! yes, do it ;
	    Dist _ T!Col;
	    while (Dist) do
	      begin
		ibp(BP);
		Dist _ Dist - 1;
	      end;
	    Dist _ R!Col - T!Col;
	    while (Dist) do
	      begin
		T!OutC(ldb(BP));
		ibp(BP);
		Dist _ Dist - 1;
	      end;
	  end
	else
	  T!CPos(R!Row, R!Col);	 ! no - punt ;
      end;

  end "move cursor";
!! title Rtn R!Disp ;
! **********************  The ReDisplay proper  ********************** ;

! It is extremely dangerous to even consider touching this.  Think twice,
! then decide not to.  If a particular type of terminal is having problems,
! you are better off looking in the terminal abstraction.
;

internal simple procedure R!Disp (integer array Buffer; boolean PuntIfKeyHit; integer FinalRow, FinalColumn);
begin "redisplay"
  own integer
    Old!BP,
    Old!C,
    New!BP,
    New!C,
    Cursor!BP,
    Line,
    FirstLineChanged,
    LineAdjustment,
    LinesChanged,
    Sweep,
    SweepSize,
    SweepCnt,
    ScanHi,
    ScanLow,
    ThisAdj,
    ThisAdjCnt,
    BestAdj,
    ThisWeight,
    BestWeight,
    NewIdx,
    OldIdx,
    ChangeP,
    BufferLength,
    BufferWidth;

  if (PuntIfKeyHit and T!ChrP) then
    return;

  BufferLength _ arrinfo(Buffer, 2);
  BufferWidth  _ arrinfo(Buffer, 4);

  BlankHash _ 0;

  for Line _ 1 upto BufferWidth do
    BlankHash _ (BlankHash rot 3) xor cvasc("     ");

  for Line _ 1 upto BufferLength do
  begin "hash"
    own integer
      Hash,
      Chunk;

    Hash _ 0;

    for Chunk _ 1 upto BufferWidth do
      Hash _ (Hash rot 3) xor Buffer[Line, Chunk];

    W!Hash[Line] _ Hash;
  end "hash";

  if (T!ILP) then
  begin "vertical adjustment"
    label
      EndOfVerticalAdjustment;

    ! Find first, and number of, lines changed. ;

    FirstLineChanged _ 0;
    LinesChanged     _ 0;

    for Line _ (T!Lines - 2) downto 1 do
      if (R!Hash[Line] neq W!Hash[Line]) then
      begin
	FirstLineChanged _ Line;
	incr(LinesChanged);
      end;

    if (LinesChanged and
	(Buffer[FirstLineChanged,1] = R!Buf[FirstLineChanged,1])) then
    begin
      incr(FirstLineChanged);
      decr(LinesChanged);
    end;

    if (LinesChanged <= 2) then
      goto EndOfVerticalAdjustment;

    ! Find the best adjustment factor by comparing the hash vectors ;

    SweepSize  _ (T!Lines - 1) - FirstLineChanged;
    BestAdj    _ 0;
    BestWeight _ 0;
    ScanHi     _ (SweepSize - 1);
    ScanLow    _ - ScanHi;

    for ThisAdj _ ScanHi downto ScanLow do
    begin "comb"
      NewIdx _ FirstLineChanged;

      if (ThisAdj > 0) then
	incr(NewIdx, ThisAdj);

      OldIdx _ FirstLineChanged;

      if (ThisAdj < 0) then
	decr(OldIdx, ThisAdj);

      SweepCnt   _ SweepSize - abs(ThisAdj);
      ThisWeight _ 0;

      for Sweep _ 1 upto SweepCnt do
      begin "sweep"
	if (R!Hash[OldIdx] = W!Hash[NewIdx]) then
	  if (R!Hash[OldIdx] = BlankHash) then
	    incr(ThisWeight, R!WB)
	  else
	    incr(ThisWeight, R!WNB);

	incr(OldIdx);
	incr(NewIdx);
      end "sweep";

      if (ThisWeight > BestWeight) then
      begin
	BestWeight _ ThisWeight;
	BestAdj    _ ThisAdj;
      end;
    end "comb";

    ! Is the best weight good enough? ;

    if (BestWeight < R!WX) then
      goto EndOfVerticalAdjustment;

    ! Don't exceed T!MaxS ;

    if (abs(BestAdj) > T!MaxS) then
      goto EndOfVerticalAdjustment;

    ! Adjust the screen with insert/delete line ops ;

    if (BestAdj < 0) then
    begin
      T!CPos(FirstLineChanged, 1);

      for Line _ -1 downto BestAdj do
	T!DL;

      T!CPos(T!Lines - 1 + BestAdj, 1);

      for Line _ -1 downto BestAdj do
	T!IL;

      for R!Row _ FirstLineChanged upto (T!Lines - 2) do
      begin
	Line _ R!Row - BestAdj;

	if (Line < (T!Lines - 1)) then
	begin
	  for R!Col _ 1 upto BufferWidth do
	    R!Buf[R!Row, R!Col] _ R!Buf[Line, R!Col];

	  R!Hash[R!Row] _ R!Hash[Line];
	end
	else
	begin
	  for R!Col _ 1 upto BufferWidth do
	    R!Buf[R!Row, R!Col] _ cvasc("     ");

	  R!Hash[R!Row] _ BlankHash;
	end;
      end;
    end
    else if (BestAdj > 0) then
    begin
      T!CPos(T!Lines - 1 - BestAdj , 1);

      for Line _ 1 upto BestAdj do
	T!DL;

      T!CPos(FirstLineChanged, 1);

      for Line _ 1 upto BestAdj do
	T!IL;

      for R!Row _ (T!Lines - 2) downto FirstLineChanged do
      begin
	Line _ R!Row - BestAdj;

	if (Line < FirstLineChanged) then
	begin
	  for R!Col _ 1 upto BufferWidth do
	    R!Buf[R!Row, R!Col] _ cvasc("     ");

	  R!Hash[R!Row] _ BlankHash;
	end
	else
	begin
	  for R!Col _ 1 upto BufferWidth do
	    R!Buf[R!Row, R!Col] _ R!Buf[Line, R!Col];

	  R!Hash[R!Row] _ R!Hash[Line];
	end;
      end;
    end;

    T!Flush;

    EndOfVerticalAdjustment:
  end "vertical adjustment";


  ! Now do fixups on a line by line basis ;

  for R!Row _ 1 upto (T!Lines min (BufferLength * 5)) do
  begin "each row"
    own integer
      NewLength,
      OldLength,
      I,
      Temp!New!BP,
      Temp!Old!BP;
    label
      EndOfLine;

    if (PuntIfKeyHit and T!ChrP) then
    begin
      T!Flush;
      return;
    end;

    OldIDX _ location(R!Buf[R!Row, 1]);
    NewIDX _ location(Buffer[R!Row, 1]);

    start!code
      label
	loop;

      setzm	ChangeP;	! no changes seen yet ;
      move	1, BufferWidth;
      move	2, OldIDX;	! point to old words ;
      move	3, NewIDX;	! point to new words ;

      loop:
      move	4, (2);		! pick up old value ;
      came	4, (3);		! compare with new value ;
       setom	ChangeP;	! a change! ;
      addi	2, 1;
      addi	3, 1;
      sojg	1, loop;
    end;

    if (not ChangeP) then
      goto EndOfLine;

    New!BP _ point(7, Buffer[R!Row, 1], 6);
    Old!BP _ point(7, R!Buf[R!Row, 1], 6);

    Temp!New!BP _ New!BP;
    Temp!Old!BP _ Old!BP;
    NewLength   _ OldLength _ 0;

    for I _ 1 upto (T!Width min (BufferWidth * 5)) do
    begin
      if (ldb(Temp!New!BP) neq " ") then NewLength _ I;
      if (ldb(Temp!Old!BP) neq " ") then OldLength _ I;
      ibp(Temp!New!BP);
      ibp(Temp!Old!BP);
    end;


    ! look for the first difference between the two lines ;
    ! compute the adjustment factor ;
    ! adjust the line with insert/delete character ;

    ! now fix the rest of the line ;

    Cursor!BP _ 0;
    R!Col     _ 1;

    while (R!Col <= (T!Width min (BufferWidth * 5))) do
    begin "fix a line"
      Old!C _ ldb(Old!BP);
      New!C _ ldb(New!BP);

      if ((R!Col > NewLength) and (Old!C neq " " ) and T!ELP) then
      begin
	if (R!Col <= OldLength) then
	begin
	  R!SetCursor(Buffer);
	  T!El;
	end;

	done "fix a line";
      end
      else if (New!C neq Old!C) then
      begin
	R!SetCursor(Buffer);
	T!OutC(New!C);
	Cursor!BP _ New!BP;
	ibp(Cursor!BP);
      end;

      ibp(Old!BP);
      ibp(New!BP);
      incr(R!Col);
    end "fix a line" ;

    ! here do do end of line bookkeeping ;

    EndOfLine:

    for R!Col _ 1 upto BufferWidth do
      R!Buf[R!Row, R!Col] _ Buffer[R!Row, R!Col];

    R!Hash[R!Row] _ W!Hash[R!Row];
  end "each row" ;


  ! Now put the cursor to rest ;

  if (FinalRow and FinalColumn) then
  begin
    R!Row _ FinalRow;
    R!Col _ FinalColumn;
    R!SetCursor(Buffer);
  end;

  T!Flush;
end "redisplay";
end "Redisplay for a Canonical CRT";


! **************************  End Redisp.Sai  ****************************;
        2UTIL.SAI     Ä16-Feb-84 14:05:33  YAGQUB    Entry;
begin "Peak Utility Module"
  require "Ded.Def" source!file;
!! title Peak Utility Module ;

! *************************************************************************
*                                                                         *
*                         Utilities used commonly                         *
*                     throughout the Corpus Collosum                      *
*                                 of Peak                                 *
*                                                                         *
**************************************************************************;

  external simple procedure
    W!Msg (string S);                   ! Put a message in the message
                                        ! line.
                                        ;
!! title Rtn ffffp ;
! Find the first free file page in the specified file starting with the
! specified page number, and return its index.
;

ifcr Tops20 thenc
  internal simple integer procedure ffffp (integer Jfn, StartPage(0));
  begin "ffffp"
    integer
      Result;

    start!code
      hrl         1, StartPage;
      hrr         1, Jfn;
      ffffp;
      movem       1, Result;
    end;

    if (Result = -1) then
      return(-1)
    else
      return(rh(Result));
  end "ffffp";
endc
!! title Rtn ufpgs ;
! Update File Page(s), forcing them to disk right now.
;

ifcr Tops20 thenc
  internal simple procedure ufpgs (integer AC1, AC2);
  begin "ufpgs"
    start!code
      move	1, AC1;
      move	2, AC2;
      ufpgs;
        jfcl;
    end;
  end "ufpgs";
endc
!! title Rtn MoveBytes ;
! Move the specified number of bytes from the source to the target.
;
! <<  Who uses this?
;

internal simple procedure MoveBytes (integer SrcPtr, TgtPtr, BytCnt);
begin "MoveBytes"
  start!code
    protect!acs
      1, 2, 3;
    label
      NoWork,
      Loop;

      skipg       3, BytCnt;
      jrst        NoWork;

      move        2, SrcPtr;
      move        4, TgtPtr;
      ldb         1, 2;
      dpb         1, 4;
      sosg        3, BytCnt;
      jrst        NoWork;

    Loop:
      ildb        1, 2;
      idpb        1, 4;
      sojg        3, Loop;

    NoWork:
  end;
end "MoveBytes";
!! title Rtn DoBlt ;
! Perfrom a BLT for the folks.
;

simple procedure DoBlt (integer Src, Dst, DstEnd);
begin "DoBlt"
  start!code
    hrl     1, Src;
    hrr     1, Dst;
    blt     1, DstEnd;
  end;
end "DoBlt";
!! title Rtn Blt ;
! Move words of stuff from one place to the other in the most efficient
! manner possible.
!
!   SrcStart    - Starting address in memory of the source region.
!   DstStart    - Starting address in memory of the destination region.
!   SrcLen      - Length in words of the source region.
;

! <<  This routine is open to severe and subtle optimization.
;

internal simple procedure Blt (integer SrcStart, DstStart, SrcLen);
begin "Blt"
  integer
    I,
    J;

  if (SrcStart = DstStart) then
    return
  else if ((SrcStart > DstStart) or ((SrcStart + SrcLen) < DstStart)) then
  begin
    ! Source does not overlap the destination.
    ;

    arrblt(memory[DstStart], memory[SrcStart], SrcLen);
  end
  else
  begin
    ! Source overlaps destination. Work from the back forwards.
    ;

    J _ DstStart + SrcLen - 1;

    for I _ SrcStart + SrcLen - 1 step -1 until SrcStart do
    begin
      memory[J] _ memory[I];
      decr(J);
    end;
  end;
end "Blt";
!! title Rtn DecrBP ;
! Semi-magic routine to decrement a byte pointer.  Don't worry about it.
;

internal simple integer procedure DecrBP (integer BP);
begin "DecrBP"
  begin!code
    move        T1, BP;                 ! Get the pointer ;
    add         T1, [bit(7,5)];         ! Decrement the pointer ;
    skipge      T1;                     ! If the pointer went negative ;
      sub       T1, [xwd('430000,1)];   !  subtract the backup offset ;
    movem       T1, BP;                 ! Store the result ;
  end;

  return(BP);
end "DecrBP";
!! title Rtn DoErstr ;
! Get error info from Tops-20, and print it out.
;

ifcr Tops20 thenc
  internal simple procedure DoErstr;
  begin "DoErstr"
    integer
      C,
      BP;
    own integer array
      Buf[0:29];
    string
      S;

    arrclr(Buf);
    S _ null;

    start!code
      hrroi       1, access(Buf[0]);
      hrloi       2, '400000;           ! last error in current process ;
      setz 3,;
      erstr;
      jfcl;
      jfcl;
    end;

    BP _ point(7, Buf[0], -1);

    while (C _ ildb(BP)) do
      appnd(S, C);

    W!Msg(S);
  end "DoErstr";
endc
!! title Rtn kequ ;
! Perform a case-independent string comparison and return the results.
! (This heavy-handedness is only necessary on Tops-20 since the SAIL
! compiler there is of more questionable pedigree than that of its
! Tymcom-X counterpart).
! (This code was ripped off from the Tymcom-X FAIL sources for SAIL.)
;

ifcr Tops20 thenc
  internal simple boolean procedure kequ (string Str1, Str2);
  begin "kequ"
    start!code
      define
        A    = 1,
        B    = 2,
        Lpsa = '13,
        Temp = '14,
        User = '15,
        Sp   = '16,
        P    = '17;
      label
        Kaschk,
        Klup,
        Notkeq,
        Keqret;


        hrrz	A, -3(Sp);	! Length of one string;
        exch	B, -1(Sp);	! Length of the other, save extra AC;
        caie	A, (B);		! Same length? (ignore lh of B);
         jrst	Notkeq;		! No, not equal strings;
        move	Lpsa, (Sp);	! One byte pointer;
        move	User, -2(Sp);	! The other byte pointer;
        jrst	klup;		! Go start the loop;

      Kaschk:
        trz	B, '40;		! Clear case bit and check for alphabetic;
        cail	B, "A";		! This makes it upper case when it was;
        caile	B, "Z";		!  either upper case or lower case;
        jrst	Notkeq;		! Not alphabetic - must be mismatch;

      Klup:
        sojl	A, Keqret;	! A will be -1 (=true) on loop termination;
        ildb	Temp, User;	! One character;
        ildb	B, Lpsa;	! Another;
        xor	Temp, B;	! Compare values;
        jumpe	Temp, Klup;	! Exactly equal;
        cain	Temp, '40;	! Differ only by case bit?;
        jrst	Kaschk;		! Yes - Go check more carefully;

      Notkeq:
        movei	A, 0;		! Character mismatch - Return false;

      Keqret:
        move	B, -1(Sp);	! Restore AC;
    end;
  end "kequ";
endc
!! title Rtn chsizef ;
! Return the size in characters of the file open on the specified
! channel.
;

ifcr Tops20 thenc
  internal simple integer procedure chsizef (integer Chan);
  begin "chsizef"
    integer
      OldPos,
      Siz;

    OldPos _ rchptr(Chan);
    schptr(Chan, -1);
    Siz    _ rchptr(Chan);
    schptr(Chan, OldPos);
    return(Siz);
  end "chsizef";
endc
end "Peak Utility Module";


! **************************  End of Util.Sai  ************************** ;
        2WINDOW.SAI   v03-Apr-84 15:26:56  QEYKUP    Entry;
begin "DED - window manager"
  require "DED.DEF" source!file;
!! title Peak Window Manager ;
! *************************************************************************
*                                                                         *
*                               Window.Sai                                *
*                                                                         *
***************************************************************************

        The Peak Window Manager.

**************************************************************************;


!                         From the Command Module
;

  external boolean procedure
    C!ChrP;                             ! Is there a character ready
                                        ! anywhere?
                                        ;
  external integer
    C!Debug;                            ! True if we are debugging.
                                        ;
  external boolean
    G!CRCtl;            		! true if lonely CRs appear as
                                        ! "^m"
                                        ;

!                         From the Buffer Module
;

  external boolean
    B!BegP,                             ! True if point is at the
                                        ! beginning of the buffer.
                                        ;
    B!EndP,                             ! True if point is at the end of
                                        ! the buffer.
                                        ;
    B!ModP;                             ! True if the buffer has been
                                        ! modified. 
                                        ;
  external integer
    B!Lock;                             ! State of the Buffer Lock.
                                        ;
  external string
    B!Mode,                             ! Current editing mode.
                                        ;
    B!File,                             ! The name of the file we are
                                        ! editing. 
                                        ;
    B!Alias;                            ! An alternate display name for
                                        ! the current buffer.
                                        ;
  external integer
    B!WS0,                              ! Index of the Mark indicating
                                        ! the start of Window 0.
                                        ;
    B!WS1;                              ! Index of the Mark indicating
                                        ! the start of Window 1.
                                        ;

  external simple integer procedure
    B!GetM (integer M);                 !  Return the location of a
                                        !  certain Mark. 
                                        ;
  external simple procedure
    B!SetM (integer M, P);              ! Set the location associated
                                        ! with a certain Mark.
                                        ;
  external simple procedure
    B!SetB (integer BufNum);            ! Go to a particular buffer.
                                        ;
  external simple integer procedure
    B!Cnt;                              ! Return the number of buffers in
                                        ! the chain.
                                        ;
  external simple procedure
    B!Move (integer Direction);         ! Move one buffer in some
                                        ! direction. 
                                        ;
  external simple integer procedure
    B!GetP;                             ! Get the location of the point.  
                                        ;
  external simple integer procedure
    B!GetC;                             ! Get the character after the
                                        ! point. 
                                        ;
  external simple procedure
    B!SetP (integer Position);          ! Move the point to a particular
                                        ! location. 
                                        ;
  external simple integer procedure
    B!GetL;                             ! Get the location of the "last"
                                        ! point. 
                                        ;
  external simple procedure
    B!SetL (integer Position);          ! Set the location of the "last"
                                        ! point. 
                                        ;
  external simple integer procedure
    B!Pcnt;                             ! Return the distance in percent
                                        ! of the point into the buffer.
                                        ;

!                        From the Redisplay Module
;

  external integer
    T!Lines,
    T!Width;
  external string
    T!Name;

  external procedure
    T!Bell;

  external procedure
    R!Disp (integer array Buffer;
        boolean PuntIfKeyHit;
        integer CursorRow, CursorCol);

  ! global state stuff ;

  external integer
    G!ESCF,
    G!OverStrikeP,
    G!WrapP,
    C!TABWidth,
    G!FFBreak;
!! title Internal Data Structures ;
! Internal data and structures ;

  ! The screen buffer is available to the redisplay, and *must* be declared
  !  the same size and shape.  ;

  own trusted integer array W!Buf[ 1 : 25, 1 : 27 ];

  ! the help "box" is overlaid on W!Buf iff W!BoxP is true ;

  own internal boolean W!BoxP;
  own trusted integer array W!Box[ 1 : 20, 1 : 12 ];
  own integer W!BoxPnt;

  ! information about the window(s) ;

  internal boolean
    W!IntP;                             ! True iff the window module has
                                        ! been initialized.
                                        ;
  own boolean W!SplitP;			! true iff split window ;
  own integer W!Num;			! window we're in [ 0..1 ] ;
  own internal integer W!Buf0, W!Buf1;	! corresponding buffer # ;
  own integer W!BufNum;			! current buffer # ;
  own integer W!Size0, W!Size1;		! size of the windows ;
  own internal string W!Bar;		! bar to use when split ;

  ! some handy byte pointers and lengths that we want to keep around ;

  own integer W!WindowBP;
  own integer W!StatusLine, W!MsgLine;
  own integer W!StatusBP, W!FixStatusBP, W!FixStatusLen;
  own integer W!MsgBP, W!MsgLen;

  ! for remembering where to put the cursor ;

  own integer SavedCursorRow, SavedCursorColumn;

  ! for forcing the cursor to the end of the message line ;

  internal own boolean W!MsgF;
!! title Rtn W!Init ;
! Initialize the Window module by doing whatever. ;

  forward simple internal procedure W!Badd( string Text );
  forward simple internal procedure W!BClr;

internal simple procedure W!Init;
  begin "init"

    T!Lines := 24;	! ** kludge ** ;

    ! start out with one clean window and one clean box ;

    arrclr( W!Buf, cvasc( "     " ));
    W!BClr;

    ! set up some fresh byte pointers ;

    W!WindowBP := point( 7, W!Buf[ 1, 1 ], -1 );
    W!StatusLine := T!Lines - 1;
    W!StatusBP := point( 7, W!Buf[ W!StatusLine, 1 ], -1 );
    W!MsgLine := T!Lines;
    W!MsgBP := point( 7, W!Buf[ W!MsgLine, 1 ], -1 );

    W!BoxP := false;
    W!SplitP := false;
    W!Num := 0;
    W!Size0 := T!Lines - 2;
    W!Size1 := 0;
    W!Bar := "+-------";

    set(W!IntP);

      ! Indicate to the world that the window has been initialized.
      ;
  end "init";
!! title Rtn W!SetB ;
! Routine used by the buffer module to tell us what buffer #
! corresponds to the current window. ;

internal simple procedure W!SetB( integer BufNum );
  begin

    if ( C!Debug ) then
      W!BAdd( "W!SetB(" & cvs(BufNum) & "), W!Num=" & cvs(W!Num) );

    if ( W!Num ) then
      W!Buf1 := BufNum
    else
      W!Buf0 := BufNum;

    W!BufNum := BufNum;

  end;
!! title Rtn AppendStr ;
! Routines to build and update the status line ;

simple procedure AppendStr( string S; reference integer BP, Len );
  while ( length( S )) do
    begin
      idpb( lop( S ), BP );
      Len := Len + 1;
    end;
!! title Rtn W!FixS ;
! This routine fixes the fixable part of a status line.  (Where we are,
!  if the buffer has been modified, if we have mail). ;

internal simple procedure W!FixS;
begin
  own boolean
    NewMailBit,
    OldMailBit;
  own integer
    Bp,
    Len;

  Bp  _ W!FixStatusBP;
  Len _ W!FixStatusLen;

  if (B!BegP and B!EndP) then
    AppendStr("Empty", Bp, Len)
  else if (B!BegP) then
    AppendStr("Top", Bp, Len)
  else if (B!EndP) then
    AppendStr("Bottom", Bp, Len)
  else
  begin
    AppendStr(cvs(B!Pcnt), Bp, Len);
    AppendStr("%", Bp, Len);
  end;

  AppendStr("-", Bp, Len);

  if (B!ModP) then
    AppendStr(" *", Bp, Len);

  ifcr TymcomX thenc
    begin!code
      setzm	NewMailBit;
      setzm	OldMailBit;

      hrroi	t1, '6;
      calli	t1, '41;
       setz	t1, ;

      trne	t1, '10000;		! jp.mal (old mail) ;
        setom	OldMailBit;
      tlne	t1, '001000;		! jp.mai (new mail) ;
      	setom	NewMailBit;
    end;

    if (OldMailBit or NewMailBit) then
      AppendStr(" Mail", Bp, Len);

    if (NewMailBit) then
      AppendStr("!", Bp, Len);

    if (OldMailBit) then
      AppendStr(".", Bp, Len);
  endc

  while (Len <= T!Width) do
    AppendStr(" ", Bp, Len);
end;
!! title Rtn W!NewS ;
! Routine to build the more permanent part of the status line.
;

internal simple procedure W!NewS;
begin
  own integer
    Bp,
    Len,
    L,
    R;

  Bp  _ W!StatusBP;
  Len _ 0;

  AppendStr(DED!Alias, Bp, Len);
  AppendStr(" " & DED!Major!Version, Bp, Len);
  AppendStr("." & DED!Minor!Version, Bp, Len);
  AppendStr(" (" & DED!Edit!Version & ")", Bp, Len);

  AppendStr(" (", Bp, Len);
  AppendStr(T!Name, Bp, Len);
  AppendStr(" ", Bp, Len);
  AppendStr(B!Mode, Bp, Len);

  if (G!WrapP) then
    AppendStr(",Wrap", Bp, Len);

  if (G!OverStrikeP) then
    AppendStr(",Over", Bp, Len);

  AppendStr(") ", Bp, Len);

  L _ B!Cnt;
  R _ rh(L);
  L _ lh(L);

  if (L) then
  begin
    integer
      I;

    for I _ 1 step 1 until L do
      AppendStr("<", Bp, Len);

    AppendStr(" ", Bp, Len);
  end;

  if (B!Alias) then
    AppendStr(B!Alias, Bp, Len)
  else
    AppendStr(B!File, Bp, Len);

  if (B!Lock) then
    AppendStr(" $", Bp, Len);

  if (R) then
  begin
    integer
      I;

    AppendStr(" ", Bp, Len);

    for I _ 1 step 1 until R do
      AppendStr(">", Bp, Len);
  end;

  AppendStr(" -", Bp, Len);

  ! the remainder of the status line is more readily changeable ;

  W!FixStatusBP _ Bp;
  W!FixStatusLen _ Len;
  W!FixS;
end;
!! title Rtn W!Msg ;
! If the Window Module has been initialized,
!   put something in the message line, and remember how long it is
! otherwise
!   print the message using a standard SAIL print statement.
;

internal simple procedure W!Msg(string S);
begin "W!Msg"
  own integer
    len,
    c,
    bp;

  if (W!IntP) then
  begin
    ! The Window Module has been initialized.
    ;

    W!FixS;

      ! While we're here, insure current status.
      ;

    for len _ 1 upto 27 do
      W!Buf[W!MsgLine, len] _ cvasc("     ");

    bp  _ W!MsgBP;
    len _ 0;

    while (length(S)) do
    begin
      c _ lop(s);

      if ((c >= " ") and (c < DEL)) then
        idpb(c, bp)
      else if (c = ESC) then
      begin
        if (G!ESCF) then
          idpb("$", bp)
        else
        begin
          idpb("^", bp);
          idpb("[", bp);
          incr(len);
        end;
      end
      else
      begin
        idpb("^", bp);

        if (c = NULL) then
          idpb("@", bp)
        else if (c = DEL) then
          idpb("#", bp)
        else
          idpb(c + '100, bp);

        incr(len);
      end;

      incr(len);

      if (len >= T!Width) then
        done;
    end;

    W!MsgLen _ len;
  end
  else
    ! The Window Module has not been initialized.
    ;

    print(S);
end "W!Msg";
!! title Rtn W!Msg2 ;
! Put something at the right margin of the message line.
! by convention, the string *must* be printable ascii ;

internal procedure W!Msg2( string S );
  begin
    integer BP, L, I;
    BP := W!MsgBP;
    L := length( S );
    for I := 1 upto ( T!Width - L - 1 ) do ibp( BP );
    while ( length( S )) do idpb( lop( S ), BP );
  end;

!! title Rtn W!GetS ;
! Return the start of the current window ;

internal simple integer procedure W!GetS;
begin
  return
  (
    if (W!Num = 1) then
      B!GetM(B!WS1)
    else
      B!GetM(B!WS0)
  );
end;
!! title Rtn W!SetS ;
! Set the start of the current window ;

internal simple procedure W!SetS (integer Position);
begin
  if (W!Num = 1) then
    B!SetM(B!WS1, Position)
  else
    B!SetM(B!WS0, Position);
end;
!! title Rtn W!Size ;
! Return the size of the current window ;

internal simple integer procedure W!Size;
  begin
    if ( W!Num = 1 ) then
      return( W!Size1 )
    else
      return( W!Size0 );
  end;
!! title Rtn ReFrame ;
! Reframe a window whose point has gone wandering off.  Try to put the
!  point in the middle of the current window, unless we run into the
!  beginning of the buffer, or a <FF>, first.  Allow for line wrap,
!  if set.  Unfortunately, TABs are very hard to allow for at this point.
!
! 10/27/82/DWS  CharCount is a foolish attempt to keep reframe from
!  failing (resulting in the 'W!BSet lost big' errors).
;

simple procedure ReFrame;
  begin "reframe"
    own integer SavePoint, C, CharCount, LineCount, SizeDiv2;

    SizeDiv2 := W!Size div 2;
    LineCount := 1;
    CharCount := 1;

    SavePoint := B!GetP;

    while ( LineCount < SizeDiv2 ) do
      begin "line"

        C := NULL;
	if ( B!BegP ) then done "line";

	B!Move( BACKWARDS );
	C := B!GetC;

	if ( C = FF ) then
	  done "line"
	else if ( C = LF ) then
	  begin
	    LineCount := LineCount + 1;
	    CharCount := 1;
	  end
	else
	  CharCount := CharCount + 1;

	if ( CharCount = T!Width ) then
	  begin
	    Linecount := Linecount + 1;
	    CharCount := 1;
	  end;

      end "line";

    if (( C = LF ) or ( C = FF )) then
      B!Move( FORWARDS )
    else if ( not B!BegP ) then
      B!Move( FORWARDS );

    W!SetS( B!GetP );
    B!SetP( SavePoint );

  end "reframe";
!! title Rtn BuildBar ;
! Put up the bar in the window ;

procedure BuildBar;
  begin
    integer P, C, W;  string Bar;

    P := point( 7, W!Buf[ ( W!Size0 + 1 ), 1 ], -1 );
    Bar := NULL;

    W := 0;
    while ( W < T!Width ) do
      begin
	if ( not length( Bar )) then
	  Bar := W!Bar;
	C := lop( Bar );
	if (( C < " " ) or ( C > '176 )) then C := "?";
	idpb( C, P );
	W := W + 1;
      end;

  end;
!! title Rtn W!BSet ;
! Routine to turn on/off the box ;

internal procedure W!BSet( boolean OnFlag );
  begin
    W!BoxP := OnFlag;
    if (( not OnFlag ) and W!SplitP ) then
      BuildBar;
  end;
!! title Rtn W!BClr ;
! Routine to rebuild the box ;

simple internal procedure W!BClr;
  begin "clear the box"
    integer I;

    arrclr( W!Box, cvasc( "     " ));

    for I := 2 upto 11 do
      W!Box[1,I] := W!Box[20,I] := cvasc( "-----" );

    for I := 2 upto 19 do
      begin
	W!Box[I,1] := cvasc( "!    " );
	W!Box[I,12] := cvasc( "    !" );
      end;

    W!Box[1,1] := W!Box[20,1] := cvasc( "+----" );
    W!Box[1,12] := W!Box[20,12] := cvasc( "----+" );

    W!BoxPnt := 1;

  end "clear the box";
!! title Rtn W!BMsg ;
! Routine to put text into the box.  Note that to the outside
! world the inside of the box is 18x56, not 20x60. ;

simple internal procedure W!BMsg( integer Line; string Text );
  begin "put a message into the box"
    integer Width, C, BP;

    if (( Line < 1 ) or ( Line > 18 )) then
      usererr( 0,0,"Bad call to W!BMsg, Line="&cvs(Line),"x" );

    BP := point( 7, W!Box[ 1 + Line, 1 ], -1 );
    ibp( BP ); ibp( BP );

    Width := 1;
    while (( Width <= 56 ) and length( Text )) do
      begin
	C := lop( Text );
	if (( C < " " ) or ( C > '176 )) then C := "?";	! ** hack ** ;
	idpb( C, BP );
	Width := Width + 1;
      end;

    W!BoxPnt := Line;

  end "put a message into the box";
!! title Rtn W!BAdd ;
! Routine to "append" text to the bottom of the box, scrolling
! other text up. ;

internal simple procedure W!BAdd( string Text );
  begin
    own integer I, J;

    W!BoxPnt := W!BoxPnt + 1;
    if ( W!BoxPnt < 19 ) then
      W!BMsg( W!BoxPnt, Text )
    else
      begin
	for I := 2 upto 18 do
	  for J := 1 upto 12 do
	    W!Box[ I, J ] := W!Box[ 1 + I, J ];
	for J := 2 upto 11 do W!Box[ 19, J ] := cvasc( "     " );
	W!Box[ 19, 1 ] := cvasc( "!    " );
	W!Box[ 19,12 ] := cvasc( "    !" );
	W!BMsg( 18, Text );
      end;
  end;

!! title Rtn W!Fill ;
! Rebuild the pertinent part of the window.  Return true iff we've seen
! the point while rebuilding.
;

simple boolean procedure W!Fill (integer WindowToFill);
begin "W!Fill"
  own boolean
    PointSeen;
  own integer
    C,
    Column,
    CurrentLine,
    I,
    J,
    Line!BP,
    LinesToFill,
    SavePoint;

  PointSeen _ false;
  SavePoint _ B!GetP;

  if (WindowToFill = 0) then
  begin
    B!SetP(B!GetM(B!WS0));
    CurrentLine _ 1;
    LinesToFill _ W!Size0;
  end
  else
  begin
    B!SetP(B!GetM(B!WS1));
    CurrentLine _ W!Size0 + 2;
    LinesToFill _ W!Size1;
  end;

  for I _ CurrentLine upto (CurrentLine + LinesToFill - 1) do
    for J _ 1 upto 27 do
      W!Buf[I, J] _ cvasc("     ");

  Line!BP _ point(7, W!Buf[CurrentLine, 1], -1);
  Column  _ 1;

  while (true) do
  begin "fill a window"
    if (Column >= T!Width) then
    begin "wrap"
      boolean
        AlreadyAtEol;

      clear(AlreadyAtEol);

      if ((Column = T!Width) and (B!GetC neq CR)) then
	idpb("|", Line!BP)
      else
      begin
	if ((B!GetP = SavePoint) and (WindowToFill = W!Num)) then
	begin
	  PointSeen         _ true;
	  SavedCursorRow    _ CurrentLine;
	  SavedCursorColumn _ Column;
	end;
	B!Move(FORWARDS);
	if (B!GetC = LF) then
	  B!Move(FORWARDS)
	else if (G!CRCtl) then
	  idpb("^", Line!BP)
	else
	  idpb("&", Line!BP);

        set(AlreadyAtEol);
      end;	

      if (not G!WrapP and not AlreadyAtEol) then
	while (true) do
	begin "move to EOL";
	  if ((B!GetP = SavePoint) and (WindowToFill = W!Num)) then
	  begin
	    PointSeen         _ true;
	    SavedCursorRow    _ CurrentLine;
	    SavedCursorColumn _ Column;
	  end;

	  if (B!EndP) then
	    done "fill a window";

	  C _ B!GetC;
	  B!Move(FORWARDS);

	  if (C = FF) then
	    done "fill a window";

	  if (C = CR) then
	  begin
	    if (B!GetC = LF) then
	      B!Move(FORWARDS);

	    done "move to EOL";
	  end;
	end "move to EOL";

      decr(LinesToFill);

      if (not LinesToFill) then
	done "fill a window";

      incr(CurrentLine);
      Line!BP _ point(7, W!Buf[CurrentLine, 1], -1);
      Column  _ 1;
    end "wrap" ;

    if (B!GetP = SavePoint and WindowToFill = W!Num) then
    begin
       PointSeen         _ true;
       SavedCursorRow    _ CurrentLine;
       SavedCursorColumn _ Column;
    end;

    if (B!EndP) then
      done "fill a window";

    C _ B!GetC;
    B!Move(FORWARDS);

    if (C = CR) then
    begin "CR"
      if (B!GetC = LF) then
      begin "CRLF"
	if (B!GetP = SavePoint) then
	begin
	   PointSeen         _ true;
	   SavedCursorRow    _ CurrentLine;
	   SavedCursorColumn _ Column;
	end;

	B!Move(FORWARDS);
      end "CRLF"
      else
      begin
	if (G!CRCtl) then
	begin
	  idpb("^", Line!BP);
	  idpb("M", Line!BP);
	end
	else
	begin "overstrike"
	  while (Column < T!Width) do
	  begin
	    ibp(Line!BP);
	    incr(Column);
	  end;

	  idpb("&", Line!BP);
	end "overstrike";
      end;

      decr(LinesToFill);

      if (not LinesToFill) then
	done "fill a window";

      incr(CurrentLine);
      Line!BP _ point(7, W!Buf[CurrentLine, 1], -1);
      Column  _ 1;
    end "CR"
    else if (C = FF) then
    begin "FF"
      idpb("^", Line!BP);  idpb("L", Line!BP);

      if (G!FFBreak) then
	done "fill a window";

      decr(LinesToFill);

      if (not LinesToFill) then
	done "fill a window";

      incr(CurrentLine);
      Line!BP _ point(7, W!Buf[CurrentLine, 1], -1);
      Column  _ 1;
    end "FF"
    else if ((C = TAB) and (C!TABWidth)) then
    begin "tab"
      while (Column mod C!TABWidth) do
      begin
	ibp(Line!BP);
	incr(Column);
      end;

      ibp(Line!BP);
      incr(Column);
    end "tab"
    else if ((C = ESC) and (G!ESCF)) then
    begin "ESC"
      idpb("$", Line!BP);
      incr(Column);
    end "ESC"
    else if ((C < " ") or (C = '177)) then
    begin "control character"
      if (Column = (T!Width - 1)) then
      begin
	idpb("|", Line!BP);
	incr(Column);
	B!Move(BACKWARDS);
      end
      else
      begin
	idpb("^", Line!BP);

	if (C = 0) then
	  idpb("@", Line!BP)
	else if (C = '177) then
	  idpb("#", Line!BP)
	else
	  idpb(C + '100, Line!BP);

	incr(Column, 2);
      end;
    end "control character"
    else
    begin "normal character"
      idpb(C, Line!BP);
      incr(Column);
    end "normal character";
  end "fill a window" ;

  B!SetP(SavePoint);
  return(PointSeen);
end "W!Fill";
!! title Rtn W!Frame ;
! check the framing for the current window ;

internal simple procedure W!Frame;
  begin
    if ( not W!Fill( W!Num ) ) then
      ReFrame;
  end;
!! title Rtn W!Set ;
! Set things up for the redisplay. ;

internal simple procedure W!Set;
  begin "set up the windows"
    own integer I, J;

    if (( W!Buf0 = W!BufNum ) and ( not W!Fill( 0 )) and ( W!Num = 0 )) then
      begin
	W!Frame;
	W!FixS;
	if ( not W!Fill( 0 ) ) then
	  usererr( 0,0, "W!Set lost big!" );
      end;

    if ( W!SplitP and
	( W!Buf1 = W!BufNum ) and ( not W!Fill( 1 )) and ( W!Num = 1 )) then
      begin
	W!Frame;
	W!FixS;
	if ( not W!Fill( 1 ) ) then
	  usererr( 0,0, "W!Set lost big!" );
      end;

    ! overlay the help box, if W!BoxP is true ;

    if ( W!BoxP ) then
      begin "box"
	for I := 1 upto 20 do
	  for J := 1 upto 12 do
	    W!Buf[ 1 + I, 2 + J ] := W!Box[ I, J ];
      end "box";

  end "set up the windows";
!! title Rtn W!2 ;
! Split the screen into two windows ;

internal procedure W!2;
  begin

    if ( W!SplitP ) then
      T!Bell
    else
      begin
	W!SplitP := true;
	W!Num := 1;		! just for kicks, put us in the bottom ;
	W!Buf1 := W!Buf0;
	W!Size1 := W!Size0 div 2;
	W!Size0 := W!Size0 - W!Size1 - 1;
        B!SetM(B!WS1, B!GetM(B!WS0));
	BuildBar;
	B!SetL( B!GetP );
	if ( C!Debug ) then
	  W!BAdd( "[split screen]" );
      end;
  end;
!! title Rtn W!1 ;
! Remove the "other" window of a split screen ;

internal procedure W!1;
begin
  integer
    T;

  if (not W!SplitP) then
    T!Bell
  else
  begin
    W!SplitP _ false;

    if (W!Num = 1) then 
      if (W!Buf0 = W!Buf1) then
        B!SetM(B!WS0, B!GetM(B!WS1))
      else
	W!Buf0 _ W!Buf1;

    B!SetM(B!WS1, -2);                  ! Window 1 is now undefined ;
    W!Buf1 _ 0;

    W!Num _ 0;
    W!Size0 _ W!Size0 + W!Size1 + 1;
    W!Size1 _ 0;
  end;
end;
!! title Rtn W!Grow ;
! Routine to grow a window ;

internal simple procedure W!Grow;
  begin
    if ( not W!SplitP ) then
      T!Bell
    else if ( W!Num ) then
      begin
	if ( W!Size0 > 2 ) then
	  begin
	    W!Size0 := W!Size0 - 1;
	    W!Size1 := W!Size1 + 1;
	    BuildBar;
	  end
	else
	  T!Bell;
      end
    else
      begin
	if ( W!Size1 > 2 ) then
	  begin
	    W!Size1 := W!Size1 - 1;
	    W!Size0 := W!Size0 + 1;
	    BuildBar;
	  end
	else
	  T!Bell;
      end;
  end;
!! title Rtn W!Switch ;
! Routine to switch between windows. ;

internal procedure W!Switch;
begin
  integer
    T;

  if (not W!SplitP) then
    W!Msg("Window is not split.")
  else
  begin
    if (W!Buf0 = W!Buf1) then
    begin
      T _ B!GetP;
      B!SetP(B!GetL);
      B!SetL(T);
      W!Num _ 1 - W!Num;
      W!NewS;
    end
    else
    begin
      W!Num _ 1 - W!Num;

      if (W!Num = 0) then
	B!SetB(W!Buf0)
      else
	B!SetB(W!Buf1);

      W!NewS;
    end;
  end;
end;
!! title Rtn W!Disp ;
! The editor interfaces to the redisplay through W!Disp.  It is
! responsible for building the correct image to present to the
! redisplay.
;

  internal procedure W!Disp (boolean PuntFlag);
  begin "W!Disp"
    ;
    if (not C!ChrP) then
    begin
      ! If there is not a character waiting for input from some source.
      ;

      W!Set;

      if (W!MsgF) then
        R!Disp(W!Buf, PuntFlag, T!Lines, W!MsgLen + 1)
      else
        R!Disp(W!Buf, PuntFlag, SavedCursorRow, SavedCursorColumn);
      
    end;
  end "W!Disp";
end "DED - window manager" ;


! **************************  End Window.Sai  ****************************;
     2XBUFF.SAI    #ç13-Apr-84 14:46:56  KABGUW    Entry;
begin "DED - buffer manager"
  require "DED.DEF" source!file;
!! title Tymcom-X Buffer/Gap Manager ;

ifcr Tops20 thenc
  require "!!!! You're compiling the wrong buffer module !!!!" message;
  require "!!!! This one is for Tymcom-X only.           !!!!" message;
  TryAgainWithTheCorrectModule
endc


! *************************************************************************
*									  *
*		The buffer/gap manager.  Tymcom-X version.		  *
*		       Dave W. Smith,  September '81			  *
*									  *
**************************************************************************;


! <<  Open does not allow '.' in usernames.  This is a SAIL bug.  We must
!     work around by doing chanios or callis ourselves.
! <<  Reformat this page!!!
;

!                         From the Command Module
;

  external boolean
    G!TextMode;                                 ! True if we are in Text
                                                ! Mode.
                                                ;
  external safe integer array
    C!Tab ['0:'177];

  external         integer	!skip!;		! skip-return flag for
						!  startcode;
  external         integer	C!Debug;	! True if we are debugging;


  external simple integer procedure
    DecrBP (integer BP);

  external boolean procedure	F!Writ( string FileName );


  external         procedure	W!SetB( integer BufNum );
  external         procedure	W!Msg( string Msg );  ! display a message ;
  external         procedure	W!FixS;		! to cause update of
						!  status line ;
  external         procedure	W!NewS;		! set to build new status line;
  external         procedure	W!BClr;
  external         procedure	W!BAdd( string Msg );


  external         procedure	T!Bell;
  external         integer	T!Lines;	! size of physical window ;
!! title Internal Storage ;
! Internal storage and such ;

  own integer B!Addr;		! address of buffer space ;
  own integer B!Pages;		! number of pages mapped ;
  own boolean B!NullFlag;	! true if Nulls in buffer ;


! Storage for buffer descriptors ;

  own integer B!!Head;		! head of active buffer list ;
  own integer B!!List;		! pointer into list ;
  own integer B!!Free;		! head of free list ;

  own trusted integer array B!!Next   [1:BUFMAX];
  own trusted integer array B!!Last   [1:BUFMAX];
  own trusted string  array B!!Mode   [1:BUFMAX];
  own trusted string  array B!!File   [1:BUFMAX];
  own trusted string  array B!!Alias  [1:BUFMAX];
  own trusted boolean array B!!ModP   [1:BUFMAX];
  own trusted integer array B!!Lock   [1:BUFMAX];
  own trusted integer array B!!Size   [1:BUFMAX];
  own trusted integer array B!!Point  [1:BUFMAX];
  own trusted integer array B!!GStart [1:BUFMAX];
  own trusted integer array B!!GSize  [1:BUFMAX];
  own trusted integer array B!!WS0    [1:BUFMAX];
  own trusted integer array B!!WS1    [1:BUFMAX];

! ------------------------------------------------------------------------;

!                    Regarding User and Internal Marks
!
!
!       We define two areas in the array which contains all marks
!       maintained by Peak, the User Marks area (in the range [0,
!       #UserMarks - 1]) and the Real Marks area ([FirstMark,
!       MaxMarks-1]).
!
!
!                          --------------------
!                          |                  | User Marks
!                          |                  |
!                          --------------------
!                          |                  | Real Marks
!                          |                  |
!                          |                  |
!                          |                  |
!                          |                  |
!                          --------------------
!
!
!       User Marks are distinguished in the sense that they are finite in
!       number (determined at compile time), and that they are
!       pre-allocated to the index range [0, #UserMarks - 1].
!
!       When the user sets a mark, a slot in the Real Marks area is
!       allocated, and its index placed in the appropriate User Mark
!       slot.
!
!       When an internal routine allocates a mark, the index in the Real
!       Marks range of the allocated mark is returned.
!
!       Mark-updating procedures in the insert and delete operations deal
!       only with marks allocated in the Real Marks area, thus keeping the
!       amount of maintenance work done to a minimum.
!
!
;

  define
    #UserMarks     = {10},
    FirstMark      = {#UserMarks},
    #InternalMarks = {30},
    MaxMarks       = {((2 * #UserMarks) + #InternalMarks)};

  own integer
    MarkCnt;

      ! The number of Real Marks allocated at the current time.
      ;

  own trusted integer array
    Marks[0 : MaxMarks - 1];

      ! The array containing the entire Mark structure.
      ;


! ------------------------------------------------------------------------;


! Static per-buffer storage ;

  internal integer B!Chan;	! channel used for swapping, i/o ;
  internal string  B!Mode;	! mode(s) that apply to this buffer ;
  internal string  B!File;	! filename the buffer came from ;
  internal integer B!Prot;	! buffer's protection code ;
  internal string  B!Alias;	! "alias" for filename ;

  own integer B!Size;		! size of buffer in characters ;
  own integer B!Point;		! pointer into the buffer ;
  own integer B!LastP;          ! Mark Index of the Last Position pointer
                                ;

  internal boolean B!BegP;	! true iff point is at 0 ;
  internal boolean B!EndP;	! true iff point is at B!Size ;
  internal boolean B!ModP;	! true iff buffer has been modified ;
  internal integer B!Lock;

  internal integer B!WS0;	! Mark Index of the starting point of the
                                ! first window.
                                ;
  internal integer B!WS1;	! Mark Index of the starting point of the
                                ! second window.
                                ;

  internal integer B!CkPtSer;	! serial number of the checkpoint file ;
  internal integer B!DedVer;	! version number of the editor that
				!  created the checkpoint file;


  own integer B!GapStart;	! beginning of gap ;
  own integer B!GapSize;	! size of gap ;


! ************************************************************************;


! Storage for things other than buffers ;

  ! static storage for byte pointers ;

  own integer
    B!GapPriorBP,	! byte pointer to character before gap ;
    B!GapStartBP,	! byte pointer to first byte of gap ;
    B!GapEndBP,		! byte pointer to end of gap ;
    B!GapNextBP,	! byte pointer to character after gap ;
    B!PntBP;		! byte pointer to character at point ;


! the following magic is used to build byte pointers.  The five numbers
!  point to the 0th, 1st, ... 4th 7 bit characters in a 36 bit word. ;

  preset!with
      hl('350700),
      hl('260700),
      hl('170700),
      hl('100700),
      hl('010700);

  own safe integer array B!BPLeft [0:4];


! ************************************************************************;
!! title Rtn VCreate ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=				Rtn VCreate				  =
=                                                                         =
=                                                                         =
=====================================+=====================================


				yamm (4-3)

	Create a range of pages in a process's Virtual Memory Map.


==========================================================================;


  simple integer procedure VCreate (integer VMPage, Count(1), Prot(3); boolean OtherFrame(false));
  begin "VCreate"
    integer
      Tmp;

    Tmp _
	calli(
	  ((if (OtherFrame) then bit(1) else 0) lor
	      bit((Prot land !mask(2)), 7) lor
	      xwd((Count land !mask(10)), VMPage)),
	  -'67
	);

    return(if (!skip!) then 0 else Tmp);
  end "VCreate";


! ===================================+=====================================
==========================================================================;
!! title Rtn VClear ;
! =========================================================================
=====================================+=====================================
=                                                                         =
=                                                                         =
=				Rtn VClear				  =
=                                                                         =
=                                                                         =
=====================================+=====================================


				yamm (4-4)

	Remove a range of pages from a process's Virtual Memory Map.
	Ignores "page does not exist" errors.


==========================================================================;


  simple integer procedure VClear (integer VMPage, Count(1); boolean RefBit(true), OtherFrame(false));
  begin "VClear"
    integer
      Tmp;

    Tmp _
	calli(
	  ((if (OtherFrame) then bit(1) else 0) lor
	      (if (RefBit) then bit(7) else 0) lor
	      xwd((Count land !mask(10)), VMPage)),
	  -'66
	);

    return(if (!skip!) then 0 else Tmp);
  end "VClear";


! ===================================+=====================================
==========================================================================;
!! title Rtn B!GtChan ;
! Open the next availible disk channel for dump mode I/O and return that
  channel's identity.  (Note that this channel number will be in the range
  [1, '17] and will not collide with other channel allocations.) ;

simple integer procedure B!GtChan;
begin "B!GtChan"
  integer
    Channel,
    Flag;

  if ((Channel _ getchan) = -1) then
    usererr(0, 0, "Out of channels in B!GtChan!", "x");

  open(Channel, "DSK", bit(23)+'17, 0, 0, 0, 0, Flag _ true);

  if (Flag) then
    usererr(0, 0, "Open Error in B!GtChan!", "x");

  return(Channel);
end "B!GtChan";
!! title Rtn B!RlChan ;
! Release the specified channel ;

simple procedure B!RlChan (integer Channel);
begin "B!RlChan"
  release(Channel);
end "B!RlChan";
!! title Rtn B!Init ;
! Initialize the buffer system by grounding the active list pointer and
!  linking all buffers into the free list. ;

internal simple procedure B!Init;
begin "init"
  own integer
    I;

  B!DedVer   _ DED!Version!Word;	! The current version of PEAK ;
  B!Addr     _ BasePage * 512;		! ** hack ** start with page 100 ;
  B!Pages    _ 0;			! ** hack ** and nothing mapped ;
  B!!Head    _ 0;			! no list, yet ;
  B!!List    _ 0;			! no buffers on active list ;
  B!!Free    _ 1;			! link all buffers to free list ;

  for I _ 1 upto BUFMAX - 1 do
    B!!Next[I] _ I + 1;

  B!!Next[BUFMAX] _ 0;

  B!Chan _ B!GtChan;		! Establish the buffer I/O channel ;
end "init";
require B!Init initialization;
!! title Rtn DeleteBuffer ;
! Delete the buffer file open on the specified channel ;

simple procedure DeleteBuffer (integer Channel);
begin "DeleteBuffer"
  start!code
    move	1, Channel;
    hrli	1, '11;		! .CHREN == 11 ;
    setzb	2, 3;
    setzb	4, 5;
    chanio	1, 2;		! delete the file ;
      jfcl;
  end;
end "DeleteBuffer";
!! title Rtn B!FreeP ;
! Routine to tell us if we have any free buffers left. ;

internal simple boolean procedure B!FreeP;
  return( B!!Free neq NULL );
!! title Rtn NameCheckpointFile ;
! Return the components of the checkpoint file name in sixbit. ;

simple procedure NameCheckpointFile (reference integer FName, Ext);
begin
  FName := cvsix(cvs(1000 + call(0, "Pjob"))[2 for 3] &
      DED!Alias[1 for 3]);
  Ext := cvsix(cvs(1000 + B!!List)[2 for 3]);
end;
!! title Rtn CloseCheckpointFile ;
! Close a checkpoint file ;

simple procedure CloseCheckpointFile;
begin
  start!code
    move	1, B!Chan;
    hrli	1, 1;			! .CHCLS == 1 ;
    chanio	1, 0;			! close the file ;
  end;
end;
!! title Rtn EnterCheckpointFile ;
! Enter a checkpoint file ;

simple boolean procedure EnterCheckpointFile( integer Name, Ext );
begin
  integer
    Error;

  start!code
    setzm	Error;
    move	1, B!Chan;
    hrli	1, 5;			! .CHENT == 5 ;
    move	2, Name;
    move	3, Ext;
    setzb	4, 5;
    chanio	1, 2;
      movem	3, Error;		! error code is in rh( 3 ) ;
  end;

  return( not Error );
    ! <<  You lose the identity of the error condition this way ;
end;
!! title Rtn LookupCheckpointFile ;
! Lookup a checkpoint file ;

simple boolean procedure LookupCheckpointFile( integer Name, Ext );
begin
  integer
    Error;

  start!code
    move	1, B!Chan;		! channel ;
    hrli	1, 4;			! .CHLK == 4  (lookup) ;
    move	2, Name;
    hllz	3, Ext;
    setzb	4, 5;
    setzm	Error;
    chanio	1, 2;
      setom	Error;
  end;

  return( not Error );
    ! <<  You lose the identity of the error condition this way ;
end;
!! title Rtn CreateCheckpointFile ;
! Create a checkpoint file ;

simple procedure CreateCheckpointFile;
begin
  integer
    Name, Ext;

  NameCheckpointFile(Name,Ext);

  if ( LookupCheckpointFile( Name, Ext ) ) then
    print( crlf & "Checkpoint file already exists!" &
	"  Continue at your own peril." );

  CloseCheckpointFile;
end;
!! title Rtn B!Checkpoint ;
! Flush information that we keep in static locations back
!  into the buffer descriptor block.  Also flush the in-core image
!  to a "checkpoint file" on disk. ;

internal simple procedure B!Checkpoint;
begin
  integer
    I,
    Size, Name, Ext;
  own safe integer array
    IOWDlist[0:2],
    CheckRec[0:127];

  arrclr(CheckRec);

  B!!File[B!!List]    _ B!File;
  B!!Alias[B!!List]   _ B!Alias;

			CheckRec[0] _ cvsix("*PEAK*");
  B!!Point[B!!List]   _ CheckRec[1] _ B!Point;
  B!!Size[B!!List]    _ CheckRec[2] _ B!Size;
  B!!ModP[B!!List]    _ CheckRec[3] _ B!ModP;
  B!!Lock[B!!List]    _ CheckRec[4] _ B!Lock;
  B!!GStart[B!!List]  _ CheckRec[5] _ B!GapStart;
  B!!GSize[B!!List]   _ CheckRec[6] _ B!GapSize;
  B!!WS0[B!!List]     _ CheckRec[7] _ B!WS0;
  B!!WS1[B!!List]     _ CheckRec[8] _ B!WS1;

  ! now expand the name & alias into the record ;

  CheckRec[9]  _ cvasc(B!File[1 for 5]);
  CheckRec[10] _ cvasc(B!File[6 for 5]);
  CheckRec[11] _ cvasc(B!File[11 for 5]);
  CheckRec[12] _ cvasc(B!File[16 for 5]);
  CheckRec[13] _ cvasc(B!File[21 for 5]);

  CheckRec[14] _ cvasc(B!Alias[1 for 5]);
  CheckRec[15] _ cvasc(B!Alias[6 for 5]);
  CheckRec[16] _ cvasc(B!Alias[11 for 5]);
  CheckRec[17] _ cvasc(B!Alias[16 for 5]);
  CheckRec[18] _ cvasc(B!Alias[21 for 5]);
  CheckRec[19] _ cvasc(B!Alias[26 for 5]);
  CheckRec[20] _ cvasc(B!Alias[31 for 5]);

  CheckRec[21] _ incr(B!CkPtSer);
  CheckRec[22] _ B!DedVer;
  CheckRec[23] _ B!Prot ;

  B!!Mode[B!!List] _ B!Mode;
  CheckRec[24] _ cvasc(B!Mode[1 for 5]);
  CheckRec[25] _ cvasc(B!Mode[6 for 5]);

  CheckRec[26] _ MarkCnt;

  for I _ 0 step 1 until MaxMarks - 1 do
    CheckRec[27 + I] _ Marks[I];

    ! Stash the Marks away too.
    ;

  CheckRec[127] _ cvasc(">>>>>");


  ! now flush the image to disk ;

  NameCheckpointFile(Name, Ext);
  EnterCheckpointFile(Name, Ext);

  start!code
    protect!acs	1, 2;
    move		1, B!Chan;
    hrli		1, '32;			! .CHPSO == 32 ;
    movei		2, 1;
    chanio		1, 2;			! set to output at page 1 ;
      jfcl;
    move		1, B!Chan;
    hrli		1, 2;			! .CHOPT == 2 ;
    movei		2, access(CheckRec[0]);
    subi		2, 1;
    hrli		2, -128;		! -128,,addr-1 ;
    setz		3, ;
    chanio		1, 2;			! do the output ;
  end;


  ! now build the IOWD list for output ;

  Size _ (B!Size + B!GapSize + 4) div 5;
  IOWDList[1] _ IOWDList[2] _ 0;

  if (Size < '400000) then
    IOWDList[0] _ xwd(-Size, B!Addr-1)
  else
  begin
    IOWDList[0] _ xwd(-'377000, B!Addr-1);
    IOWDList[1] _ xwd(-(Size - '377000),(B!Addr + '377000 - 1));
  end;

  start!code
    protect!acs	1, 2, 3, 4;
    move		1, B!Chan;
    hrli		1, '2;		  ! .CHOPT == 2 ;
    move		2, access(IOWDList[0]);
    move		3, access(IOWDList[1]);
    move		4, access(IOWDList[2]);
    chanio		1, 2;		  ! do the output ;
  end;

  CloseCheckpointFile;
end;
!! title Rtn RestoreCheckpoint ;
! Restore from a Checkpoint File ;

internal simple procedure RestoreCheckpoint (integer Name, Ext);
begin "restore"
  own safe integer array
    IOWDList [0:2],
    CheckRec [0:127];
  integer
    I,
    WrdSize;


  LookupCheckpointFile(Name, Ext);


  ! read the checkpoint header ;

  start!code
    protect!acs	1, 2;
    move	1, B!Chan;
    hrli	1, '31;			! .CHPSI == 31 ;
    movei	2, 1;
    chanio	1, 2;			! set to input at page 1 ;
      jfcl;
    move	1, B!Chan;
    hrli	1, 3;			! .CHIPT == 3 ;
    movei	2, access(CheckRec[0]);
    subi	2, 1;
    hrli	2, -128;		! -128,,add-1 ;
    setz	3, ;
    chanio	1, 2;			! read the checkpoint header ;
  end;


  ! now restore various facts of interest about this buffer ;

  B!Point    _ B!!Point[B!!List]  _ CheckRec[1];
  B!Size     _ B!!Size[B!!List]   _ CheckRec[2];
  B!ModP     _ B!!ModP[B!!List]   _ CheckRec[3];
  B!Lock     _ B!!Lock[B!!List]   _ CheckRec[4];
  B!GapStart _ B!!GStart[B!!List] _ CheckRec[5];
  B!GapSize  _ B!!GSize[B!!List]  _ CheckRec[6];
  B!WS0      _ B!!WS0[B!!List]    _ CheckRec[7];
  B!WS1      _ B!!WS1[B!!List]    _ CheckRec[8];

  B!BegP     _ (B!Point = 0);
  B!EndP     _ (B!Point = B!Size);
  B!CkPtSer  _ CheckRec[21];
  B!DedVer   _ CheckRec[22];
  B!Prot     _ CheckRec[23];

  B!Mode _ B!!Mode[B!!List] _
      cvastr(CheckRec[24]) &
      cvastr(CheckRec[25]);

  set (G!TextMode, kequ(B!Mode[1 for 4], "Text"));

  B!File _ B!!File[B!!List] _
      cvastr(CheckRec[9]) &
      cvastr(CheckRec[10]) &
      cvastr(CheckRec[11]) &
      cvastr(CheckRec[12]) &
      cvastr(CheckRec[13]);

  B!Alias _ B!!Alias[B!!List] _
      cvastr(CheckRec[14]) &
      cvastr(CheckRec[15]) &
      cvastr(CheckRec[16]) &
      cvastr(CheckRec[17]) &
      cvastr(CheckRec[18]) &
      cvastr(CheckRec[19]) &
      cvastr(CheckRec[20]);

  MarkCnt _ CheckRec[26];

  for I _ 0 step 1 until MaxMarks - 1 do
    Marks[I] _ CheckRec[27 + I];

    ! Restore the Mark System.
    ;


  ! Do some memory management first.  Kill the pages used by the last
  ! buffer, and create some for this one to be read back into. ;

  WrdSize  _ ceiling(B!Size + B!GapSize, 5);

  if (VClear(BasePage, 512 - BasePage)) then
    usererr(0, 0, "VClear Error in RestoreCheckpoint", "x");

  B!Pages _ ceiling(WrdSize, 512);

  if (VCreate(BasePage, B!Pages)) then
    usererr(0, 0, "VCreate Error in RestoreCheckpoint", "x");


  ! now restore the in-memory image for this buffer ;
  ! build the IOWD list for input ;

  IOWDList[1] _ IOWDList[2] _ 0;

  if (WrdSize < '400000) then
    IOWDList[0] _ xwd(-WrdSize, (B!Addr - 1))
  else
  begin
    IOWDList[0] _ xwd(-'377000,(B!Addr - 1));
    IOWDList[1] _ xwd(-(WrdSize - '377000), (B!Addr + '377000 - 1));
  end;

  start!code
    protect!acs	1, 2, 3, 4;
    move	1, B!Chan;
    hrli	1, '3;		  ! .CHIPT == 3 ;
    move	2, access(IOWDList[0]);
    move	3, access(IOWDList[1]);
    move	4, access(IOWDList[2]);
    chanio	1, 2;		  ! do the input ;
  end;

  CloseCheckpointFile;
end "restore";
!! title Rtn B!Restore ;
! Routine to reset the static definitions from a descriptor ;

internal simple procedure B!Restore;
begin
  integer Name, Ext;

  NameCheckpointFile( Name, Ext );
  RestoreCheckpoint( Name, Ext );
end;
!! title Rtn B!Setup ;
! Routine to set up a fresh buffer descriptor by unlinking one from the
!  free list and adding it to the buffer chain.  It becomes the current
!  buffer in the doubly linked list. ;

simple procedure B!Setup;
begin "setup"
  integer
    Error, Next, Flag;

  if ( B!!Free = 0 ) then
    usererr( 0,0, "Out of buffers in B!Setup" );

    ! <<  Should this be a death condition? ;

  Next := B!!Free;			! get a free buffer ;
  B!!Free := B!!Next[ B!!Free ];

  if ( B!!List = 0 ) then		! link into chain ;
    begin
      B!!Head := Next;
      B!!Next[ Next ] := B!!Last[ Next ] := NULL;
      B!!List := Next;
    end
  else
    begin
      B!!Next[ Next ] := B!!Next[ B!!List ];
      B!!Last[ Next ] := B!!List;
      if ( B!!Next[ B!!List ] neq 0 ) then
	B!!Last[ B!!Next[ B!!List ] ] := Next;
      B!!Next[ B!!List ] := Next;
      B!!List := Next;
    end;


  ! Now allocate a channel and file for swapping ;

  CreateCheckpointFile;

  W!SetB( B!!List );			! tell the window manager the ;
					!  identity of the current buffer ;
end "setup";
!! title Rtn B!CKFile ;
! Routine to load the specified checkpoint file back into a buffer.
;

internal simple boolean procedure B!CKFile( integer Name, Ext );
begin "recover checkpoint"
  integer Error;

  DeleteBuffer(B!Chan);

  if ( LookupCheckpointFile( Name, Ext ) ) then
  begin
    RestoreCheckpoint( Name, Ext );
    W!Msg( "Restore Complete" );
  end
  else
  begin
    W!Msg( "Lookup Failed!  Further editing may be fatal!" );
    T!Bell;
  end;

  return( not Error );
end "recover checkpoint";
!! title Rtn B!Kill ;
! Routine to "B!Kill" the current buffer by adding it to the free list
! and resetting the current buffer to the next buffer if possible (or the
! last buffer if not).
;
! <<  Buffer chain s/b a pushdown list, so that the buffer returned to is
!     the last buffer exitted.
;

internal simple procedure B!Kill;
begin "B!Kill"
  own integer
    Next;


  DeleteBuffer(B!Chan);

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if (B!!Head = B!!List) then B!!Head _ B!!Next[B!!List];

  if (B!!Next[B!!List]) then
  begin
    Next _ B!!Next[B!!List];
    B!!Last[Next] _ B!!Last[B!!List];

    if (B!!Last[B!!List] neq 0) then
      B!!Next[B!!Last[B!!List]] _ Next;
  end
  else if (B!!Last[B!!List]) then
  begin
    Next _ B!!Last[B!!List];
    B!!Next[Next] _ B!!Next[B!!List];
  end
  else
    Next _ 0;	! into the void ... ;

  B!!Next[B!!List] _ B!!Free;
  B!!Free _ B!!List;
  B!!List _ Next;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  if (B!!List) then
    B!Restore;

  W!SetB(B!!List);
end "B!Kill";
!! title Rtn B!SetB ;
! Routine to position to a specified buffer ;

internal simple procedure B!SetB( integer BufNum );
  begin
    if ( BufNum = B!!List ) then return;
    B!CheckPoint;
    B!!List := BufNum;
    W!SetB( BufNum );
    B!Restore;
    W!NewS;
  end;
!! title Rtn B!Step ;
! Routine to step forwards or backwards along the buffer chain ;

internal simple procedure B!Step( integer Dir );
  begin
    if ( Dir = FORWARDS ) then
      begin
	if ( B!!Next[ B!!List ] neq NULL ) then
	  begin
	    B!CheckPoint;
	    B!!List := B!!Next[ B!!List ];
	    W!SetB( B!!List );
	    B!Restore;
	    W!NewS;
	  end
	else
	  W!Msg( "No buffers left >" );
      end
    else if ( Dir = BACKWARDS ) then
      begin
	if ( B!!Last[ B!!List ] neq NULL ) then
	  begin
	    B!CheckPoint;
	    B!!List := B!!Last[ B!!List ];
	    W!SetB( B!!List );
	    B!Restore;
	    W!NewS;
	  end
	else
	  W!Msg( "No buffers left <" );
      end;

  end;
!! title Rtn B!Cnt ;
! Routine to tell us how many buffers to the left and right of the
!  current buffer are active. Returns [ #left,,#right ] ;

internal simple integer procedure B!Cnt;
  begin
    own integer Left, Right, Chain;

    Chain := B!!List;
    Left := 0;
    while ( B!!Last[ Chain ] neq NULL ) do
      begin
	Left := Left + 1;
	Chain := B!!Last[ Chain ];
      end;
    Chain := B!!List;
    Right := 0;
    while ( B!!Next[ Chain ] neq 0 ) do
      begin
	Right := Right + 1;
	Chain := B!!Next[ Chain ];
      end;
    return( XWD( Left, Right ) );
  end;
!! title Rtn B!Make ;
! Build a new buffer descriptor by setting one up and filling it in.
;

forward internal simple procedure B!SetM (integer M, P);
forward internal simple integer procedure B!AllocateMark;

internal simple procedure B!Make(string FileNam, Alias);
begin
  integer
    I;

  if (B!!List neq 0) then
    B!CheckPoint;

  B!Setup;

  if (not length(B!Mode)) then
    B!Mode _ "Normal";

  B!!Mode[B!!List]   _ B!Mode;
  B!!File[B!!List]   _ B!File     _ FileNam;
  B!!Alias[B!!List]  _ B!Alias    _ Alias;
  B!!Point[B!!List]  _ B!Point    _ 0;
  B!!Size[B!!List]   _ B!Size     _ 0;
  B!!ModP[B!!List]   _ B!ModP     _ false;
  B!!Lock[B!!List]   _ B!Lock     _ 0;
  B!!GStart[B!!List] _ B!GapStart _ 0;
  B!!GSize[B!!List]  _ B!GapSize  _ (GAPMAX - GAPMIN) div 2;

  for I _ 0 step 1 until MaxMarks - 1 do
    Marks[I] _ -1;

    ! Initialize our Mark Structure.
    ;

  B!SetM((B!LastP _ B!AllocateMark), 0);
  B!SetM((B!WS0   _ B!AllocateMark), 0);
  B!SetM((B!WS1   _ B!AllocateMark), -1);
  
  B!!WS0[B!!List] _ B!WS0;
  B!!WS1[B!!List] _ B!WS1;

    ! Initialize some important Marks.
    ;

  B!CkPtSer _ 0;
  B!BegP _ B!EndP _ true;


  ! now build an empty gap for the buffer ;

  B!Pages _ 2;

  if (VClear(BasePage, B!Pages)) then
    usererr(0, 0, "VClear Error in B!Make", "x");

  if (VCreate(BasePage, B!Pages)) then
    usererr(0, 0, "VCreate Error in B!Make", "x");

  B!!GSize[B!!List] _ B!GapSize _ 2 * 512;
end;
!! title Rtn ExpandGap ;
! Routine to expand the gap.  ;

simple procedure ExpandGap;
begin
  own integer
    WordsUsed, WordsToMove, MoveFrom, MoveTo;

  WordsUsed _ ceiling(B!Size + B!GapSize, 5);

  if (VClear(BasePage + B!Pages, 1)) then
    usererr(0, 0, "VClear Error in ExpandGap", "x");

  if (VCreate(BasePage + B!Pages, 1)) then
    usererr(0, 0, "VCreate Error in ExpandGap", "x");

  B!Pages _ B!Pages + 1;


  ! shuffle memory if the gap isn't at the end of the buffer ;

  if (B!GapStart < B!Size) then
  begin
    MoveFrom _ WordsUsed - 1;
    MoveTo _ WordsUsed - 1 + 512;
    WordsToMove _ WordsUsed - (B!GapStart + B!GapSize) div 5;

    while (WordsToMove > 0) do
    begin
      memory[B!Addr + MoveTo] _ memory[B!Addr + MoveFrom];
      MoveTo _ MoveTo - 1;
      MoveFrom _ MoveFrom - 1;
      WordsToMove _ WordsToMove - 1;
    end;
  end;

  B!GapSize _ B!GapSize + (5 * 512);
end;
!! title Rtn ShrinkGap ;
! Routine to shrink the gap when it gets above GAPMAX bytes long. ;

simple procedure ShrinkGap;
  begin
    own integer WordsUsed, MoveFrom, MoveTo, WordsToMove;

    if ( B!GapStart < B!Size ) then
      begin
	WordsUsed := ( B!Size + B!GapSize + 4 ) div 5;
	MoveFrom := ( B!GapStart + B!GapSize ) div 5;
	MoveTo := MoveFrom - GAPSHRINK;
	WordsToMove := WordsUsed - MoveFrom;

	while ( WordsToMove > 0 ) do
	  begin
	    memory[ B!Addr + MoveTo ] := memory[ B!Addr + MoveFrom ];
	    MoveTo := MoveTo + 1;
	    MoveFrom := MoveFrom + 1;
	    WordsToMove := WordsToMove - 1;
	  end;
      end;
    B!GapSize := B!GapSize - 5 * GAPSHRINK;
! W!Msg( "ShrinkGap, B!GapSize = " & cvs( B!GapSize ) );
  end;

!! title Rtn MakeGapPriorBP ;
! Routines to make byte pointers.  These guys ar good targets for eventual
!  recoding into assembly language. ;

! Make a byte pointer to the character before the gap ;

simple integer procedure MakeGapPriorBP;
  begin
    own integer Temp1, Temp2;
    Temp1 := B!GapStart - 1;
    Temp2 := B!Addr + ( Temp1 div 5 );
    return( Temp2 lor B!BPLeft[ Temp1 mod 5 ] );
  end;
!! title Rtn MakeGapStartBP ;
! Make a byte pointer to the first gap character ;

simple integer procedure MakeGapStartBP;
  begin
    own integer Temp1;
    Temp1 := B!Addr + ( B!GapStart div 5 );
    return( Temp1 lor B!BPLeft[ B!GapStart mod 5 ] );
  end;
!! title Rtn MakeGapEndBP ;
! Make a byte pointer to the last character in the gap ;

simple integer procedure MakeGapEndBP;
  begin
    own integer Temp1, Temp2;
    Temp1 := B!GapStart + B!GapSize - 1;
    Temp2 := B!Addr + ( Temp1 div 5 );
    return( Temp2 lor B!BPLeft[ Temp1 mod 5 ] );
  end;
!! title Rtn MakeGapNextBP ;
! Make a byte pointer to the first character after the gap ;

simple integer procedure MakeGapNextBP;
  begin
    own integer Temp1, Temp2;
    Temp1 := B!GapStart + B!GapSize;
    Temp2 := B!Addr + ( Temp1 div 5 );
    return( Temp2 lor B!BPLeft[ Temp1 mod 5 ] );
  end;
!! title Rtn MakePointBP ;
! More routines to make byte pointers ;

! Make a byte pointer to the character to the right of the point ;

simple integer procedure MakePointBP;
  begin
    own integer Temp1, Temp2;
    Temp1 := B!Point + ( if ( B!Point >= B!GapStart ) then
				B!GapSize else 0 );
    Temp2 := B!Addr + ( Temp1 div 5 );
    return( Temp2 lor B!BPLeft[ Temp1 mod 5 ] );
  end;
!! title Rtn MakeBufEndBP ;
! Make a byte pointer to the slot past the end of the buffer ;

simple integer procedure MakeBufEndBP;
  begin
    own integer Temp1, Temp2;
    Temp1 := B!Size + B!GapSize;
    Temp2 := B!Addr + ( Temp1 div 5 );
    return( Temp2 lor B!BPLeft[ Temp1 mod 5 ] );
  end;

!! title Rtn B!ForceGap ;
! Force the gap to the right of the point. ;

simple procedure B!ForceGap;
  begin
    own integer Count, ToMove;
    if ( B!Point = B!GapStart ) then
      return
    else if ( B!Point > B!GapStart ) then
      begin
	B!GapNextBP := MakeGapNextBP;
	B!GapStartBP := MakeGapStartBP;
	ToMove := ( B!Point - B!GapStart );
	for Count := 1 upto ToMove do
	  begin
	    dpb( ldb( B!GapNextBP ), B!GapStartBP );
	    ibp( B!GapNextBP );
	    ibp( B!GapStartBP );
	  end;
	B!GapStart := B!Point;
      end
    else ! if ( B!Point < B!GapStart ) then ;
      begin
	B!GapEndBP := MakeGapEndBP;
	B!GapPriorBP := MakeGapPriorBP;
	ToMove := ( B!GapStart - B!Point );
	for Count := 1 upto ToMove do
	  begin
	    dpb( ldb( B!GapPriorBP ), B!GapEndBP );
	    B!GapPriorBP := DecrBP( B!GapPriorBP );
	    B!GapEndBP := DecrBP( B!GapEndBP );
	  end;
	B!GapStart := B!Point;
      end;
  end;

!! title Rtn B!Pcnt ;
! Return the percentage that the point is into the buffer ;

internal simple integer procedure B!Pcnt;
  begin
    return( ( B!Point * 100 ) div B!Size );
  end;
!! title Rtn B!GetP ;
! Return the current value of the point. ;

internal simple integer procedure B!GetP;
  return( B!Point );
!! title Rtn B!SetP ;
! Set the point to an absolute position in the buffer.  If set to beginning
!  and/or end, set the appropriate flags. ;

internal simple procedure B!SetP( integer Position );
  begin
    B!BegP := B!EndP := false;
    B!Point := Position;
    if ( B!Point <= 0 ) then
      begin
	B!Point := 0;
	B!BegP := true;
      end;
    if ( B!Point >= B!Size ) then
      begin
	B!Point := B!Size;
	B!EndP := true;
      end;
  end;
!! title Rtn B!GetL ;
! Return the "last" point. ;

forward internal simple integer procedure B!GetM (integer M);

internal simple integer procedure B!GetL;
begin
  return(B!GetM(B!LastP));
end;
!! title Rtn B!SetL ;
! Set the "Last" point.  (Used by the split window code). ;

internal simple procedure B!SetL( integer Position );
begin
  B!SetM(B!LastP, Position);
end;
!! title Rtn B!AllocateMark ;
! Allocate the first availible Real Mark to the caller and return its
! index.  A return of -1 indicates that there are no more Marks
! availible.
;

internal simple integer procedure B!AllocateMark;
begin "B!AllocateMark"
  integer
    I;

  for I _ FirstMark step 1 until MaxMarks - 1 do
    if (Marks[I] = -1) then
    begin
      Marks[I] _ -2;

      if (I - FirstMark = MarkCnt) then
        incr(MarkCnt);

      return(I);
    end;

  return(-1);
end "B!AllocateMark";
!! title Rtn B!DeAllocateMark ;
! Remove a given Mark from circulation, and if possible decrease MarkCnt.
;

internal simple procedure B!DeAllocateMark (integer M);
begin "B!DeAllocateMark"
  integer
    I;

  if (M < 0 or M >= FirstMark + MarkCnt) then
    usererr(0, 0, "Error in B!DeAllocateMark", "x")
  else if (M < #UserMarks) then
  begin
    if (Marks[M] neq -1) then
    begin
      Marks[Marks[M]] _ -1;
      Marks[M]        _ -1;
    end;
  end
  else
    Marks[M] _ -1;

  for I _ FirstMark + MarkCnt - 1 step -1 until FirstMark do
    if (Marks[I] = -1) then
      decr(MarkCnt)
    else
      done;
end "B!DeAllocateMark";
!! title Rtn B!GetM ;
! Return the current position of the mark ;

internal simple integer procedure B!GetM (integer M);
begin
  if (M < 0 or M >= FirstMark + MarkCnt) then
    usererr(0, 0, "Bad call to B!GetM, M = " & cvs(M), "x" )
  else
    return
    (
      if (M < #UserMarks) then
        if (Marks[M] = -1) then
          -1
        else
          Marks[Marks[M]]
      else
        Marks[M]
    );
end;
!! title Rtn B!SetM ;
! Set the mark to some position within the buffer ;

internal simple procedure B!SetM (integer M, P);
begin
  if (P < 0) then
    P _ 0
  else if (P > B!Size) then
    P _  B!Size;

  if (M < 0 or M >= FirstMark + MarkCnt) then
    usererr(0, 0, "Bad call to B!SetM, M = " & cvs(M), "x" )
  else
    if (M < #UserMarks) then
    begin
      if (Marks[M] = -1) then
        Marks[M] _ B!AllocateMark;

      Marks[Marks[M]] _ P;
    end
    else
      Marks[M] _ P;
end;
!! title Rtn B!Move ;
! Move forward or backward through the buffer.  If we reach the beginning
! and/or reach the end, set appropriate flags.  Note that with an empty
! buffer the point will be both at the beginning and the end. (This code
! has been optimized since it is central to almost all buffer-related
! work.)
;

internal simple procedure B!Move (integer Dir);
begin "B!Move"
  start!code
    define
      Ac13 = {'13};
    label
      Labl1,
      Labl2;

      setzm     B!BegP;
      setzm     B!EndP;

      move      Ac13, Dir;
      addb      Ac13, B!Point;

      jumpg     Ac13, Labl1;
      setzb     Ac13, B!Point;
      setom     B!BegP;

    Labl1:
      camge     Ac13, B!Size;
        jrst    Labl2;

      setom     B!EndP;
      move      Ac13, B!Size;
      movem     Ac13, B!Point;

    Labl2:
  end;
end "B!Move";
!! title Rtn B!Delete ;
! Delete a character from the buffer.  The side of the point from
!  which the character is deleted depends on the flag Side. ;

internal simple procedure B!Delete( integer Side );
  begin

    if ( B!Lock ) then return;

    B!ForceGap;
!   if ( B!GapSize >= GAPMAX ) then ShrinkGap; 

    if ( Side > 0 ) then	! delete from right of the gap ;
      begin
	if ( B!Point < B!Size ) then
	  begin
	    start!code
              define
                AC1 = 1,
                AC2 = 2,
                AC3 = 3;
              protect!acs
                AC1,
                AC2,
                AC3;
              label
                Loop,
                GoOn;

                move      AC1, B!Point;
                movei     AC2, access(Marks[FirstMark]);
                move      AC3, MarkCnt;

              Loop:
                sojl      AC3, GoOn;
                camge     AC1, (AC2);
                sos       (AC2);
                aoja      AC2, Loop;

              GoOn:
            end;

	    B!GapSize := B!GapSize + 1;
	    B!Size := B!Size - 1;

	    if ( B!Point = B!Size ) then
	      B!EndP := true;
	  end;
      end
    else			! delete from left of the gap ;
      begin
	if ( B!Point > 0 ) then
	  begin
	    start!code
              define
                AC1 = 1,
                AC2 = 2,
                AC3 = 3;
              protect!acs
                AC1,
                AC2,
                AC3;
              label
                Loop,
                GoOn;

                move      AC1, B!Point;
                movei     AC2, access(Marks[FirstMark]);
                move      AC3, MarkCnt;

              Loop:
                sojl      AC3, GoOn;
                camge     AC1, (AC2);
                sos       (AC2);
                aoja      AC2, Loop;

              GoOn:
	    end;

	    B!Point := B!Point - 1;
	    B!GapStart := B!GapStart - 1;
	    B!GapSize := B!GapSize + 1;
	    B!Size := B!Size - 1;
	  end;
      end;

    if ( not B!ModP ) then
      begin
	B!ModP := true;		! buffer is now modified ;
	W!FixS;
      end;

  end;
!! title Rtn B!Insert ;
! Insert a character into the buffer.  The character is inserted at the
!  right of the point, and at the left size of the gap. ;

! <<  Is this actually true? ;

internal simple procedure B!Insert( integer C );
  begin "insert"

    own integer InsertBP;

    if ( B!Lock ) then return;

    start!code
      define
        AC1 = 1,
        AC2 = 2,
        AC3 = 3;
      protect!acs
        AC1,
        AC2,
        AC3;
      label
        Loop,
        GoOn;

        move      AC1, B!Point;
        movei     AC2, access(Marks[FirstMark]);
        move      AC3, MarkCnt;

      Loop:
        sojl      AC3, GoOn;
        camge     AC1, (AC2);
        aos       (AC2);
        aoja      AC2, Loop;

      GoOn:
    end;

    B!ForceGap;
    if ( B!GapSize <= GAPMIN ) then ExpandGap;
    InsertBP := MakeGapStartBP;
    B!GapStart := B!GapStart + 1;
    B!GapSize := B!GapSize - 1;

    dpb( C, InsertBP );
    B!Size := B!Size + 1;
    B!Point := B!Point + 1;
    B!BegP := false;

    if ( Not B!ModP ) then
      begin
	B!ModP := true;	! buffer is now modified ;
	W!FixS;
      end;

  end "insert";
!! title Rtn B!GetC ;
! Return the character to the right of the point.
;

internal simple integer procedure B!GetC;
begin "B!GetC"
  if (B!Point >= B!Size) then
    return(0);

  start!code
    define
      Ac1  = {'01},
      Ac13 = {'13},
      Ac14 = {'14},
      Ac15 = {'15};

      move      Ac14, B!Point;          ! compute absolute char offset ;
      caml      Ac14, B!GapStart;
        add     Ac14, B!GapSize;
      idivi     Ac14, 5;                ! word pointer in Ac14, offset in Ac15;
      add       Ac14, B!Addr;           ! add base ;
      move      Ac14, (Ac14);           ! pick up the word ;
      imuli     Ac15, 7;                ! build a shift count ;
      addi      Ac15, 7;                ! ... ;
      lshc      Ac13, (Ac15);
      andi      Ac13, '177;              ! mask to 7 bits ;
      move      Ac1, Ac13;
  end;
end "B!GetC";
!! title Rtn B!Read ;
! Routine to slurp a file into memory from disk ;

internal simple procedure B!Read(integer Chan, Words);
begin
  integer
    Offset, Inc, Bits, TWords;
  boolean
    EmptyFile;

  EmptyFile _ (Words = 0);
  B!Pages   _ ceiling(Words, 512) + 2;
  B!GapSize _ 2 * 512 * 5;

  if (VClear(BasePage, 512 - BasePage)) then
    usererr(0, 0, "VClear Error in B!Read", "x");

  if (VCreate(BasePage, B!Pages)) then
    usererr(0, 0, "VCreate Error in B!Read", "x");

  B!Size _ Words * 5;
  Offset _ 2 * 512;		! start with 2 gap pages ;
  B!NullFlag _ false;
  TWords _ Words;

  while (Words) do
  begin
    Inc _ 512 min Words;
    Arryin(Chan, memory[B!Addr + Offset], Inc);

    start!code
      label		loop1, loop2;
      skipe		B!NullFlag;
	jrst		loop2;
      move		1, B!Addr;
      add		1, Offset;
      move		2, Inc;
      caie		2, 512;
	soje		2, loop2;

    loop1:
      sosg		TWords;		! examine all but the last word ;
	jrst		loop2;
      move		3, (1);
      trnn		3, '376;		! '177 lsh 1 ;
	setom		B!NullFlag;
      addi		1, 1;
      sojg		2, loop1;

    loop2:
    end;

    Words  _ Words - Inc;
    Offset _ Offset + Inc;
  end;


  ! now strip 1 to 4 trailing nulls from the end of the file ;

  if (not EmptyFile) then
  begin
    Offset _ OffSet - 1;	! point to last word of file ;
    Bits _ '177 lsh 1;		! character mask ;

    for Inc _ 1 upto 4 do
    begin
      if (memory[B!Addr + OffSet] land Bits) then
	done
      else
      begin
	Bits _ Bits lsh 7;
	B!Size _ B!Size - 1;
      end;
    end;
  end;

  B!BegP _ true;
  B!EndP _ (not B!Size);
end;
!! title Rtn B!Write ;
! Routine to spit a file out to disk ;

internal simple procedure B!Write( integer Chan );
  begin
    own integer SavePoint, Words, Inc, Offset;

    ! Push that gap the the end of the file, and insure that the last
    ! 4 characters are NULL ;

    SavePoint := B!Point;
    B!Point := B!Size;
    B!ForceGap;
    Inc := MakeGapStartBP;
    dpb( NULL, Inc );
    idpb( NULL, Inc );
    idpb( NULL, Inc );
    idpb( NULL, Inc );

    ! spit out the buffer ;

    OffSet := 0;
    Words := ( B!Size + 4 ) div 5;
    while ( Words ) do
      begin
	Inc := Words min 512;
	arryout( Chan, memory[ B!Addr + Offset ], Inc );
	Words := Words - Inc;
	OffSet := OffSet + Inc;
      end;

    B!Point := SavePoint;
    B!ModP := false;		! buffer is again virgin ;

  end;
!! title Rtn B!AnyM ;
! See if any buffers in the ring are modified ;

internal simple boolean procedure B!AnyM;
begin "B!AnyM"
  integer
    Ptr;

  Ptr _ B!!Head;

  while (Ptr) do
  begin
    if ((Ptr = B!!List and B!ModP and length(B!File)) or
	(Ptr neq B!!List and B!!ModP[Ptr] and length(B!!File[Ptr]))) then
      return(true);

    Ptr _ B!!Next[Ptr];
  end;

  return(false);
end "B!AnyM";
!! title Rtn B!ModCnt ;
! routine to return the number of buffers in the ring that are modified
;

internal simple integer procedure B!ModCnt;
begin "B!ModCnt"
  integer
    Cnt,
    Ptr;

  Ptr _ B!!Head;
  Cnt _ 0;

  while (Ptr) do
  begin
    if ((Ptr = B!!List and B!ModP and length(B!File)) or
	(Ptr neq B!!List and B!!ModP[Ptr] and length(B!!File[Ptr]))) then
      incr(Cnt);

    Ptr _ B!!Next[Ptr];
  end;

  return(Cnt);
end "B!ModCnt";
!! title Rtn B!Fini ;
! B!Fini - walk the ring, optionally writting out modified files
!  and deleting the checkpoint files.
! Note that B!Kill does a B!Restore for the next buffer.
;

internal simple boolean procedure B!Fini( boolean WriteFiles );
  begin "fini"

    B!!ModP[ B!!List ] := B!ModP;

    while ( B!!List ) do
      begin "each buffer"

	if ( WriteFiles and
	     B!!ModP[ B!!List ] and
	     length( B!!File[ B!!List ] )) then
	  begin
	    if ( not F!Writ( B!!File[ B!!List ] )) then return( false );
	    B!Kill;
	  end
	else
	  B!Kill;

      end "each buffer";

    B!RlChan(B!Chan);
    return( true );

  end "fini";
!! title Rtn B!SeqP ;
! Routine to tell if there are sequence number bits on.
;

internal simple boolean procedure B!SeqP;
  begin "seq?"
    integer I, W, C;

    if ( B!Size = 0 ) then return( false );
    W := memory[ B!Addr + ( B!GapSize div 5 ) ];

    if ( not ( W land 1 )) then return( false );

    W := W lsh -1;
    for I := 1 upto 5 do
      begin
	C := W land '177;
	if (( C < "0" ) or ( C > "9" )) then return( false );
	W := W lsh -7;
      end;

    return( true );

  end "seq?";
!! title Rtn B!NulP ;
! Routine to tell if there are NULLs in this buffer ;

internal simple boolean procedure B!NulP;
  begin
    return( B!NullFlag );
  end;
!! title Rtn B!DelN ;
! Routine to delete nulls from the buffer. Since it does not adjust Marks
! while doing its deletion, this routine should only be invoked before
! the buffer is turned over to the user.  Currently, it is only called
! by F!Load and B!DelS ;

internal simple procedure B!DelN;
begin
  B!SetP(0);

  while (not B!EndP) do
  begin
    if (B!GetC = null) then
    begin
      B!ForceGap;
      incr(B!GapSize);
      decr(B!Size);

      if (B!Point = B!Size) then
	set(B!EndP);
    end
    else
      B!Move(FORWARDS);
  end;

  B!SetP(0);
end;
!! title Rtn B!DelS ;
! Routine to delete sequence numbers from the buffer.
! *Must* be called after B!Read before any other mods are made
! to the buffer.  Hideous things happen elsewise. ;

internal simple procedure B!DelS;
  begin
    integer idx, count;

    idx := B!Addr + ( B!GapSize div 5 );
    count := B!Size div 5;

    while ( count ) do
      begin
	if ( memory[ idx ] land '1 ) then
	  begin
	    memory[ idx ] := 0;
	    memory[ idx + 1 ] := memory[ idx + 1 ] land '003777777777;
	  end;
        idx := idx + 1;
	count := count - 1;
      end;

    B!DelN;
  end;
!! title Rtn B!BufStat ;
! Routine to throw the list of buffers into the Box ;

internal simple procedure B!BufStat;
begin "buffer status"
  integer L;
  string S;

  ! List starting with B!!Head;

  L := B!!Head;
  while ( L ) do
  begin "list buffers"
    if ( L = B!!List ) then
      S := " > " else S := "   ";

    if ( B!!Alias[ L ] ) then
      S := S & B!!Alias[ L ]
    else
      S := S & B!!File[ L ];

    if ( L = B!!List and B!ModP or
	L neq B!!List and B!!ModP[ L ] ) then
      S := S & " *";

    W!BAdd( S );
    L := B!!Next[ L ];
  end "list buffers";
end "buffer status";
end "DED - buffer manager"


! ***************************  End Xbuff.Sai  ****************************;
    2XFILE.SAI    ü05-Apr-84 10:08:31  KADVUJ    Entry;
begin "DED - File I/O"
  require "DED.DEF" source!file;
!! title Tymcom-X File I/O Module ;

ifcr Tops20 thenc
  require "!!! This is the Tymcom-X File I/O module !!!" message;
  TryAgainWithTheTops20Version
endc


! *************************************************************************
*									  *
*	 This module handles all disk I/O, and isolates all system	  *
*      dependent file system calls into one file.  The RPG interface	  *
*			     also lives here.				  *
*									  *
*		     Dave W. Smith,  October '81 - ...			  *
*									  *
**************************************************************************;


! Entry points in other modules that we reference. ;

  external integer
    C!Debug;


!                         From the Buffer Module
;

  external string
    B!File;				! name of file ;
  external simple procedure
    B!Make( string FileNam, Alias );	! make a new buffer ;
  external simple procedure
    B!Read( integer Chan, Words );	! suck in a file ;
  external simple procedure
    B!Write( integer Chan );		! spit out a file ;
  external simple procedure 
    B!SetP( integer Position );	        ! set the point ;
  external simple procedure
    B!Insert( integer C );		! insert a character ;
  external simple procedure
    B!Delete( integer Dir );		! delete a chracter ;
  external simple integer procedure
    B!GetP;			        ! get the point ;
  external simple integer procedure
    B!GetC;			        ! get char at point ;
  external integer
    B!Prot;				! buffer protection ;
  external simple procedure
    B!Move( integer Dir );		! move the point ;
  external boolean
    B!BegP,
    B!EndP;                             ! position flags ;
  external boolean
    B!ModP;				! buffer modified ;
  external integer
    B!Lock;
  external simple boolean procedure
    B!SeqP;
  external simple boolean procedure
    B!NulP;
  external simple procedure
    B!DelS;
  external simple procedure
    B!DelN;


!                         From the Window Module
;

  external procedure
    W!Disp( boolean PuntIfKeyHit );
  external procedure
    W!Msg( string S );
  external boolean
    W!MsgF;
  external procedure
    W!NewS;                             ! create new status line ;
  external procedure
    W!FixS;


!                         From the Command Module
;

  external boolean
    C!SPMRegion,                        ! Swap Pooint and Mark on
                                        ! region-oriented operations (ie
                                        ! Insert File)
                                        ;
    G!RNulls;                           ! Remove nulls from Text file
                                        ! automatcially if true.
                                        ;
  external boolean procedure
    C!Ask( string Question );
  external safe integer array
    C!Tab['0:'177];


!                      From the SAIL Runtime System
;

  external integer
    RPGSW;                              ! true iff called w/ offset ;


!                        From the Redisplay Module
;

  external procedure
    T!Bell;
  external procedure
    T!Fini;
  external procedure
    T!RSet;
!! title Internal Storage ;
! Storage internal to this module ;

  internal string
    F!Search;                           ! The string for which we want to
                                        ! search upon opening a file for
                                        ! editing.
                                        ;

  own integer F!Chan;			! channel of current file ;
  own integer F!EOF;			! true iff eof reached ;
  own integer F!EOFSeen;
  own integer F!InputCount, F!OutputCount;
  own integer F!Count, F!Break;
  own integer F!Words;			! size, in words, of file ;
  internal integer F!Chars;		! chars yet to be read from file ;
  own integer F!Prot;			! file protection ;

  own integer F!BP;			! byte pointer into F!Buffer ;
  own safe integer array F!Buffer[ 0 : 127 ];

! stuff scanned from a filename ;

  own string F!Name;			! file name ;
  own string F!Alias;			! r e g n a d   k c i n ;
  own boolean F!Lock;			! true iff /read ;
  own integer F!Page, F!Line, F!Char;	! where to start ;
  internal boolean F!RPGFlag;		! true iff to exit to RPG ;
  own string TmpCoreString;		! contents of EDS tmpcore file ;
!! title Rtn F!Exit ;
! Do system dependent termination stuff ;

internal procedure F!Exit;
  begin
    safe integer array RB[ 0 : 5 ];

    if ( F!RPGFlag ) then
      begin
	T!Fini;
	print(crlf);
	RB[ 0 ] := cvsix( "SYS" );
	RB[ 1 ] := cvsix( "RPG" );
	RB[ 2 ] := RB[ 3 ] := RB[ 4 ] := RB[ 5 ] := 0;
	calli( XWD( 1, location( RB[ 0 ] )), '35 );
	Usererr( 0,0,"??? Unable to run RPG - contact SQA","x" );
      end;
  end;
!! title Rtn F!Decompose ;
! Decompose a Tymcom-X/PEAK FileSpec, which must be of the following form:
!
! <FileSpec>	->	<FS>(<Alias>)(<Switches>)
! <FS>		->	(<UserName>)<FileName> | <FileName>(<PPNSpec>)
! <UserName>	->	'(' repeat(<V1>, 1-12) ')
! <FileName>	->	<FilePart> ('.' <ExtPart>)
! <FilePart>	->	repeat(<V2>, 1-6)
! <ExtPart>	->	repeat(<V2>, 0-3)
! <PPNSpec>	->	'[' <GanSpec> ',' <UunSpec> ']'
! <GanSpec>	->	repeat(<OctNum>, 1-6)
! <UunSpec>	->	repeat(<OctNum>, 1-6)
! <Alias>	->	'"' repeat(<V3>, 1-*) '"'
! <Switches>	->	'/' <Sw> | '%' <Sw>
! <Sw>		->	repeat(ASCII, 1-*)
! 
! <V1>		->	<Alpha> | <DecNum> | '*' | '.' | '/' | '-' | ' '
! <V2>		->	<Alpha> | <DecNum>
! <V3>		->	{ASCII - '"'}
! 
! <Alpha>	->	'A' - 'Z' | 'a' - 'z' 
! <DecNum>	->	'0' - '9'
! <OctNum>	->	'0' - '7'
! 
! 
! (The function repeat(Item, Minimum-Maximum) is replaced by between
! Minimum and Maximum number of occurences of Item.  The special symbol
! '*' indicates no limit.)
!
! The symbol 'ASCII' indicates the entire ASCII character set.
!
! Braces ('{' and '}') enclose set specifications - eg, '{ASCII - '"'}'
! means all characters except '"'.
;


internal boolean procedure F!Decompose (string InStr; reference string UserName, File, Ext, PPN, Alias, Switches);
begin "F!Decompose"
  label
    S0, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, S13, S14, S15,
    S16, SGood, SBad;
  integer
    C;
  string
    LUserName, LFile, LExt, LGanStr, LUunStr, LAlias, LSwitches;
  define
    sp               = {" "},
    IsAlphabetic (X) = {("A" <= UpShift(X) <= "Z")},
    IsNumeric    (X) = {("0" <= X <= "9")},
    IsOctal      (X) = {("0" <= X <= "7")},
    IsWhiteSpace (X) = {(X = sp or X = tab)};


  LUserName _
  LFile     _
  LExt      _
  LGanStr   _
  LUunStr   _
  LAlias    _
  LSwitches _
  UserName  _
  File      _
  Ext       _
  PPN       _
  Alias     _
  Switches  _ null;


  S0:
      ! Nothing seen - Look for username or filename ;

    C _ lop(InStr);
    if (IsAlphabetic(C)) then goto S4;
    if (IsNumeric(C))    then goto S4;
    if (C = "(") then goto S1;
    goto SBad;


  S1:
      ! "(" Seen - Look for username ;

    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if ((IsAlphabetic(C)) or
	(IsNumeric(C)) or
	(C = "*") or (C = ".") or
	(C = "/") or (C = "-") or
	(C = sp)) then
      goto S2;
    goto SBad;


  S2:
      ! Username character seen - Collect more and look for ")" ;

    appnd(LUserName, ToUpper(C));
    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if ((IsAlphabetic(C)) or
	(IsNumeric(C)) or
	(C = "*") or (C = ".") or
	(C = "/") or (C = "-") or
	(C = sp)) then
      goto S2;
    if (C = ")") then goto S3;
    goto SBad;


  S3:
      ! ")" seen - Skip whitespace and look for filename ;

    if (not (length(InStr) and length(LUserName))) then goto SBad;
    C _ lop(InStr);
    if (IsAlphabetic(C)) then goto S4;
    if (IsNumeric(C))    then goto S4;
    if (IsWhiteSpace(C)) then goto S3;
    goto SBad;


  S4:
      ! Filename character seen - Collect more ;

    appnd(LFile, ToUpper(C));
    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (IsAlphabetic(C)) then goto S4;
    if (IsNumeric(C))    then goto S4;
    if (C = ".")         then goto S6;
    if ((C = "/") or (C = "%")) then goto S16;
    if (C = """")        then goto S14;
    if (C = "[")         then goto S9;
    if (IsWhiteSpace(C)) then goto S5;
    goto SBad;


  S5:
      ! Whitespace seen - gobble up more and look for dot ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = ".") then goto S6;
    if (C = "[") then goto S9;
    if ((C = "/") or (C = "%")) then goto S16;
    if (C = """") then goto S14;
    if (IsWhiteSpace(C)) then goto S5;
    goto SBad;


  S6:
      ! Dot seen - Look for extension ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (IsAlphabetic(C)) then goto S7;
    if (IsNumeric(C))    then goto S7;
    if (C = "[") then goto S9;
    if ((C = "/") or (C = "%")) then goto S16;
    if (C = """") then goto S14;
    if (IsWhiteSpace(C)) then goto S6;
    goto SBad;


  S7:
      ! Extension character seen - Look for more ;

    appnd(LExt, ToUpper(C));
    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (IsAlphabetic(C)) then goto S7;
    if (IsNumeric(C))    then goto S7;
    if (C = "[") then goto S9;
    if ((C = "/") or (C = "%")) then goto S16;
    if (C = """") then goto S14;
    if (IsWhiteSpace(C)) then goto S8;
    goto SBad;


  S8:
      ! Whitespace seen - gobble up more ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = "[") then goto S9;
    if ((C = "/") or (C = "%")) then goto S16;
    if (C = """") then goto S14;
    if (IsWhiteSpace(C)) then goto S8;
    goto SBad;


  S9:
      ! "[" seen - Look for Gan ;

    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if (IsOctal(C)) then goto S10;
    goto SBad;


  S10:
      ! Gan digit seen - Collect more and look for "," ;

    appnd(LGanStr, ToUpper(C));
    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if (IsOctal(C)) then goto S10;
    if (C = ",") then goto S11;
    goto SBad;


  S11:
      ! "," seen - Look for Uun ;

    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if (IsOctal(C)) then goto S12;
    goto SBad;


  S12:
      ! Uun digit seen - Collect more ;

    appnd(LUunStr, ToUpper(C));
    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if (IsOctal(C)) then goto S12;
    if (C = "]")  then goto S13;
    goto SBad;


  S13:
      ! "]" seen - Look for Alias ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if ((C = "/") or (C = "%")) then goto S16;
    if (C = """") then goto S14;
    goto SBad;


  S14:
      ! '"' seen - Gobble up everything until the next occurence ;

    if (not length(InStr)) then goto SBad;
    appnd(LAlias, ToUpper(C));
    C _ lop(InStr);
    if (C = """") then goto S15;
    goto S14;


  S15:
      ! '"' terminating Alias seen - Look for switches ;

    appnd(LAlias, ToUpper(C));
    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = "/" or C = "%") then goto S16;
    goto SBad;


  S16:
      ! "/" or "%" seen - Gobble up the rest of the line ;

    appnd(LSwitches, ToUpper(C));
    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    goto S16;


  SGood:
      ! Many Happy Returns ;

    if (length(LUserName)) then
      UserName _ LUserName[1 for 12]
    else
      PPN _ cvos(xwd(cvo(LGanStr[1 for 6]), cvo(LUunStr[1 for 6])));

    File     _ LFile[1 for 6];
    Ext      _ LExt[1 for 3];
    Alias    _ LAlias;
    Switches _ LSwitches;

    return(true);


  SBad:
      ! Oops - something smells funny ;

    UserName _ File _ Ext _ PPN _ Alias _ Switches _ null;

    return(false);
end "F!Decompose";
!! title Rtn F!Parse ;
! Parse and Sanctify a file name ;

internal string procedure F!Parse (string StrIn);
begin "F!Parse"
  string
    UserName,
    FileName,
    Ext,
    SPPN,
    Alias,
    Switches;
  integer
    PPN;
  define
    OurPPN = {(call(xwd(-1, 2), "gettab"))};


  if (F!Decompose(StrIn, UserName, FileName, Ext, SPPN,
      Alias, Switches)) then
  begin
    string
      S;

    PPN _ cvo(SPPN);
    S   _ null;

    if (length(UserName)) then
      appnd(S, ("(" & UserName & ")"));

    appnd(S, FileName);

    if (length(Ext)) then
      appnd(S, ("." & Ext));

    if (PPN and PPN neq OurPPN) then
      appnd(S, xwdstr(PPN));

    return(S);
  end
  else
    return(null);
end "F!Parse";
!! title Rtn F!Lookup ;
! Routine to open a file for input ;

internal boolean procedure F!Lookup( string FileName );
  begin "lookup"
    own boolean Flag;
    own integer array Info[ 0:5 ];

    F!Chan := GetChan;
    F!Count := 128;
    F!EOF := 0;

    open( F!Chan, "DSK", BIT(23)+'17, 0,0, F!Count, F!Break, F!EOF );
    if ( F!EOF ) then
      begin
	W!Msg( "? Can't open DSK:" );  T!Bell;
	return( false );
      end;

    lookup( F!Chan, FileName, Flag );
    FileInfo( Info );
    if ( Flag ) then
      begin
	Flag := Info[ 1 ] land '777777;
	if ( Flag = 0 ) then
	  W!Msg( "Nonexistent File"  )
	else if ( Flag = 1 ) then
	  W!Msg( "Bad FileSpec" )
	else if ( Flag = 2 ) then
	  W!Msg( "File is Protected" )
	else
	  W!Msg( "Cannot LOOKUP File, error " & cvos( Flag ) );
	release( F!Chan );
	return( false );
      end;

    F!Prot  := Info[2] lsh -27;		! Protection of file ;
    F!Words := Info[ 5 ];
    F!Chars := F!Words * 5;

    F!InputCount := 0;		! haven't read anything, yet ;

    if ( F!Words > MAXFILESIZE ) then
      begin
	W!Msg( "? File is too large to edit with "&DED!Alias );
	T!Bell;
	release( F!Chan );
	return( false );
      end;

    return( true );

  end "lookup";
!! title Rtn F!Lkup ;
! Routine to open a disk-resident tmpcore file for input.
;

boolean procedure F!Lkup (string FileName);
begin "F!Lkup"
  own boolean
    Flag;
  own integer array
    Info [0:5];

  F!Chan  _ GetChan;
  F!Count _ 128;
  F!EOF   _ 0;

  open(F!Chan, "DSK", BIT(23)+'17, 0,0, F!Count, F!Break, F!EOF);

  if (F!EOF) then
  begin
    print("? Can't open DSK:");
    T!Bell;
    return(false);
  end;

  lookup(F!Chan, FileName, Flag);

  if (Flag) then
  begin
    release(F!Chan);
    return(false);
  end;

  fileinfo(Info);
  F!Words _ Info[5];
  F!Chars _ F!Words * 5;

  return(true);
end "F!Lkup";
!! title Rtn F!GetC ;
! Return the next character input from the file open on F!Chan.
! Return -1 at when no more characters remain to be read or at EOF.
! The assumption is made that the lookup routine used in conjunction with
! this one has set the file character count (F!Chars).
;

internal integer procedure F!GetC;
begin "F!GetC"
  own integer
    Addr,
    C;

  if (F!EOF or F!Chars <= 0) then
    return(-1);

  if (F!InputCount = 0) then
  begin
    F!BP _ point(7, F!Buffer[0], -1);
    arryin(F!Chan, F!Buffer[0], 128);
    F!InputCount _ 128 * 5;
  end;

  C _ ildb(F!BP);
  decr(F!InputCount);
  decr(F!Chars);
  return(C);
end "F!GetC";
!! title Rtn F!Release ;
! Routine to release the input file ;

internal simple procedure F!Release;
  begin "release"

    release( F!Chan );

  end "release";
!! title Rtn F!Enter ;
! Open a file for output ;

internal boolean procedure F!Enter( string FileName );
  begin "enter"
    boolean Flag;

    F!Chan := GetChan;
    F!Count := 128;
    F!EOF := 0;
    open( F!Chan, "DSK", BIT(23)+'17, 0,0, F!Count, F!Break, F!EOF );
    if ( F!EOF ) then return( false );
    enter( F!Chan, FileName, Flag );
    if ( Flag ) then
      begin
	release( F!Chan );
	return( false );
      end;

    F!OutputCount := 0;
    return( true );

  end "enter";
!! title Rtn F!PutC ;
! Put a character into the output buffer ;

internal procedure F!PutC( integer C );
  begin "put c"
    own integer I;

    if ( F!OutputCount = 0 ) then
      begin
	own integer Addr;
	arrclr( F!Buffer );
	F!BP := point( 7, F!Buffer[ 0 ], -1 );
      end;

    idpb( C, F!BP );

    F!OutputCount := F!OutputCount + 1;

    if ( F!OutputCount = 128 * 5 ) then
      begin
	own integer Addr;
	arryout( F!Chan, F!Buffer[ 0 ], 128 );
	F!OutputCount := 0;
      end;

  end "put c";
!! title Rtn F!Close ;
! Routine to flush output and close the file ;

internal procedure F!Close (string FileName);
  begin "close"
    integer FlushCount, Flag;

    FlushCount := ( F!OutputCount + 4 ) div 5;
    if ( FlushCount > 0 ) then
      begin
	integer Addr;
	arryout( F!Chan, F!Buffer[ 0 ], FlushCount );
      end;

    rename( F!Chan, FileName, B!Prot, (Flag _ 0) );

    if ( Flag ) then
      usererr( 0, 0, "Cannot apply protection to file (" & FileName & ")" );

    release( F!Chan );

  end "close";
!! title Rtn F!Read ;
! Routine to read a file.
;

internal boolean procedure F!Read(string FName);
begin "F!Read"
  integer
    SavePoint;

  if (not F!Lookup(FName)) then
    return(false);

    ! Refuse if there is a problem.
    ;

  SavePoint _ B!GetP;

    ! Remember our position.
    ;

  if (F!Chars) then
  begin
    integer
      C;

    while ((C _ F!GetC) >= 0) do
      B!Insert(C);

    ! delete up to 4 nulls from the end of the buffer ;

    F!Chars _ (B!GetP - SavePoint) min 4;

    while (F!Chars) do
    begin
      B!Move(BACKWARDS);

      if (B!GetC) then
      begin
        B!Move(FORWARDS);
        done;
      end
      else
        B!Delete(FORWARDS);

      decr(F!Chars);
    end;
  end;

  release(F!Chan);

  if (not C!SPMRegion) then
    B!SetP(SavePoint);

  return(true);
end "F!Read";
!! title Rtn F!Load ;
! Routine to "load" (i.e. destructive read) a file ;

internal boolean procedure F!Load (string FName; integer P, L, C);
begin "load a file"
  if (P < 0) then
    P _ F!Page;

  if (L < 0) then
    L _ F!Line;

  if (C < 0) then
    C _ F!Char;

  if (not F!Lookup(FName)) then
    return(false);

  B!Prot _ F!Prot;		! save file protection with buffer ;

  B!Read(F!Chan, F!Words);
  release(F!Chan);
  W!NewS;

  if (B!SeqP) then
  begin
    W!Msg("Removing sequence numbers");
    W!MsgF _ true;
    W!Disp(true);
    B!DelS;
    W!MsgF _ false;
  end
  else if (B!NulP) then
  begin
    if (G!RNulls) then
    begin
      W!Msg("Removing Nulls");
      B!DelN;
    end
    else
      W!Msg("Nulls Exist");

    W!Disp(false);
  end;

  ! position to (P, L, C) ;

  decr(P);

  while (P > 0) do
  begin "page"
    if (B!EndP) then
      done "page";

    if (B!GetC = FF) then
      decr(P);

    B!Move(FORWARDS);
  end "page";

  decr(L);

  while (L > 0) do
  begin "line"
    if (B!EndP) then
      done "line";

    if (B!GetC = LF) then
      decr(L);

    B!Move(FORWARDS);
  end "line";

  decr(C);

  while (C > 0) do
  begin "char"
    if (B!EndP) then
      done "char";

    decr(C);
    B!Move(FORWARDS);
  end "char";

  B!Lock _ F!Lock;		  ! save the lock ;
  return(true);
end "load a file";
!! title Rtn MakeBackupName ;
! Routine to map a filename into a backup filename ;

simple string procedure MakeBackupName( string FName );
  begin "backup name"
    string BName;
    boolean DotSeen;

    BName := NULL;
    DotSeen := false;

    if ( FName = "(" ) then
      begin
	while ( FName neq ")" ) do
	  begin
	    BName := BName & lop( FName );
	  end;
	BName := BName & lop( FName );
      end;

    while ( FName ) do
      begin
	if ( ( not DotSeen ) and Fname = "." ) then
	  begin
	    BName := BName & ".BAK";
	    DotSeen := true;
	    while ( FName ) do lop( FName );
	  end
	else
	  BName := BName & Lop( FName );
      end;
    if ( not DotSeen ) then
      BName := BName & ".BAK";

    return( BName );

  end "backup name";
!! title Rtn MakeBackup ;
! Routine to try to make a backup copy of the current file. ;

simple boolean procedure MakeBackup( string FName );
  begin "make backup"
    string BackupFileName;
    integer BChan, EOF, Flag;

    BackupFileName := MakeBackupName( FName );

    ! delete the backup file, if it exists ;

    open( BChan := getchan, "DSK", BIT(23)+'17, 0,0,0,0,EOF );
    if ( EOF ) then return( false );

    lookup( BChan, BackupFileName, Flag );
    if ( Flag = 0 ) then
      begin
	rename( BChan, 0, NULL, Flag );
	release( BChan );
	if ( Flag ) then
	  begin
	    W!Msg( "? Couldn't Delete Backup File" );
	    return( false );
	  end;
      end
    else if ( Flag and ( RH( Flag ) = 0 ) ) then	! no backup file. ;
      begin
      end
    else
      begin
	W!Msg( "? Lookup Error " & cvs( RH(Flag) ) & " for BACKUP file" );
	release( BChan );
	return( false );
      end;


    ! Here with old backup file deleted.  Try to rename the file to backup ;

    open( BChan := getchan, "DSK", BIT(23)+'17, 0,0,0,0, EOF );
    if ( EOF ) then return( false );

    lookup( BChan, FName, Flag );
    if ( Flag = 0 ) then
      begin
	rename( BChan, BackupFileName, '0, Flag );
	release( BChan );
	if ( Flag ) then
	  begin
	    if ( RH( Flag ) = 2 ) then
	      W!Msg( "? Protection Failure creating backup file" )
	    else
	      W!Msg( "? Rename Error " & cvos( RH(Flag) ) &
		     " creating Backup file" );
	    T!Bell;
	    return( false );
	  end
	else
	  return( true );		! all is o.k. ;
      end
    else if ( RH( Flag ) = 0 ) then	! can't find file, must be new ;
      begin
	release( BChan );
	return( true );
      end
    else
      begin
	W!Msg( "? Rename Error " & cvs( RH(Flag) ) );
	release( BChan );
	return( false );
      end;

    return( false );  

  end "make backup";
!! title Rtn F!Writ ;
! Routine to write the current file out to DSK ;

internal boolean procedure F!Writ (string FName);
begin "F!Writ"
  if (FName = null) then
    FName _ B!File;

  if (not MakeBackup(FName)) then
    return(false);

  if (not F!Enter(FName)) then
    return(false);

  B!Write(F!Chan);
  F!Close(FName);

  W!FixS;
  return(true);
end "F!Writ";
!! title Rtn F!Scan;
! Given a string, break it down into a filename, alias, and switches.
! This routine sets F!Name, F!Alias, F!Lock, F!Page, F!Line, etc.
;

internal integer procedure F!Scan(string CmdLine);
begin "F!Scan"
  string
    S, UserName, FileName, Ext, SPPN, Switches;
  integer
    C, BC, PPN, Error;
  define
    OurPPN         = {(call(xwd(-1, 2), "gettab"))},
    F.OK           = 0,
    F.BAD.SWITCH   = 1,
    F.BAD.FILESPEC = 2;


  set(G!RNulls);

    ! We remove nulls from the text file by default.
    ;

  clear(F!RPGFlag);

  F!Lock _ null;
  F!Page _
  F!Line _
  F!Char _ 0;

  if (length(CmdLine) = 0) then
    return(F.OK);

    ! All is Ok.
    ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  ! disect the command line ;

  if (not F!Decompose(CmdLine, UserName, Filename, Ext, SPPN,
      F!Alias, Switches)) then
    return(F.BAD.FILESPEC);

  F!Name _ null;
  PPN    _ cvo(SPPN);

  if (length(UserName)) then
    appnd(F!Name, ("(" & UserName & ")"));

  appnd(F!Name, FileName);

  if (length(Ext)) then
    appnd(F!Name, ("." & Ext));

  if (PPN and PPN neq OurPPN) then
    appnd(F!Name, xwdstr(PPN));

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

  C _ lop(Switches);

  F!Search _ null;

    ! We are not searching for anything yet.
    ;

  forever do
  begin "get switch"
    if (not (C = "/" or C = "%")) then done "get switch";

    if (Switches <= " ") then done "get switch";
    S _ NULL;
    while (length(Switches)) do
    begin "switch"
      if not (C!Tab[ Switches ] land IsAlpha) then done "switch";
      S _ S & lop(Switches);
    end "switch";

    if (kequ (S, "Nulls"[1 to length(S)])) then
      clear(G!RNulls)
    else if (kequ(S, "READ"[1 to length(S)])) then
      F!Lock _ -1
    else if (kequ(S, "RPG"[1 to length(S)])) then
      F!RPGFlag _ true
    else if (kequ(S, "P")) then
    begin
      F!Page _ intscan(Switches, BC);
    end
    else if (kequ(S, "L")) then
      F!Line _ intscan(Switches, BC)
    else if (kequ(S, "C")) then
      F!Char _ intscan(Switches, BC)
    else if (kequ(S, "S")) then
    begin
      integer
        C,
        Delim;

      Delim    _ lop(Switches);

      while (length(Switches) and ((C _ lop(Switches)) neq Delim)) do
      begin
        appnd(F!Search, C);

        if (C = CR) then
          appnd(F!Search, LF);
      end;
    end
    else if (length(S)) then
      return(F.BAD.SWITCH);

    C _ lop(Switches);
  end "get switch";

  return(F.OK);
end "F!Scan";
!! title Rtn ReadTMPFile ;
! Read a tempcore or .tmp file and return the contents.
! Return NULL if none.
;

string procedure ReadTMPFile;
begin "tmp"
  string L, TmpFile;
  integer C, Flag;

  L := tmpin( "EDT", Flag );

  if ( not Flag ) then
  begin
    integer array T [0:1];

    T[0] := cvsix( "EDT" );
    T[1] := 0;
    calli( xwd(2, location(T[0])), '44 );	! delete EDT tmpcore file ;
  end;

  L := tmpin( "EDS", Flag );

  if ( Flag ) then
    begin "disk"
      TmpFile := cvs( 1000 + call(0,"PJOB"))[2 for 3] & "EDS.TMP";
      if ( not F!Lkup( TmpFile )) then return( NULL );

      L := NULL;
      while ( ( C := F!GetC ) >= " " ) do L := L & C;
      F!Release;
    end "disk";

  ! o.k. - save the original contents and get rid of the verb ;

  TmpCoreString := L;
  while ( C!Tab[ L ] land IsAlpha ) do lop( L );
  while ( C!Tab[ L ] land IsWhite ) do lop( L );
  while ( L[ inf for 1 ] <= " " ) do L := L[ 1 for inf-1 ];

  return( L );

end "tmp";
!! title Rtn RescanCommandLine ;
! Rescan the command line.  Return the line, or NULL if none
! available.
;

string procedure RescanCommandLine;
  begin "rescan"
    string L, S;
    integer Flag;

    start!code
      setob 1,Flag;
      ttcall '6,1;		! getlch 1 ;
      tlnn 1,'100000;		! lc.ecs - command lines exists ;
	setzm Flag;
    end;

    if ( not Flag ) then return( NULL );

    start!code
      ttcall '10,;		! rescan ;
    end;

    L := inchwl;

    ! make sure that we were invoked correctly ;

    S := NULL;
    TmpCoreString := L;
    while ( C!Tab[ L ] land IsAlpha ) do S := S & lop( L );
    while ( C!Tab[ L ] land IsWhite ) do lop( L );

    if ( not kequ( S, DED!Alias[1 for length( S )] )) then
      TmpCoreString := L := NULL;

    return( L );

  end "rescan";
!! title Rtn Elsewhere ;
! Give the luser somehwere else to go ... ;

simple procedure Elsewhere;
begin
  define
    exit = {calli(1, '12)};

  own integer array
    RnB[0:5];

    ! <<  This should also delete all instantiations of the offending
	  software ;

  calli(cvsix("*PEAK*"), -'63);

  RnB[0] _ cvsix("DSK");
  RnB[1] _ cvsix("TECO");
  RnB[2] _ 0;
  RnB[3] _ 0;
  RnB[4] _ xwd(1, 4);
  RnB[5] _ 0;

  calli(location(RnB[0]), '35);
  exit;
end;
!! title Rtn SanctifyUser ;
! Verify the user's rights of passage ;

simple procedure SanctifyUser;
begin
  integer
    Fpn,
    Aun,
    OurName,
    PrivWrd;

  define
    Coees.Gan   = {'7676},
    Unicon.Gan  = {'35525},
    Daddy       = {xwd(3, '35556)},
    Ded         = {xwd(3, '717040)},
    exit        = {calli(1, '12)},
    FtSys       = {xwd(1, '315372)},
    Gan.3       = {3},
    TymshareBit = {bit(21)},
    Sys         = {xwd(1, 4)};

  define
    Bptym       = {xwd('40545, '67440)}         ! British Petroleum
                                                ! customer for version
                                                ! 1.2
                                                ;,
    Ucslm       = {xwd('11020, '312331)}        ! British Petroleum
                                                ! customer for version
                                                ! 1.2
                                                ;,
    Phillips    = {xwd('43546, '303644)}        ! Phillips Petroleum
                                                ! customer for version 1.2
                                                ;;


  PrivWrd _ call(xwd(-1, 6), "gettab");
  Aun     _ call(xwd(-1, -'23), "gettab");

  if (Aun = Daddy) then
    return;

  if (not (PrivWrd land TymShareBit) and lh(Aun) neq Coees.Gan and
      lh(Aun) neq Unicon.Gan and Aun neq Bptym and Aun neq Ucslm and
      Aun neq Phillips) then
    exit;

  Fpn _ call(xwd(-1, -'25), "gettab");

  if (Fpn neq Sys and Fpn neq FtSys and Fpn neq Ded
      and lh(Aun) neq Gan.3) then
    Elsewhere;

  OurName _ call(xwd(-1, 3), "gettab");

  if (Ourname neq cvsix(DED!Alias)) then
    Elsewhere;
end;
!! title Rtn F!RPG ;
! Find out what file is meant to be editted.
;

internal procedure F!RPG;
begin "rpg interface"
  string
    L;
  integer
    Flag, Error;
  define
    exit           = {calli(1, '12)},
    F.OK           = 0,
    F.BAD.SWITCH   = 1,
    F.BAD.FILESPEC = 2;


  if (RPGSW) then
    L  _ ReadTMPFile
  else
  begin
    L _ RescanCommandLine;

    if (not length(L)) then
      L _ ReadTMPFile;
  end;

  SanctifyUser;

  if (length(L) = 0) then
    return;

  if ((Error _ F!Scan(L)) neq F.OK) then
  begin
    T!Bell;

    if (Error = F.BAD.FILESPEC) then
      print(crlf, L, " [Bad FileSpec]", crlf)
    else
      print(crlf, "? Bad command line: ", L, crlf);

    exit;
  end;

  if (length(TmpCoreString)) then
    tmpout("EDS", TmpCoreString, Flag);

      ! <<  This should handle the error (no-room-in-core) that could
	    occur. ;

end "rpg interface";
!! title Rtn F!Init ;
! Initialize the file I/O module.  (This assumes that F!RPG has
! already been invoked, and that F!Name & Co. are set up.
;

internal procedure F!Init;
begin "init"
  if ( length( F!Name )) then
  begin
    B!Make( F!Name, F!Alias );
    if ( F!Load( F!Name, F!Page, F!Line, F!Char ) ) then
      B!Lock := F!Lock
    else
      W!Msg( "New File" );
  end
  else
    B!Make( "NONAME.TXT", NULL );

  B!ModP := false;
end "init";
end "DED - File I/O";
      2XXBUFF.SAI   c02-May-84 07:32:28  VELXOG    Entry;
begin "DED - Buffer / Checkpoint manager"
  require "DED.DEF" source!file;
!! title Tops20 Buffer/Checkpoint Manager ;

  ifcr TymcomX thenc
    require "!!!! You're compiling the wrong buffer module !!!!" message;
    require "!!!! This one is for Tops20 only.             !!!!" message;
    TryAgainWithTheCorrectModule
  endc


! *************************************************************************
*                                                                         *
*             The Buffer/Checkpoint manager.  Tops20 version.             *
*                       Ken Dawson   25-August-1983                       *
*                                                                         *
**************************************************************************;

!                  From the Language / Operating System.
;

  external integer
    !skip!;                             ! Skip-return flag for SAIL/OS
                                        ! operations.
                                        ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                        From the Utility Module.
;

  external simple integer procedure
    chsizef (integer Chan);             ! Return the size in characters
                                        ! of the file open on the
                                        ! indicated channel.
                                        ;
  external simple procedure
    Blt (integer SrcStart, DstStart, SrcLen);
                                        ! General block transfer
                                        ! routine.
                                        ;
  external simple integer procedure
    DecrBP (integer BP);                ! Return a decremented byte
                                        ! pointer. 
                                        ;
  external simple procedure
    DoErstr;                            ! Produce an error message
                                        ! corresponding to the last
                                        ! detected error condition.
                                        ;
  external simple integer procedure
    ffffp (integer Jfn, StartPage(0));  ! Find first free file page jsys.
                                        ;
  external simple procedure
    MoveBytes (integer SrcPtr, TgtPtr, BytCnt);
                                        ! Transfer byte strings from one
                                        ! place to another.
                                        ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                        From the Command Module.
;

  external safe integer array
    C!Tab ['0:'177];                    ! Character-translation table.
                                        ;

  external integer
    C!Debug;                            ! True if we are debugging.
                                        ;

  external boolean
    G!TextMode,                         ! True iff we are in Text Mode.
                                        ;
    G!RNulls;                           ! True if we want to remove nulls
                                        ! automatically on startup.
                                        ;

  external boolean procedure
    C!Ask (string Question);            ! Ask the user a question through
                                        ! the message line.
                                        ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                          From the File Module.
;

  external  simple boolean procedure
    F!FileExists (string FName);        ! True if the named file exists.
                                        ;
  external boolean procedure
    F!Writ (string FileName);           ! ???
                                        ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                         From the Window Module.
;

  external procedure
    W!SetB (integer BufNum);            ! ???
                                        ;
  external procedure
    W!Msg (string Msg);                 ! Display a message.
                                        ;
  external procedure
    W!FixS;                             ! To cause update of status line.
                                        ;
  external procedure
    W!NewS;                             ! Set to build new status line.
                                        ;
  external procedure
    W!BClr;                             ! ???
                                        ;
  external procedure
    W!BAdd (string Msg);                ! Add a string to the little
                                        ! display window.
                                        ;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                        From the Redisplay Module.
;
  external procedure
    T!Bell;                             ! Do a beep on the terminal.
                                        ;
  external integer
    T!Lines;                            ! Size of physical window.
                                        ;


! ------------------------------------------------------------------------;
!! title Internal Storage ;

!                     Storage for buffer descriptors.
;

  own integer
    B!!Head,                            ! Head of active buffer list.
                                        ;
    B!!List,                            ! Pointer into list.
                                        ;
    B!!Free;                            ! Head of free list.
                                        ;

  own trusted string array
    B!!Alias      [1:BUFMAX],
    B!!ChkPntFile [1:BUFMAX],
    B!!File       [1:BUFMAX],
    B!!Mode       [1:BUFMAX];

  own trusted integer array
    B!!Last       [1:BUFMAX],
    B!!Next       [1:BUFMAX];

  own trusted boolean array
    B!!ModP       [1:BUFMAX];


  ! Static per-buffer storage.
  ;

  internal string
    B!Alias,                            ! "alias" for filename.
                                        ;
    B!ChkPntFile,                       ! Name of the current Checkpoint
                                        ! file.
                                        ;
    B!File,                             ! Filename the buffer came from.
                                        ;
    B!Mode;                             ! Mode(s) that apply to this
                                        ! buffer.
                                        ;

  internal boolean
    B!BegP,                             ! True iff point is at 0.
                                        ;
    B!EndP,                             ! True iff point is at B!Size.
                                        ;
    B!ModP;                             ! True iff buffer has been
                                        ! modified.
                                        ;

  internal integer
    B!Size,                             ! The number of characters in the
                                        ! buffer at any given time.
                                        ;
    B!Lock,                             ! State of the write-lock on the
                                        ! buffer. 
                                        ;
    InsertLock,                         ! Indicates that the Buffer is
                                        ! locked against character
                                        ! insertions.
                                        ;
    DeleteLock,                         ! Indicates that the Buffer is
                                        ! locked against character
                                        ! deletions.
                                        ;
    B!Prot,                             ! Buffer's protection code.
                                        ;

    B!WS0,                              ! Mark Index of the starting point
                                        ! of the first window.
                                        ;
    B!WS1,                              ! Mark Index of the starting point
                                        ! of the second window.
                                        ;
    B!CkPtSer,                          ! Serial number of the checkpoint
                                        ! file.
                                        ;
    B!DedVer;                           ! Version number of the editor
                                        ! that created the checkpoint
                                        ! file. 
                                        ;

  own integer
    B!Point,                            ! The Point is the position
                                        ! indicator for the cursor,
                                        ! located between characters in
                                        ! the buffer.  Its value is the
                                        ! number of characters to the
                                        ! left of the cursor.
                                        ;
    B!LastP;                            ! Mark Index of the Last Position
                                        ! indicator. 
                                        ;


! ************************************************************************;


  ! Storage for things other than buffers.
  ;

  preset!with
    hl('350700),
    hl('260700),
    hl('170700),
    hl('100700),
    hl('010700);

  own safe integer array
    B!BPLeft [0:4];

    ! This magic is used to build byte pointers.  The five numbers point
    ! to the 0th, 1st, ... 4th 7 bit characters in a 36 bit word.
    ;


! ------------------------------------------------------------------------;

!                    Regarding User and Internal Marks
!
!
!       We define two areas in the array which contains all marks
!       maintained by Peak, the User Marks area (in the range [0,
!       #UserMarks - 1]) and the Real Marks area ([FirstMark, MaxMarks]).
!
!
!                          --------------------
!                          |                  | User Marks
!                          |                  |
!                          --------------------
!                          |                  | Real Marks
!                          |                  |
!                          |                  |
!                          |                  |
!                          |                  |
!                          --------------------
!
!
!       User Marks are distinguished in the sense that they are finite in
!       number (determined at compile time), and that they are
!       pre-allocated to the index range [0, #UserMarks - 1].
!
!       When the user sets a mark, a slot in the Real Marks area is
!       allocated, and its index placed in the appropriate User Mark
!       slot.
!
!       When an internal routine allocates a mark, the index in the Real
!       Marks range of the allocated mark is returned
!
!       Mark-updating procedures in the insert and delete operations deal
!       only with marks allocated in the Real Marks area, thus minimizing
!       the amount of work done to what is necessary.
!
!
;

  define
    #UserMarks     = {10},
    FirstMark      = {#UserMarks},
    #InternalMarks = {30},
    MaxMarks       = {((2 * #UserMarks) + #InternalMarks)};

  own integer
    MarkCnt;

      ! The number of Real Marks allocated at the current time.
      ;

  own integer array
    Marks[0 : MaxMarks - 1];

      ! The array containing the entire Mark structure.
      ;


! ------------------------------------------------------------------------;
!! title Some Definitions ;
! <<  Encyphering: Enter with no lookup will allegedly cause the file to
!     be hidden from the file system until a close is done on it.
;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                                Globally
;

! <<  Global Lock variables for (1) Insert    lock
!                               (2) Delete    lock
!                               (3) Read-Only lock
;

  define
    !ChrMask (X) = {!mask(36 - ((X + 1) * 7))};

  preset!with
      !ChrMask(0),
      !ChrMask(1),
      !ChrMask(2),
      !ChrMask(3),
      !ChrMask(4);

  own safe integer array
    ChrMsk [0:4];                       ! This is a set of character
                                        ! masks for composing a word of
                                        ! bytes from two different
                                        ! source words.  (See MoveTextPL)
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                             Process-Related
;

  define
    !fhslf = {bit(18)};                 ! The Tops-20 designator for the
                                        ! current process.
                                        ;

  integer
    B!Chan;                             ! The channel related to the
                                        ! Checkpoint file.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                          Page-Mapping Related
;


  define
    !CPg (X) = {xwd(B!Chan, X)},
    !MPg (X) = {xwd(!fhslf, X)},
    !TPg (X) = {xwd(F!Chan, X)};

    ! These define a series of device designators for the pmap calls.
    ;

  define
    !Count! (X)  = {(bit(0) lor (X land !mask(18)))}

                                        ! A repeat count is specified.
                                        ;,
    !Cow!        = {bit(9)}             ! Copy-on-write acccess.
                                        ;,
    !Rd!         = {bit(2)}             ! Read access.
                                        ;,
    !Wt!         = {bit(3)}             ! Write access.
                                        ;,
    !RdWt!       = {(!Rd! lor !Wt!)}    ! Read-Write access.
                                        ;,
    !PreRef!     = {bit(5)}             ! Pre-Reference the page.
                                        ;;



! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                       Regarding the Virtual File
;

  internal integer
    B!MaxPgIdx;                         ! Index of the last page in the
                                        ! Virtual File.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                         Regarding the EDT Area
;

! The EDT area contains all checkpointable quantities associated with the
! individual buffer.  These are the variables which are remembered when
! we return to a buffer after having edited another buffer.
;

  define
    EDTSize = {1};                      ! Size in pages of the EDT
                                        ! portion of the giant buffer.
                                        ;


  integer
    EDT;                                ! The location of the base of the
                                        ! EDT portion of the giant array.
                                        ;


  define
    !B!EdName  = {memory[EDT + 0]},
    !B!DedVer  = {memory[EDT + 1]},
    !B!CkPtSer = {memory[EDT + 2]},

    !B!Point   = {memory[EDT + 3]},
    !B!Size    = {memory[EDT + 4]},
    !B!ModP    = {memory[EDT + 5]},
    !B!Lock    = {memory[EDT + 6]},
    !B!Prot    = {memory[EDT + 7]},
    !B!WS0     = {memory[EDT + 8]},
    !B!WS1     = {memory[EDT + 9]},

    !B!File1   = {memory[EDT + 10]},
    !B!File2   = {memory[EDT + 11]},
    !B!File3   = {memory[EDT + 12]},
    !B!File4   = {memory[EDT + 13]},
    !B!File5   = {memory[EDT + 14]},
    !B!File6   = {memory[EDT + 15]},

    !B!Alias1  = {memory[EDT + 16]},
    !B!Alias2  = {memory[EDT + 17]},
    !B!Alias3  = {memory[EDT + 18]},
    !B!Alias4  = {memory[EDT + 19]},
    !B!Alias5  = {memory[EDT + 20]},
    !B!Alias6  = {memory[EDT + 21]},
    !B!Alias7  = {memory[EDT + 22]},

    !B!Mode1   = {memory[EDT + 23]},
    !B!Mode2   = {memory[EDT + 24]},

    !B!BufNum  = {memory[EDT + 25]},
    !B!MarkCnt = {memory[EDT + 26]},
    !B!Marks   = {memory[EDT + 27]},

    !B!LstWrd  = {memory[EDT + 28 + MaxMarks - 1]};


    ! These are the offsets used to designate the locations corresponding
    ! to the named objects in the EDT area.
    ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                      Regarding the Checkpoint file
;


  ! The format of the Checkpoint file is as follows:

                  -------------------------     memory[HEAD]
                  |                       |
                  |       Header          |         HEADSize
                  |                       |
                  -------------------------     memory[ICBM]
? Should this     |                       |
? be here?        |        ICBM           |         ICBMSize
?                 |                       |
                  -------------------------     memory[PPM]
                  |                       |
                  |         PPM           |         PPMSize
                  |                       |
                  -------------------------     memory[EDT]
                  |                       |
                  |         EDT           |         EDTSize
                  |                       |
                  -------------------------     memory[ICB]
                  |                       |
                  |                       |         ICBSize
                  |        Data           |
                  |                       |
                  |                       |
                  -------------------------
  ;


  integer
    HEAD;                               ! The address of the base of the
                                        ! Header portion in the giant
                                        ! array.
                                        ;

  define
    HEADSize = {1};                     ! Size in pages of the Header
                                        ! portion of the giant array.
                                        ;

  define
    $H$ICBM   = {memory[HEAD + 0]}      ! Page offset of the ICBM Block.
                                        ;,
    $H$PPM    = {memory[HEAD + 1]}      ! Page offset of the PPM Block.
                                        ;,
    $H$EDT    = {memory[HEAD + 2]}      ! Page offset of the EDT Block.
                                        ;,
    $H$Data   = {memory[HEAD + 3]}      ! Page offset of the Data Block.
                                        ;,
    $H$DedVer = {memory[HEAD + 4]}      ! The signature of the editor
                                        ! version that created this
                                        ! CheckPoint file.
                                        ;;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                           Regarding the ICBM
;

! The ICBM currently occupies 1 page of memory.
! The ICBM is indexed (=[0, MaxICBMIdx]).
! An ICBM entry is empty iff $ICBM.VFPg is < 0.
;


  integer
    ICBM;                               ! Location of the In-Core Buffer
                                        ! Map.
                                        ;

  define
    ICBMWordsPerEntry = {4};            ! The number of words which
                                        ! constitute an entry in the ICB
                                        ! map.  This number should be a
                                        ! factor of WordsPerPage.
                                        ;

  define
    ICBMSize = {1};                     ! The size in pages of the ICBM
                                        ! portion of the giant array.
                                        ;

  define
    ICBMEntries = {((ICBMSize * WordsPerPage) div ICBMWordsPerEntry)};

      ! The number if entries in the ICBM.
      ;

  define
    MaxICBMIdx = {ICBMEntries - 1};     ! The maximum value which an
                                        ! index into the ICBM can
                                        ! attain.
                                        ;

  define
    IWPE              = {ICBMWordsPerEntry};

      ! Generally useful substitution.
      ;

  define
    $I.MP             = {0},
    $I.VP             = {1},
    $I.MC             = {2};

      ! These are the offsets of the various fields within the ICBM
      ! entry.
      ;

  define
    $ICBM.Adr   (Pg)    = {ICBM + (Pg * IWPE)},
    $ICBM.MP    (Adr)   = {memory[Adr + $I.MP]},
    $ICBM.VP    (Adr)   = {memory[Adr + $I.VP]},
    $ICBM.MC    (Adr)   = {memory[Adr + $I.MC]};

      ! These are primitives for accessing the fields of a ICBM entry,
      ! given that we know the entry's address.
      ;
      ! 
      ;
  define
    $ICBM.MemPg   (I) = {memory[ICBM + (I * IWPE) + 0]},
    $ICBM.VFPg    (I) = {memory[ICBM + (I * IWPE) + 1]},
    $ICBM.MissCnt (I) = {memory[ICBM + (I * IWPE) + 2]};

      ! The access-methods for the various fields of an ICBM entry.
      ;

      ! We define these fields as follows:
      !
      !   $ICBM.MemPg   (I)
      !     The physical page in memory where the contents of the Ith ICB
      !     page reside.
      !
      !   $ICBM.VFPg    (I)
      !     The index of the Virtual File page mapped to the Ith ICB page.
      !
      !   $ICBM.MissCnt (I)
      !     The number of times which the Ith ICB page has not been
      !     selected, and yet has remained in memory.
      ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                            Regarding the ICB
;

  integer
    ICB;                                ! Location of the In-Core Buffer.
                                        ;

  define
    ICBSize = {ICBMEntries};            ! The size in pages of the ICB
                                        ! portion of the giant array.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                            Regarding the PPM
;

    ! ((  Note that this assumes that the PPM consists of only 1
    !     (resident) section.
    ;

  integer
    PPM;                                ! The memory address of the PPM
                                        ! buffer.
                                        ;

  define
    PPMWordsPerEntry  = {8};            ! The number of words in a single
                                        ! page's entry in the PPM.  This
                                        ! number must be a factor of
                                        ! WordsPerPage.
                                        ;

  define
    PPMEntries = {1024};                ! The number of entries in the
                                        ! PPM.
                                        ;

  define
    MaxPPMIdx = {PPMEntries - 1};       ! The maximum value that an index
                                        ! into the PPM can attain.
                                        ;

  define
    PPMSize = {((PPMWordsPerEntry * PPMEntries) div WordsPerPage)};

      ! The size of the portion of the giant buffer occupied by the PPM.
      ;

  define
    PWPE               = {PPMWordsPerEntry};

      ! Generally useful substitution.
      ;

  define
    $V.LG             = {0},
    $V.TL             = {1},
    $V.RG             = {2},
    $V.IX             = {3},
    $V.CP             = {4};

      ! These are the offsets of the various fields within the PPM entry.
      ;

  define
    $VFPg.Adr   (Pg)  = {PPM + (Pg * PWPE)},
    $VFPg.LG    (Adr) = {memory[Adr + $V.LG]},
    $VFPg.TL    (Adr) = {memory[Adr + $V.TL]},
    $VFPg.RG    (Adr) = {memory[Adr + $V.RG]},
    $VFPg.IX    (Adr) = {memory[Adr + $V.IX]},
    $VFPg.CP    (Adr) = {memory[Adr + $V.CP]};

      ! These are primitives for accessing the fields of a PPM entry,
      ! given that we know the entry's address.
      ;

  define
    $VFPg.LftGap (Pg) = {memory[PPM + (Pg * PWPE) + $V.LG]},
    $VFPg.TxtLen (Pg) = {memory[PPM + (Pg * PWPE) + $V.TL]},
    $VFPg.RgtGap (Pg) = {memory[PPM + (Pg * PWPE) + $V.RG]},
    $VFPg.ICBIdx (Pg) = {memory[PPM + (Pg * PWPE) + $V.IX]},
    $VFPg.ChkPg  (Pg) = {memory[PPM + (Pg * PWPE) + $V.CP]};

      ! These are primitives for accessing the fields of a PPM entry at
      ! random.
      ;

      !   We define these fields as follows:
      !
      !     $VFPg.LftGap (I)
      !       The location of the first character after the left gap on
      !       page I.  This is equivalent to saying that it is the length
      !       of the gap preceding the text on this page.
      !
      !         length($VFPg.LftGap(I)) =
      !             $VFPg.LftGap(I)
      !
      !     $VFPg.TxtLen (I)
      !       The length of the text residing on page I.
      !
      !     $VFPg.RgtGap (I)
      !       The location of the first character following the last text
      !       character on page I.  When the text ends at the end of the
      !       page, this value is CharactersPerPage.
      !
      !         length($VFPg.RgtGap(I)) =
      !             CharactersPerPage - $VFPg.RgtGap(I) 
      !
      !     $VFPg.ICBIdx (I)
      !       The index of page I in the In-Core Buffer.
      !
      !     $VFPg.ChkPg  (I)
      !       The index of page I in the Checkpoint file.  This is the
      !       actual file page on which Virtual File page I resides.
      !
      !     In General,
      !       length($VFPg.LftGap(I)) + $VFPg.TxtLen(I) =
      !           CharactersPerPage
      !
      ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                        Giant page-mapped buffer
;

! Note: We exploit the correspondence in layout between the beginning of
!       the Checkpoint file and the beginning of the giant array by using
!       ICBBase to denote the first data page in the Checkpoint file.
!       This consitutes a mixed metaphor.
;

  define
    HEADBase    = {0},
    ICBMBase    = {HEADBase  + HEADSize},
    PPMBase     = {ICBMBase  + ICBMSize},
    EDTBase     = {PPMBase   + PPMSize},
    ICBBase     = {EDTBase   + EDTSize},
    EndOfBuffer = {ICBBase   + ICBSize};

    ! Define the bases of the various portions of the giant array.
    ;

  integer
    GiantBase;                          ! The address of the first page
                                        ! boundry in the giant array.
                                        ;

  preload!with
    [((EndOfBuffer + 1) * WordsPerPage + 1)] 0;

    ! This incantation is included in order to avoid the fuss Sail would
    ! otherwise go through to initialize the venerable giant.
    ;

  safe integer array
    GiantArray[0: (EndOfBuffer + 1) * WordsPerPage];

    ! The physical array for holding all the current page-mapped buffers.
    ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

ifcr false thenc
require crlf message;
require "ICBMEntries: " & cvs(ICBMEntries) & crlf message;
require "MaxICBMIdx:  " & cvs(MaxICBMIdx) & crlf message;
require "MaxPPMIdx:   " & cvs(MaxPPMIdx) & crlf message;
require "PPMSize:     " & cvs(PPMSize) & crlf message;
require "HeadBase:    " & cvs(HeadBase) & crlf message;
require "ICBMBase:    " & cvs(ICBMBase) & crlf message;
require "PPMBase:     " & cvs(PPMBase) & crlf message;
require "EDTBase:     " & cvs(EDTBase) & crlf message;
require "ICBBase:     " & cvs(ICBBase) & crlf message;
require "EndOfBuffer: " & cvs(EndOfBuffer) & crlf message;
require "Length:      " & cvs((EndOfBuffer + 1) * WordsPerPage) message;
require crlf message; 
endc

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
!! title File Inclusions ;
! The source is large enough to warrant being split up, especially since
! we must edit it on Tops20 with version 0.145, which does file I/O a
! character at a time!
;

  require "xxbuf1.req" source!file;
  require "xxbuf2.req" source!file;

end "DED - Buffer / Checkpoint manager"


! **************************  End XXBuff.Sai  *************************** ;
      2XXFILE.SAI   Ò02-Apr-84 15:31:53  YOZMER    Entry;
begin "DED - File I/O"
  require "DED.DEF" source!file;
!! title Tops-20 File I/O Module ;

ifcr TymcomX thenc
  require "!!! This is the Tops-20 File I/O module !!!" message;
  TryAgainWithTheTymcomXVersion
endc


! *************************************************************************
*									  *
*	 This module handles all disk I/O, and isolates all system	  *
*      dependent file system calls into one file.  The RPG interface	  *
*			     also lives here.				  *
*									  *
*		     Dave W. Smith,  October '81 - ...			  *
*									  *
**************************************************************************;


!            Entry points in other modules that we reference.
;

! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                      From the SAIL runtime system
;

  external integer
    !skip!,                             ! Indicates an error occurred in
                                        ! some quadrant of the Runtimes.
                                        ;
    RPGSW,              		! True iff called w/ offset
                                        ;
    C!Debug;                            ! True if we are doing run-time
                                        ! debugging and performance
                                        ! monitoring.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                         From the Utility Module
;

  external simple procedure
    DoErStr;                            ! Print out the message of the
                                        ! last error to occur.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                         From the Buffer Module.
;

  external integer
    B!Size,                             ! Total number of characters in
                                        ! the buffer.
                                        ;
    B!MaxPgIdx;                         ! Index of the last page of the
                                        ! Checkpoint file.
                                        ;

  external string
    B!File;				! Name of the Text file being
                                        ! edited. 
                                        ;

  external simple boolean procedure
    B!CreateChkPntFile
        (string TName, TAlias(null); 
        integer TPage(0), TLine(0),
        TChar(0));                      ! Create a new checkpoint file
                                        ! and fill it with the named
                                        ! Text file.
                                        ;
  external simple boolean procedure
    B!WriteTextFile (string FName);     ! Write the Checkpoint file to
                                        ! the named Text file.
                                        ;
  external procedure
    B!SetP (integer Position);          ! Set the point.
                                        ;
  external procedure
    B!Insert (integer C);		! Insert a character.
                                        ;

  external procedure
    B!Delete (integer Dir);		! Delete a chracter.
                                        ;

  external integer procedure
    B!GetP;			        ! Get the point.
                                        ;

  external simple integer procedure
    B!GetC;			        ! Get char at point.
                                        ;

  external simple procedure
    B!Move (integer Dir);		! Move the point.
                                        ;


  external boolean
    B!BegP,                             ! The Point is at the beginning
                                        ! of the Buffer.
                                        ;
    B!EndP,			        ! The Point is at the end of the
                                        ! Buffer.
                                        ;
    B!ModP;				! The Buffer is modified.
                                        ;

  external integer
    B!Prot,				! Buffer protection.
                                        ;
    B!Lock;                             ! The current Buffer lock
                                        ! condition.
                                        ;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                         From the Window Module
;


  external procedure
    W!Disp (boolean PuntIfKeyHit);

  external procedure
    W!Msg (string S);

  external boolean
    W!MsgF;

  external procedure
    W!NewS;			        ! Create new status line.
                                        ;

  external procedure
    W!FixS;


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                         From the Command Module
;


  external boolean
    G!RNulls,                           ! Remove nulls from the Text file
                                        ! automatcially if true.
                                        ;
    G!ShowGens;                         ! Show Generation numbers in file
                                        ! names.
                                        ;

  external boolean procedure
    C!Ask (string Question);

  external safe integer array
    C!Tab['0:'177];


! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

!                        From the Redisplay Module
; 

  external procedure
    T!Bell;

  external procedure
    T!Fini;

  external procedure
    T!RSet;


! ------------------------------------------------------------------------;
!! title Internal Storage ;
!                    Storage internal to this module.
;

  internal integer
    F!Chars;		                ! Chars yet to be read from file.
                                        ;

  own integer
    F!Chan,			        ! Channel of current file.
                                        ;
    F!EOF,			        ! True iff eof reached.
                                        ;
    F!EOFSeen,
    F!InputCount,
    F!OutputCount,
    F!Prot;			        ! File protection.
                                        ;


!                       Stuff scanned from a filename
;

  internal boolean
    F!RpgFlag;          		! true iff to exit to RPG.
                                        ;
  own boolean
    F!Lock;     			! true iff /read.
                                        ;
  own integer
    F!Page,
    F!Line,
    F!Char;                     	! where to start.
                                        ;
  own string
    F!ReScanLine,                       ! Contents of the legendary
                                        ! rescan buffer.
                                        ;
    F!Name,     			! file name.
                                        ;
    F!Alias,    			! r e g n a d   k c i n.
                                        ;
    F!String;                           ! String for holding a filespec.
                                        ;
!! title Rtn MakeFName ;
! Return a filename compiled of the parts supplied.
;

simple string procedure MakeFName (string Dev, Usr, Nam, Ext, Gen);
begin "MakeFName"
  string
    Str;

  Str _ null;

  if (length(Dev)) then
    appnd(Str, Dev & ":");

  if (length(Usr)) then
    appnd(Str, "<" & Usr & ">");

  appnd(Str, Nam);

  if (length(Ext) or (length(Gen) and G!ShowGens)) then
    appnd(Str, ("." & Ext));

  if (G!ShowGens) then
    appnd(Str, ("." & Gen));

  return(Str);
end "MakeFName";
!! title Rtn F!Exit ;
! Do system dependent termination stuff.
;
! <<  In Tymcom-X, this did a run of (Sys)Rpg in order to facilitate
!     ^X^E.  What should we do here?
!
!     Virgil proposes a push-to-compile or push-to-load or
!     push-to-execute command set, since he does not see that this is
!     possible with the Tops-20 exec, which does not keep tmpcore files.
!
!     Does Tymcom-X presuppose an Exe when no tmpcore exists?
;

internal procedure F!Exit;
begin
  if (F!RPGFlag) then
  begin
    T!Fini;

    start!code
      haltf;
    end;

      ! ** hack **
      ;

    T!RSet;
    T!Bell;
  end;
end;
!! title Rtn F!Decompose ;
! Decompose a Tops-20/PEAK FileSpec, which must be of the following form:
!
! <FileSpec>    ->      <Fs>(<Alias>)(<Switches>)
! <Fs>          ->      (<Device>)(<UserName>)<FileName>(<Prot>)
! <UserName>    ->      '<' <Un> '>' | '[' <Un> ']'
! <Un>          ->      repeat(<V0>, 1-39)
! <Device>      ->      repeat(<V1>, 1-39) ':'
! <FileName>    ->      <FilePart> ('.' <ExtPart>)('.' <GenPart>)
! <FilePart>    ->      repeat(<V1>, 1-39)
! <ExtPart>     ->      repeat(<V1>, 0-39)
! <GenPart>     ->      repeat(<DecNum>, 0-*)
! <Prot>        ->      <semicolon> repeat(<OctNum>, 6)
! <Alias>       ->      '"' repeat(<V2>, 1-*) '"'
! <Switches>    ->      '/' <Sw> | '%' <Sw>
! <Sw>          ->      repeat(ASCII, 1-*)
! 
! <V0>          ->      <V1> | '.'
! <V1>          ->      <Alpha> | <DecNum> | '-'
! <V2>          ->      {ASCII - '"'}
! 
! <Alpha>       ->      'A' - 'Z' | 'a' - 'z' 
! <DecNum>      ->      '0' - '9'
! <OctNum>      ->      '0' - '7'
!
! <semicolon>   ->      (This is literally a semicolon, which cannot be
!                       included here without being taken personally by
!                       SAIL.)
! 
! 
! (The function repeat(Item, Minimum-Maximum) is replaced by between
! Minimum and Maximum number of occurences of Item, inclusively.  The
! special symbol '*' indicates no limit.)
!
! The symbol 'ASCII' indicates the entire ASCII character set.
!
! Braces ('{' and '}') enclose set specifications - eg, "{ASCII - '"'}"
! means all characters except '"'.
;


internal boolean procedure F!Decompose (string InStr; reference string Dev, UserName, File, Ext, Gen, Alias, Switches);
begin "F!Decompose"
  label
    S0, S1, S2, S3, S4, S5, S6, S7, S8, S9, S10, S11, S12, SGood, SBad;
  integer
    C;
  string
    LDev, LUserName, LFile, LExt, LGen, LProt, LAlias, LSwitches,
    Str, Tst;
  define
    sp               = {" "},
    IsAlphabetic (X) = {("A" <= UpShift(X) <= "Z")},
    IsNumeric    (X) = {("0" <= X <= "9")},
    IsOctal      (X) = {("0" <= X <= "7")},
    IsWhiteSpace (X) = {(X = sp or X = tab)},
    IsV1         (X) = {(IsAlphabetic(X) or IsNumeric(X) or (X = "-"))},
    IsV0         (X) = {(IsV1(X) or (X = "."))};

  Str  _
  LDev _ LUserName _ LFile _ LExt _ LGen _ LProt _ LAlias   _ LSwitches _
  Dev  _ UserName  _ File  _ Ext  _ Gen  _ Alias _ Switches _ null;


  S0:
      ! Nothing seen
      ;

    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if (C = "[" or C = "<") then goto S3;
    if (IsV1(C)) then
    begin
      appnd(Str, ToUpper(C));
      goto S1
    end;
    goto SBad;


  S1:
      ! Picking up Device or Filename
      ;

    if (not length(InStr)) then
    begin
      LFile _ Str;
      goto SGood;
    end;
    C _ lop(InStr);
    if (C = ":") then
    begin
      LDev _ Str;
      goto S2;
    end;
    if (C = ".") then
    begin
      LFile _ Str;
      goto S5;
    end;
    if (C = """") then
    begin
      LFile _ Str;
      goto S9;
    end;
    if (C = "/" or C = "%") then
    begin
      LFile _ Str;
      goto S11;
    end;
    if (IsV1(C)) then
    begin
      appnd(Str, ToUpper(C));
      goto S1;
    end;
    goto SBad;


  S2:
      ! Colon seen - we just picked up the Device name.
      ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = "[" or C = "<") then goto S3;
    if (C = ".") then goto S5;
    if (C = """") then goto S9;
    if (C = "/" or C = "%") then goto S11;
    if (C = ";") then goto S7;
    if (IsV1(C)) then
    begin
      appnd(LFile, ToUpper(C));
      goto S2;
    end;
    goto SBad;


  S3:
      ! '[' or '<' seen - pick up UserName.
      ;

    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if (C = "]" or C = ">") then goto S4;
    if (IsV0(C)) then
    begin
      appnd(LUserName, ToUpper(C));
      goto S3;
    end;
    goto SBad;


  S4:
      ! "]" or ">" seen - pick up FileName.
      ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = ".") then goto S5;
    if (C = """") then goto S9;
    if (C = "/" or C = "%") then goto S11;
    if (C = ";") then goto S7;
    if (IsV1(C)) then
    begin
      appnd(LFile, ToUpper(C));
      goto S4;
    end;
    goto SBad;


  S5:
      ! Dot seen - pick up an Ext.
      ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = ".") then goto S6;
    if (C = """") then goto S9;
    if (C = "/" or C = "%") then goto S11;
    if (C = ";") then goto S7;
    if (IsV1(C)) then
    begin
      appnd(LExt, ToUpper(C));
      goto S5;
    end;
    goto SBad;


  S6:
      ! Dot seen - pick up a Generation number.
      ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = """") then goto S9;
    if (C = "/" or C = "%") then goto S11;
    if (C = ";") then goto S7;
    if (IsNumeric(C)) then
    begin
      appnd(LGen, C);
      goto S6;
    end;
    goto SBad;


  S7:
      ! Semicolon seen - pickup Protection field.
      ;

    if (not length(Instr)) then goto SBad;
    appnd(LProt, C);
    C _ lop(InStr);
    if (ToUpper(C) = "P") then
    begin
      appnd(LProt, ToUpper(C));
      goto S8;
    end;
    goto SBad;


  S8:
      ! 'P' seen - pick up Protection expression.
      ;

    if (length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = """") then goto S9;
    if (C = "/") then goto S11;
    if (IsOctal(C)) then
    begin
      appnd(LProt, C);
      goto S8;
    end;
    goto SBad;


  S9:
      ! Quote seen - pick up an Alias.
      ;

    if (not length(InStr)) then goto SBad;
    C _ lop(InStr);
    if (C = """") then goto S10;
    appnd(LAlias, ToUpper(C));
    goto S9;


  S10:
      ! Second quote seen.
      ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    if (C = "/" or C = "%") then goto S11;
    goto SBad;


  S11:
      ! '/' or '%' seen - put it on the front of the switch.
      ;

    LSwitches _ C;
    goto S12;


  S12:
      ! Gather the rest of the line as switches.
      ;

    if (not length(InStr)) then goto SGood;
    C _ lop(InStr);
    appnd(LSwitches, ToUpper(C));
    goto S12;


  SGood:
      ! Many Happy Returns ;

    Tst _ MakeFName(LDev, LUserName, LFile, LExt, LGen);

    if (gtjfn(Tst, (bit(12) lor bit(17))) = -1) then

      ! Parse-only gtjfn to verify the legitimacy of what we've got.
      ;

      goto SBad;
      
    Dev      _ LDev;
    UserName _ LUserName;
    File     _ LFile;
    Ext      _ LExt;
    Gen      _ LGen;
    Alias    _ LAlias;
    Switches _ LSwitches;

!    print
    (
      "Dev: (", Dev, ")", crlf,
      "UserName: (", UserName, ")", crlf,
      "File: (", File, ")", crlf,
      "Ext: (", Ext, ")", crlf,
      "Gen: (", Gen, ")", crlf,
      "Alias: (", Alias, ")", crlf,
      "Switches: (", Switches, ")", crlf
    );

    return(true);


  SBad:
      ! Oops - something smells funny ;

    UserName _ File _ Ext _ Gen _ Alias _ Switches _ null;

    return(false);
end "F!Decompose";
!! title Rtn F!Parse ;
! Parse and sanctify a file name, returning a kosher-processed version of
! the input string, to be used by the caller for approved purposes.
;

internal string procedure F!Parse(string FName);
begin "F!Parse"
  string
    JfnStr,
    Dev,
    Usr,
    Fn,
    Ext,
    Gen,
    Dummy;

  if (not F!Decompose(FName, Dev, Usr, Fn, Ext, Gen, Dummy, Dummy)) then
    return(null);

  JfnStr _ null;

  if (length(Dev)) then
    appnd(JfnStr, Dev & ":");

  if (length(Usr)) then
    appnd(JfnStr, "<" & Usr & ">");

  appnd(JfnStr, Fn);

  if (length(Ext) or length(Gen)) then
  begin
    appnd(JfnStr, "." & Ext);

    if (length(Gen)) then
      appnd(JfnStr, "." & Gen);
  end;

  return(JfnStr);
end "F!Parse";
!! title Rtn F!Writ ;
! Write the current Buffer to the specified Text file.
;

internal boolean procedure F!Writ (string FName);
begin "F!Writ"
  if (FName = null) then
    FName _ B!File;

  if (not B!WriteTextFile(FName)) then
    return(false);

  W!FixS;
  return(true);
end "F!Writ";
!! title Rtn F!Scan ;
! Look at a command-line filespec and decide whether it is ok or not. In
! general, a filespec can be OK or have a BAD FILESPEC or have BAD
! SWITCHES.
;

forward simple boolean procedure SetSwitches (string Switches);

internal simple integer procedure F!Scan (string FName);
begin "F!Scan"
  string
    Dummy,
    Sw;
  define
    F.OK           = 0,
    F.BAD.SWITCH   = 1,
    F.BAD.FILESPEC = 2;

  if (not F!Decompose(FName, Dummy, Dummy, Dummy, Dummy, Dummy,
      Dummy, Sw)) then
    return(F.BAD.FILESPEC);

  if (length(Sw) and not SetSwitches(Sw)) then
    return(F.BAD.SWITCH);

  return(F.OK);
end "F!Scan";
!! title Rtn Elsewhere ;
! Give the luser somehwere else to go ...
;

simple procedure Elsewhere;
begin
  runprg("Ps:[Emacs]Teco.Exe", 0, false);
                                        ! Run Teco in this fork,
                                        ;
  exit;                                 ! Just in case.
                                        ;
end;
!! title Rtn SanctifyUser ;
! Verify the user's rights of passage.
;
! <<  Can we tell the pedigree of both caller and program on T20?
!     Probably not.
;

simple procedure SanctifyUser;
begin
end;
!! title Rtn DoRescan ;
! Pick up and return the contents of the legendary ReScan Buffer.
;

simple string procedure DoRescan;
begin "DoRescan"
  integer
    Byte,                               ! A character temporary.
                                        ;
    RescanBytes;                        ! The number of bytes in the
                                        ! ReScan Buffer.
                                        ;
  string
    Str;                                ! We form our reply in this
                                        ! string.
                                        ;

  start!code
    setz        1,;
    rscan;
      setz      1,;
    movem       1, RescanBytes;
  end;

  Str _ null;

  while (RescanBytes) do
  begin
    start!code
      movei     1, -1;
      bin;
      movem     2, Byte;
    end;

    appnd(Str, Byte);
    decr(RescanBytes);
  end;

  while (length(Str) and (Str[inf for 1] <= " ")) do
    Str _ Str[1 to inf - 1];

    ! Lop garbage off the end of Str.
    ;

  return(Str);
end "DoRescan";
!! title Rtn SetSwitches ;
! Analyse the specified switch string, set the appropriate global
! switches, and return true if all went well.
;

simple boolean procedure SetSwitches (string Switches);
begin "SetSwitches"
  integer
    BC,                                 ! Suprizingly useful.
                                        ;
    C;
  string
    S;

  set(G!RNulls);

    ! Remove nulls from the Text file automatically by default.
    ;

  F!Page _
  F!Line _
  F!Char _ 0;
  C _ lop(Switches);

  while (true) do
  begin "get switch"
    if (not (C = "/" or C = "%")) then
      done "get switch";

    if (Switches <= " ") then
      done "get switch";

    S _ null;

    while (length(Switches)) do
    begin "switch"
      if not (C!Tab[Switches] land IsAlpha) then
        done "switch";

      appnd(S, lop(Switches));
    end "switch";

    if (kequ(S, "Nulls"[1 for length(S)])) then
      clear(G!RNulls)
    else if (kequ(S, "READ"[1 to length(S)])) then
      F!Lock _ -1
    else if (kequ(S, "RPG"[1 to length(S)])) then
      F!RPGFlag _ true
    else if (kequ(S, "P")) then
      F!Page _ intscan(Switches, BC)
    else if (kequ(S, "L")) then
      F!Line _ intscan(Switches, BC)
    else if (kequ(S, "C")) then
      F!Char _ intscan(Switches, BC)
    else if (length(S)) then
      return(false);

    C _ lop(Switches);
  end "get switch";

  return(true);
end "SetSwitches";
!! title Rtn F!Rpg ;
! Determine the credentials of the user, the editor, and the invocation.
;

internal simple procedure F!Rpg;
begin "F!Rpg"
  integer
    C;                                  ! A character temporary.
                                        ;
  string
    ReScanLine,                         ! A local copy of the contents of
                                        ! the ReScan line.
                                        ;
    Verb;                               ! The first token of the command
                                        ! line should be a verb.
                                        ;

  SanctifyUser;

  F!ReScanLine _
  ReScanLine   _ DoReScan;

  Verb _ null;

  while (length(ReScanLine)) do
    if ((C _ lop(ReScanLine)) > " ") then
      done;

  while (length(ReScanLine)) do
  begin
    if ((C _ lop(ReScanLine)) = " ") then
      done;

    appnd(Verb, C);
  end;

  if (not length(ReScanLine)) then
  begin
    F!Name  _ "NoName.Txt";
    F!Alias _ null;
    return;
  end;

  begin
    string
      Alias,                            ! Magnum Alias.
                                        ;
      Dev,                              ! Device Name.
                                        ;
      Ext,                              ! File Extension.
                                        ;
      Gen,                              ! File Generation count.
                                        ;
      FName,                            ! File Name.
                                        ;
      Switches,                         ! User-specified switches.
                                        ;
      User;                             ! File's Username
                                        ;

    if (F!Decompose(ReScanLine, Dev, User, FName, Ext, Gen, Alias,
        Switches)) then
    begin
      if (not SetSwitches(Switches)) then
      begin
        print(ReScanLine, " [bad switches]", crlf);
        exit;
      end;

      F!Name  _ MakeFName(Dev, User, FName, Ext, Gen);
      F!Alias _ Alias;
    end
    else
    begin
      print(ReScanLine, " [bad command line]", crlf);
      exit;
    end;
  end;
end "F!Rpg";
!! title Rtn F!FileExists ;
! Determine whether a specified file exists.
;

internal simple boolean procedure F!FileExists (string FName);
begin "F!FileExists"
  integer
    F!Chan;
  define
    ForInput = 0;

  if (not length(FName)) then
    return(false);

  F!Chan _ gtjfn(FName, ForInput);

  if (not !skip!) then
  begin
    rljfn(F!Chan);
    return(true);
  end;

  return(false);
end "F!FileExists";
!! title Rtn F!Init ;
! Initialize the file I/O module.  (This assumes that F!Rpg has already
! been invoked, and that F!Name & Co. are set up.)
;

internal procedure F!Init;
begin "F!Init"
  if (not B!CreateChkPntFile(F!Name, F!Alias, F!Page, F!Line,
      F!Char)) then
    exit;

  if (F!FileExists(F!Name)) then
    B!Lock _ F!Lock
  else
    W!Msg("New File");

  B!ModP _ false;
end "F!Init";
end "DED - File I/O";


! *************************  End of XXFile.Sai  ************************* ;
        2PEAK.SAV    Ú30-Jun-84 00:07:51  NOGSEC    h §b 0  +   x ©   vx -bÿ{ / @  à7    O@ u²-  v,>  ,>  [,>  X4+   9Z  â     H KÝ, 16, h, ^, mþ, Xn, 8j,~   , w7@j d@l pf, X<,>  c,<  ì,<  m, }~,<  ê,<  k, }~Z  â 8  (Nò,>  ,-, }~,<  i,<  é, }~Z  â @  (PwA0 ÿ,>  ,-, }~,<  ç,<  h, }~Z  â H  A2ÿ,>  ,-, }~,<  f,<  æ, }~,<  n,<  î, }~,<  ä,<  e, }~/  b,  4, 8V, tF, h',>  d,>  ã, {o+   R 6  ],z P  /  á,~   ` Ö    ±    H  ^   p Y        ]x Ú 
p  x Üx   X ÝDED - Top Level Logic    P àÿ          ¯ÿ    ~h d    H  å...      H  g)        H  è (       H  j.        H  ë Version      H  íPEAK x î  H x p    0x q @  à` ó    à    a P  
    W( ö7    O@   -    ,>  ,> 9²,>  X4+  ?    þ~<    þh ü   ¿      @H>@   {@@  þQ8  þX8  *8 >+  P   D~xB                
    
                   MACRO IDKEYBODYNAMELASTNEXT   xÍ~xK        x     H Ç    : H     H    : È     È     I     ÉxÔ   uOHÕ         D   Í   Û|   ÛhÙ   ó      tO@  X@@ ÛQ8 ÛX8 \*8 O+  ï   Vc   Õ               8î@  Ò@@ VQ8 VX8 Ö*8 î+  6   õ<   õhó    ¿       @uõ                                                                   	        
                                                                                                                                              (    (   !(   ¡(   "(   ¢(   #(   £(   $(   ¤(   %(   ¥(   &(   ¦(  '(   §(   ((   ¨(   )(   ©(   *(   ª(   +(   «(   ,(  ¬(   -   ­   .   ®   /   ¯   0(    (   !(   ¡(   "(   ¢(   #(   £(   $(   ¤(   %(   ¥(   &(   ¦(  '(   §(   ((   ¨(   )(   ©(   *(   ª(   +(   «(   ,(  ¬(   -   ½   >   ¾   ?    ¿@  r+  &Zÿ/ 9J+x Zÿ/ 9J+x  ÿ H 9   þ H 9(Hw0H  +  ¾,> 9, (+  ¿:  9, 97  9+  Â 
 9 J 9  9 L 9/ 9J+x 6@ 9+  E+  M@@ ÍQ"  X 9	b  +    \"  B   O@ Í7@ Í+  M,< ?b,< ?â, _j, B,> 9Ö, d,~   |`Í7@ 9+  P\"ÿ+  SZ 94N R\"ÿ+  S, hÍ+  S,~   Z 94P ×Z 94R Ö> 9 9 R h+  Þ7@ 9+  Z, RD B h+  Þ, N5B \,> 9Õ, d, N5B Ý, Ã, h_ B h7@ 9 +  æ,< 9,< 9,> h,
®,\ 9,\ 9Z 90D  d+  æ@f 9 ,< ?Û,< ?\, _;, i¼  h+  ç,~   }Xh, Ó B {2B 9+  n,< ?Z,< ?Ú, _;, ÓG"  @ B {+  ò  {2H 9+  ò,< ?Ø,< ?Y, _;, ÓG"   B { 
 {A* @4J ù,> {, », _;7@ 9+  ù7@ 9+  ùZ 95L ù,> 9Õ, d  {+  ú,~   y{, i¼,< ?ä,< ?e, _;@n 97@ 9 +  @p 9 Z 9/2  ,< 9,< 9,>  ,> 9W,
Ò,\ 9,\ 9   91`  ¿+  
Z 9/$  ,< 9,< 9,>  ,> 9W,
Ò,\ 9,\ 9,< ?U,< ?Õ, _;,~   @f 9,~   @h 9Oj 9,~   @l 9,< ?S,< ?Ó, _;,~   6@ 9+   .   N 9  9$ 9,>  ,&,< ?Ñ,< ?R,	}, _;@r ³ R 4, Ó B 31"  +     31`  +  +  £Ob 4  ³$$    3/&  .   D ³$ 9,>  ,&,< ?Ñ,< ?R,	}, _;+  ,> 3,< 9,< 9,
­,\ 9,\ 97@ 9 +  ,Z 9/(  ,< 9,< 9,>  ,> 9W,
Ò,\ 9,\ 97@ 4+  / 
 9$
 ³ J 9+  °  9$ 9 L 9,< ?ä,< ?e, _;On 9,~   ~4@p 9, h_1B  +  7+  5,~   @r 9   9¢0@  +  »,< ?N,< ?Î, _;+  Â,< ?Ì,< ?M, _;, è B C  9¢.$   D 9¢     þ FÕ,< ?ä,< ?e, _;,~   ~HC@h 96@ 9¢+  G,< ?I,< ?É, _;+  Î,< ?Ì,< ?M, _;, è B O 
    9¢ 0Õ L( þ  9¢/.   N 9¢,< ?ä,< ?e, _;,~   xO, IÍ    @õA 9Ð   +  Ò,~   , IÍ    HõA 9Í   +  V,~   , IÍ    õA 9O   +  Ù,~   , IÍ    õA 9I   +  ],~   , IÍ     õA 9N   +  à,~   , IÍ 
   
(õA
 9L   +  d,~   6@ KÚ+  g, IÍ0B  +  h\"ÿ+  ò, IÍ1B  +  ê!"   +  ò,> 9W, I6@ KÚ+  n, IÍ0B  +  ð,> 9Õ, I\"ÿ+  ò+  ò,> 9Õ, I!"   +  ò,~   7@ KZ+  u\"ÿ+  	,> 9Õ, I, IÍ0B  +  z,> 9W, I\"ÿ+  	+  	, IÍ0B  +  	,> 9Õ, I6@ KZ+  , IÍ0B  +  	,> 9W, I,> 9W, I\"ÿ+  	+  	,> 9W, I,> 9W, I!"   +  	+  	,> 9W, I!"   +  	,~   , IÍ B 	,> 9W, I  	0L  +  	, IÍ0B  +  	,> 9W, I,~   }0	7@ KZ+  	+  	,> 9Õ, I, IÍ0B  +  	6@ KZ+  	,> 9Õ, I, IÍ1B  +  	,> 9W, I,~   ,>  ,> 	¢,>  Z4, s5B 	, 	+  	 P  / 9È+x     Ö   	    H 	%             	¤    h   9®	   9´~0	¤MOVETOBOL ,>  ,> 	0,>  Z4, ä5B 	*, 	+  	( P  / 9È+x    	   	&    H 	²             	2    @  x9®`	*   9´w8	2MOVETOEOL ,>  ,> 	|,>  Z4\. ?e,N 9
,N 9Op d§ P ,<Oÿ,<H  ,< 9,< 9
,
, _;, Ó B 	w0B  +  	Á\  ?e,@ 9
,@ 9@b d§!"   Z6 	ÿ,z+  	u+  	m  	w3DWþ+  	Ä  	w2FW+  	Å+  	í+  	m  	w1H  +  	È 
 	w0J  ¿+  	_Z 9,< 9,< 9
,> 9W,>  ,
ÒZwÿ4N 	Mp  / 9J0N  +  	ZZ 9/0  ,< 9,< 9
,> 9W,>  ,
ÒZwÿ4R 	Óp  / 9J0R  +  	ZZ 9/$  ,< 9,< 9
,>  ,> 9W,
Ò,\ 9
,\ 9+  	ÞZ 9/&  ,< 9,< 9
,>  ,> 9W,
Ò,\ 9
,\ 9+  	m  	w0H  +  	ä, Ó,< 9,< 9
,>  ,
®,\ 9
,\ 9+  	m 
 	w0J  +  	j,< 9,< 9
,< ?Ç,< ?H,
,\ 9
,\ 9+  	m,< 9,< 9
,> 	w,
®,\ 9
,\ 9+  	· P ,<7ÿ,<0  ,< 9,< 9
,
,< ?F,< ?Æ,
, _;@n d§\"ÿZ6 	ÿ,z+  	u/ 9J P  / 9H+x ~x	w   	«   	³    H 

            	ÿ  	~   P9®8	u   9´     
    
   x   x
 CREADSTRING   ,>  ,> 
E,>  Z4\0 ?e,P 9
,P 9Or d§ P ,<ÿ,<  ,< 9,< 9
,
, _;, Ó B 
@0B  +  
\& ?e,F 9
,F 9@h d§!"   Z6 
È,z+  
>+  
6 
 
@3JWþ+  
  
@2LW+  
+  
¶+  
6  
@1N  +  
  
@0P  ¿+  
­Z 9,< 9,< 9
,> 9W,>  ,
ÒZwÿ4D 
p  / 9J0D  +  
¨Z 9/&  ,< 9,< 9
,> 9W,>  ,
ÒZwÿ4H 
"p  / 9J0H  +  
¨Z
 9/*  ,< 9,< 9
,>  ,> 9W,
Ò,\ 9
,\ 9+  
-Z 9/,  ,< 9,< 9
,>  ,> 9W,
Ò,\ 9
,\ 9+  
6  
@0N  +  
3, Ó,< 9,< 9
,>  ,
®,\ 9
,\ 9+  
6,< 9,< 9
,> 
@,
®,\ 9
,\ 9+  
 P ,<Gÿ,<@  ,< 9,< 9
,
,< ?F,< ?Æ,
, _;@r d§\"ÿZ6 
È,z+  
>/ 9J P  / 9H+x ~x
@   	÷   
    H 
É
            
È  
G(   89®  
>   9´     
    
   x   w
ICREADLITSTRING,>  ,> ,>  Z4\  ?e,@ 9
,@ 9Ob d§ P ,<ÿ,<  ,< 9,< 9
,
, _;, Ó B 0B  +  
Y\& ?e,F 9
,F 9@h d§!"   Z6 ,z+  +   
 0J  +  
ÜZ 95L 
Ü+  +    0N  +  
eZ 9,< 9,< 9
,> 9W,>  ,
ÒZwÿ4R 
âp  / 9J0R  +  
e+  +     1@  +  
h  0B  ¿+  
þZ 9,< 9,< 9
,> 9W,>  ,
ÒZwÿ4F 
ìp  / 9J0F  +  
ùZ 9/(  ,< 9,< 9
,> 9W,>  ,
ÒZ
wÿ4J 
s
p  / 9J0J  +  
ùZ 9/,  ,< 9,< 9
,>  ,> 9W,
Ò,\ 9
,\ 9+  
~Z 9/.  ,< 9,< 9
,>  ,> 9W,
Ò,\ 9
,\ 9+    0P  +  , Ó,< 9,< 9
,>  ,
®,\ 9
,\ 9+  ,< 9,< 9
,> ,
®,\ 9
,\ 9+  
O P ,<Oÿ,<H  ,< 9,< 9
,
,< ?F,< ?Æ,
, _;@` d§\"ÿZ6 ,z+  / 9J P  / 9È+x    
À   
K    H 
              2   )H9®)0   9´    x   {pCREADESCSTRING   4,>  ,> 8,>  Z4 P ,<ÿ,<  ,> 9R,> 9Ò, 	³5B "+  1+  °Z 94F $  9
  1F  ¬+  (Z 94H '  9
  0H  ¼+  ©\"ÿ+  ±+  °Z
 94J « 
 9

  1J  '+  ¯Z 94L ®  9
  0L  7+  °!"   +  ±, i¼+  / 9J P  / 9È+x           H ;
            º  :6@  3P9®38±   9´    z ºCASK,>  ,> ð,>  Z4 W1.  +  A\0 ?Ä,P ë,P k+  F W12  @+  Ä\  ?C,@ ë,@ k+  F\" ?e,B ë,B k WA$  ¿ DW5D L,< k,< ë,< ?A,< ?Á,
,\ ë,\ k+  g W0F  +  Ñ,< k,< ë,< ?¿,< ?@,
,\ ë,\ k+  g W0H  +  W,< k,< ë,< ?>,< ?¾,
,\ ë,\ k+  g 
W0J  ¿+  Ü,< k,< ë,< ?¼,< ?=,
,\ ë,\ k+  g W0,  +  d,< k,< ë,< ?;,< ?»,
 W..   ,>  ,
®,\ ë,\ k+  g,< k,< ë,>W,
®,\ ë,\ k,< k,< ëZ6 s,z+  é P  / 9Ç+x ë   ³   »    H t             s  ò=H  7P9®78é   9´ 
   x   hóCVCMDCHR    kzõ,>  ,> Å,>  Z4+  0,>  7   @ [@ 0X Á+  ùQ0 ',>  ,>  Z4 W12  +  \  ?¹,@ &,@ ¥+   W1"  @+  \$ ?·,D &,D ¥+  \& ?e,F &,F ¥ WA(  ¿ HW5H ,< ¥,< &,< ?5,< ?µ,
,\ &,\ ¥+  ¡ 
W0J  +  ,< ¥,< &,< ?³,< ?4,
,\ &,\ ¥+  ¡ W0L  ¿+  ,< ¥,< &,< ?2,< ?²,
,\ &,\ ¥+  ¡ W0.  +  ,< ¥,< &,< ?;,< ?»,
 W.0   ,>  ,
®,\ &,\ ¥+  ¡,< ¥,< &,>W,
®,\ &,\ ¥,< ¥,< &Z6 ­,z+  $ P  / 9Ç+x &   l   ø    H ®             ­  -Dp  ?PÁ?$   H 
   x
   }p.CV     ¥   õ\2 ?e,R @,R ¿ P Zÿ4D : 
P Z/ÿ4H µ>/ÿ(   H À,>  , ø,< ¿,< @,	},\ @,\ ¿+  ±/ 9J,< ¿,< @Z6 H,z+  > 6 H,z P  / 9È+x À   ¦   v    H I            H  ÇH  >x9®>`>   9´    x   {xÈCVCMDSTR    ¿   ¯,>  ,> f,>  Z4 W2L 9Õ+  Ô7@ KZ+  Ð!"   +  `,> 9Õ, I Wþ, z«4B T\"ÿ+  `+  ß W0N  +  \ Wþ, z«4B Ø\"ÿ+  `,> 9W, I7@ KÚ+  Û!"   +  `+  ß,> 9Ö,> 9Ö,< ?0,< ?°,< ?ä,< ?e, yÚ+  M P  / 9H+x    A   K    H j
             i  hL   IH9®I0`   9´$
    
   x    |(éMOVETO    ,>  ,> ,>  Z4 W0P  +  ó,> 9W, I6@ KÚ+  r Wþ, z«5B s\"ÿ+  ~+  ý W2R 9Õ+  z,> 9Õ, I6@ KZ+  ø Wþ, z«5B ù\"ÿ+  ~+  ý,> 9Ö,> 9Ö,< ?.,< ?®,< ?ä,< ?e, yÚ+  m P  / 9H+x    á   k    H 
               P   MH9®M0~   9´$
    
   x    {hMOVEPAST  ,>  ,> ®,>  Z4  Wþ1   +   Wþ0"  ¿+   "  Z6 ±,z+  (+  ( Wþ0D  +  !"   Z6 ±,z+  (+  ( Wþ0F  +  7@ 9©+   "  Z6 ±,z+  (+   "  Z6 ±,z+  (+  ( Wþ0H  +  & *   J © W& 9&4R £  ©.2   R ©  W.    @W+    ©Z6 ±,z+  (+  ( "  Z6 ±,z+  ( P  / 9H+x  ©   ÿ   	    H ²
             ±  °U(  Q(9®Q(   9´ 
    
   x   ~P2CHARWIDTH , H¢ B ½, 	 "   B >, H¢3B ½+  <, IÍ,>  ,> >, 	. > B >,> 9W, I+  6  >+  =,~   ~H>, H¢ B J, 	 &   F Ê, Ö4B Æ, IÍ,>  ,> Ê, 	. Ê B Ê,> 9W, I+  A,> J, H$ 
 Ê/*     +  É,~   ~ Ê, ³ B Y3bÿ+  Î, 	 ,   L Y  Y2.ÿ+  X, IÍ B Ù1B  +  Ó  Ù0P  +  T+  X,> 9W, I,> Ù,> Y, 	. Y B Y+  Î/ 9G+x |xÙ6 ÿ+  Û@`ÿ, ³ B t, ¾/ÿ"  . t1"   "   B ò@d ó ÿ F s7@ 9(+  å ÿ& 9& P ó ÿ& 9& N s, 	, Ö4B è,> 9W, I+  f7@ ó+  ì,> 9U, I:  ó/0   P ó+  è7@ s+  ð,> 9Ñ, I:   s/    @ s+  ì,> ò, K/ 9J+x yht,>  ,> ­,>  Z4,> 9W,> 9K,> 9W,Ì B &@d ¨ P Z'ÿ4F  
 ¨.*   J ¨0*  0j  (b ?,.
 & P Z?ÿ4L >?ÿ8   L/ÿ+  ù, H¢ B ¦ 0   P (  (2r ¨+   7@ KÚ+  +   , H¢ B '   (2` ¨+   , IÍ B §,> 9W, I7@ 9++    (0$  0d  (b ?,. & ÿ2D §+    (.&   F (+  6@ 9++    (0(  0h  (b ?,. & 'ÿ  õA(ÿ 
 § 
(õA*ÿ2H  +    (.,   L (+  ,> ', H$,> 9W, I .   N (+   +  +    (2p ¨+  #,> ¦, H$ 6 0,z/ 9J P  / 9È+x ~p¨   *   ô    H ²            0  ¯e  ^`9®^H$   9´     &x   x   þx   þyh2FORWARDSEARCH  ,>  ,> ë,>  Z4,> 9W,> 9K,> 9W,Ì B d@r æ P Zÿ4D Á  æ.(   H æ0(  0h  (b ?,. d P Z
7ÿ4J À>
7ÿ
0   J'ÿ+  9, H¢ B ä  æ N f7` f+  _, H¢ B e7` f+  Þ7@ KZ+  H+  _,> 9Õ, I, IÍ B å7@ 9++  Q  f00  0p  (b ?,. d Gÿ2P å+  Q  f/2   R f+  ^6@ 9++  Ú  f0$  0d  (b ?,. d ÿ õA$ÿ  å õA&ÿ2D  +  Ú  f/(   H f+  ^,> e, H$,> 9Õ, I 
 æ J f+  Þ+  Å+  Ã7` f+  a,> ä, H$ 6 n,z/ 9J P  / 9È+x ~pæ   )   4    H ð            n  ílx  fX9®f@b   9´     dx   x   þx   þ{hpBACKWARDSEARCH ,>  ,> ,>  Z4,> 9W,> 9Î,> 9W,Ì B ,> 9W,> 9Î,> 9W,Ì B ,> 9W,> 9Î,> 9W,> 9K,> 9×,Ì B +  ,>  7   0 [0 0X 	+  ~Q, ,>  ,>  Z4 .   N 2n +  	0.  0n  b ?ª. 7@?ÿ+  \"ÿ+  
  9 !"   +  
 P  / 9È+x    g   }    H 
                 q@  p	oP
   r ISMATCH     3p +  g  "2     +  ,~   @` @b ,> ,> 9Ö,	Ï P Zÿ,<ÿ,<  ,> 9W,>  ,
ÒZwÿ4H p  / 9J H  P Z
7ÿ4J Ä  ..   N 1n  +  §,< ?&,< ?¦, _;!"   Z6 ,z+   P ZGÿ4R * @    3R +  =  0$  0d  b ?$.   0&  0f  b ?$.  ÿ.&   Fÿ  0(  0h  b ?,$(  ( 
 0*  0j  b ?$.
  
/ÿ0*  0j  (d ?,.
  .
  P Z?ÿ4L <>?ÿ8   L/×+  § P ZOÿ4P ¿> Oÿ`H    0$  0d  b ?$.   3&ÿ ÿ F +   , H¢ B  B  (   H @j 6@ KÚ+  x,> ,> 9Õ,	Ï, IÍ B  ,   L 2l +  ï0,  0l  b ?ª. 7@7ÿ+  ë7@ 9++  X  0.  0n  b ?,$.  (  00  0p  (d ?,.  .  G×3P +  â6@ 9++  ë  02  0r  b ?,$2  (  0$  0d  (d ?,.  .  × õA$ÿ   õA&ÿ2D  +  ë  0(  0h  b ?ª. Oj'ÿ  0,  0l  b ?$.   2N7ÿ+  k   P +  x+  î  02  0r  b ?ª. @`Oÿ  9 Ë,> 9W, I  ."   B , }4B t, 5B J  .$   D ,>  , H$ &   F +  Ç7@ +  ü,> 9W, I  Z6 ,z+  +  ÿ,> , H$!"   Z6 ,z+   6 ,z/ 9J P  / 9È+x ~X      r    H 
                n89®n    9´       x   x   þx   þx   þ{ MULTIPLESEARCH    px            x     H ?£    H ?#    H ?¢    H ?"    H ?¡    H ?!    H ?     H ?     H ?    H ?    H ?    H ?@    `   Ê+  4*,>  ,> B,>  Z4,> 9Ö,> 9S, {o B »&"  .$   D <  »&0   P »&0  .2   R ¼  »&.  ..    N =,>  ,&,< ?,< ?,
(R  ,<H,<H,
,< ?,< ?,
,>  ,&,
Z6 D,z+  : P  / 9F+x =      ¦    H E             D    `   9®h:   9´x   |xÄDATESTR   ,>  ,> d,>  Z4,> 9Ö,> 9Ô, {o&"   B Ý&"   D _  Ý&0   P Ý&0   P ^  Ý&,   N Þ,>  ,&,< ?,< ?,
..  2,>  ,&,> 9×,> 9×,
Ò,
,< ?,< ?,
.$  2,>  ,&,> 9×,> 9×,
Ò,
Z6 f,z+  \ P  / 9È+x _   ½   F    H g             f       x9®`\   9´x   z@æTIMESTR   , H¢ B , `,>  , H$7@ 9ª+   .   N @p 7@ KÚ+  î+  , IÍ B 0B  +  r7@ 9«+  r+  ,> ,> , 	.  B    1@  +  ù  1B  +  ù  /$  3$ ph+     .(   H , `2B +  ý+  +   ,> ,> 9W, 	."   B , 	+  m+  @j 7@ KÚ+  +  , IÍ B 0B  +  7@ 9«+  +    1L  +  
  0N  +    .2   R , `2B +  +  , 	+  ,> ph, K, H¢ B ,> , H$  +  ,~   {, 	&, 	,~   , 	, 	,~     ÿ0@  +  , ä5B , Ö5B , 	+  +  $ ÿ2B 9Õ+  $, 	, s5B ¢, Ö5B ¢, 	+  , Ö4B $, 	/ 9J+x  ÿ0D  +  *, ä5B ©, Ö4B ©, 	+  ¦+  ° ÿ2F 9Õ+  °, 	, s5B /, Ö4B /, 	+  ,, Ö5B °, 	/ 9J+x , H¢ B ¼, 	6@ KÚ+  6, Ö4B 6, 	+  36@ KÚ+  ¸, ä5B ¸g
  "*   J <,> ¼, H$  <+  »,~   yX¼7@ÿ+  A,> 9Ñ, I: ÿ/.   Nÿ+  =/ 9J+x 7@+  I,> 9Ò, I:,> 9V, I:7@ÿ+  G,>ÿ, Z /2   R+  B/ 9Æ+x   ÿ3` 9Õ+  ß 0B  +  S, H¢,>ÿ B ï, Hà3b ï+  Ò, Z4B Ò,> 9W, I+  M+  _ 2D 9Õ+  _, H¢,>ÿ B ï, Hà2" ï+  _, H¢,>ÿ B ï, Hà2" ï+  Ý, 	, Z4B ],> 9W, I+  ×, Z5B _, 	+  î 0F  +  å, H¢2" KÚ+  e, Z4B e,> 9W, I+  a+  î 2H 9Õ+  î6@ KZ+  î6@ KZ+  m, 	, Z4B l,> 9W, I+  ì+  m+  h, Z5B î, 	/ 9Æ+x {(ï 
ÿ3j 9Õ+   0L  +  y, H¢,>ÿ B , Hà3b +  ø, Ö4B ø,> 9W, I+  s+   2N 9Õ+  , H¢,>ÿ B , Hà2" +  , H¢,>ÿ B , Hà2" +  , 	, Ö4B ,> 9W, I+  ý, Ö5B , 	+   0P  +  , H¢2" KÚ+  , Ö4B ,> 9W, I+  +   2R 9Õ+  6@ KZ+  6@ KZ+  , 	, Ö4B ,> 9W, I+  +  +  , Ö5B , 	/ 9Æ+x vp  ÿ0@  +  6@ KÚ+  , Z5B +  , 	+  +  " ÿ2B 9Õ+  ", 	6@ KZ+   , Z4B  , 	+  , Z5B ", 	/ 9J+x  $   D aOf á@h _, H0 B à, H¢ B `,>þ, Hà3b `+  ], Z4B 6,> 9W,>~, J ~3jÿ+  ±,> 9W þ/,  ,>  , B  O~@p _+  µ  ` R á,> a, = ~. a G~Oj _+  Ü, IÍ B ß1B  +  ¼  ß1L  +  ¼  ß1N  +  ¼  ß0P  +  ½ 2  +  G   ß1@  +  E  ß1B  +  E  ß1D  ®+  E  ß1F  +  E  ß0H  +  F 
 a+  Æ *      R a, 	 ~3lÿ+  ×7@ _+  ×,> à, H¢,>  , Hø,> á, H$,> 9W,>~, J,> à, Hà/ á B b,> 9W þ/.  ,>  , B,> à, Hà,>  , H$ . b Q~+  Ü  ß0R  +  [ ~/&   G~+  Ü ~.*   K~+  &,> à, H¿/ 9Ç+x rb7@ KÛ+  ä@l 9+  Ð  91.   .   N 97@ 9*+  ó  910  +  ó00  ¿+  ó 2   R R2r 9+  ó, ä5B ó, IÍ0B  +  ñ, ³& 9&5D q,> 9W, I+  ò,> 9W, I  R9 ê7@ 9§+  ¶   93@ 9+  w, ³ B Ñ  90B  +    $   D Ñ &   F R2f 9+  ÿ,> 9Ò, I:6@ 9­+  þ,> 9V, I:  R9 z+    90H  +   *   J R2j 9+  ,> 9U,> Ñ, 	 B Ô. Ñ B Ñ6@ 9(+  7@ 9­+  
,> 9U, I:+  ,> Ô, = 
 R9
 +    90N  +    Ñ/ 9 R Ñ+    Ñ. 9 F Ñ (   H R2h 9+  ,> 9, I:  R9  
 9¤.*  2* Ñ+  6, H0 B T,>  , H¢,>  , Hø, 	&, H0 B Ó,>  , H¢,>  , Hø,> T, Hà,>  , H$  9¤.,  2, Ñ+  $  9¤..  ,>  , K,> 9Õ, %,> 9Õ, ,> 9Õ, %,> 9Õ, , ³ B Ñ,> Q,> Ó,> 9%,> 9¤, #,> T, Hà,>  , H$  91P  +  °  90R  +  3, ä4B 3, 	,> 9W, %, ³ B Ñ,> T, H¿,> Ó, H¿+  P   90@  +  ¾ $   D R2d 9+  >,> 9Ò, I:6@ 9­+  =,> 9V, I:  R9 ¸+  P  90F  +  L, ³ B Ò (   H R2h 9+  Ë,> 9U,> Ò, 	 B S. Ò B Ò6@ 9(+  H7@ 9­+  É,> 9U, I:+  Ê,> S, =  R9 Á+  P ,   L R2l 9+  P,> 9, I:  R9 Ì@n 9,~      Ñ~pÔ7@ KÛ+  W@p 9+  Ý  9 R ^   â @ 9  9 B Þ $   D 9, â  Þ F 9  ^ H 9,~   ~pÞ7@ KÛ+  a@j 9+  ç  9 L h . â N 9  9 P è 2   R 9, â   è @ 9  h B 9,~   }pè7@ 9*+  êg  "$   D 9*, ^g@f 9,~   7@ KÛ+  o@h 9+  ù,< ?,< ?, _; 
 9 J z , â L 9  9 N úOr 9­, Ó B 9, â@` 9­  z B 9  ú D 9,< ?ä,< ?e, _;,~   ~Pú7@ KÛ+  }@f 9+  , H¢ B   9 H  * â J 9  9 L  .   N 9, â   P 9   R 9,> , H$,~   ~ ,>  ,> ,>  Z47@ KÛ+  @` 9Z6 ,z+    91"   "   B 9, ¾ B 7@ 9+  , ,> 9Ò, I:,> 9V, I:,> , Z  9/&   F 9+   P  / 9È+x    ß       H                  C  A9®@x   9´x   }xCINDENTUP,>  ,> 5,>  Z47@ KÛ+  ¥@h 9Z6 7,z+  ® 
 91*   *   J 9, ¾ B 07@ 9+  ®,> 9Ò, I:,> 9V, I:,> 0, Z  9/.   N 9+  ¨ P  / 9È+x 0           H 8             7    F  D 9®D®   9´x   }`·CINDENTDOWN   ,>  ,> O,>  Z47@ KÛ+  ¾@p 9Z6 Q,z+  È  912   2   R 9, ³/"   B J7@ 9+  È, 	&,> 9Ò, I:,> 9V, I:,> J, Z  9/&   F 9+  B P  / 9È+x J   °   ¹    H R             Q    I0  G09®GÈ   9´x   wxÑCCOLUMNDOWN     91(   (   H 97@ 9+  [7@ KÚ+  ØOl 9!+  [, 	  9/0   P 9+  Õ,~     912   2   R 97@ 9+  c7@ KZ+  àOf 9!+  c, 	 
 9/*   J 9+  Ý,~   , 	@l 9,~   , 	&@n 9,~     910   0   P 9 2 æ3R 9+  ì   v3@ 9+  ì, ³ B 9¥7@ 9+  s, 	7@ KZ+  pOf 9!+  s, 	, 	 
 9/*   J 9+  ì6@ 9+  u,> 9¥, K@l 9,~     91.   .   N 9 0 æ3P 9+  | 2 v3R 9+  |, ³ B 9¥7@ 9+  , 	&7@ KÚ+  ÿOf 9!+  , 	 
 9/*   J 9+  |6@ 9+  ,> 9¥, K@l 9,~     91.   .   N 9, H¢ B , `,>  , H$7@ 9+  , 	&, 	  9/2   R 9+  , H¢,>  , `, H¢3"   ,>  , H$, bu,~   }    91        @ 9, H¢ B ), `,>  , H$7@ 9+  , 	, 	  9/&   F 9+  , H¢,>  , `7@ 9ª+  ¥, h B ©,>  , H$, ä5B ¢ 
 ©/*   J ©  )2l ©  ©,>  , H$+  (, h2b )  ),>  , H$, bu,~   ~p©, bu, `,>  , H$, ^´@n 9,~   , bu, H¢ B 3, 	, H¢,>  , `,> 3, H$@p 9,~   ~P3,~   , bu7@ 9ª+  », h B ¾,>  , H$, ä5B :   ¾/    @ ¾,> ¾, H$+  =, h,>  , H$, ^´@b 9,~   } ¾6` 9+  A $   D 9, bu, `,>  , H$7@ 9+  Õ, `/"   B ×7@ ×+  O7@ KÚ+  H+  Õ, IÍ B W0B  +  K@f ×+  N, IÍ0B  +  N  ×/(   H ×, 	+  Å, IÍ0B  +  Q, 	6@ KÚ+  Ó, H¢,>  , ` 
 9/*   J 9+  C, ^´@l 9,~   |`×6` 9+  Z .   N 9, bu, `,>  , H$7@ 9+  ð, 	, IÍ0B  +  ß, 	, ` B ò@p r, IÍ B r7@ KZ+  ã+  ð  r0R  +  f@` ò+  i  r0B  +  i  ò/$   D ò6@ ò+  ê+  ë, 	+  a6@ ò+  m, 	, H¢,>  , `  9/&   F 9+  \, ^´@h 9,~   ~xò, 	6@ KZ+  z, IÍ B û0B  +  ÷, 	+  z7@ KZ+  y+  z, 	+  ô, ^´@j 9,~   û, ^´7@ KÚ+  ~+  , IÍ B 0B  +  +  , 	+  ü@l 9,~   }x,> 9Ö, H$, ^´@n 9,~   ,> 9T, H$, ^´@p 9,~   6` 9+  
 2   R 97@ 9+  , IÍ B ,> 9W, I   0@  +  , IÍ0B  +  ,> 9W, I  9/&   F 9+  
,~   } 6` 9+   (   H 9@j *7@ 9+  ¦7@ KZ+  @l 9+  ©, ` B ª, H¢3B ª+  g  ".   N *, 	, IÍ0B  +  £,> 9W, I, IÍ0B  +  #,> 9W, I+  ¤,> 9W, I  9/2   R 9+  7@ *+  ©, 	,> 9Õ, d, 	,~   |ª, Ö4B ­,> 9W, I+  +@` 9,~   6@ KZ+  5,> 9Õ, I, Ö4B 3,> 9W, I+  ´,> 9W, I+  5+  ®@b 9,~   ,>  ,> Ï,>  Z47@ KÛ+  ¼,< ?,< ?, _;@d 9Z6 Ñ,z+  I@f 9, H0 B Ê,>  , H¢,>  , Hø,> 9Ö, H$6@ KÚ+  F, IÍ5B Ä,> 9W, I+  Å,> 9W, I+  A,> Ê, Hà,>  , H$,> Ê, H¿ P  / 9È+x Ê   Ê   6    H Ò             Ñ    i8  fx9®f`I   9´x   } RCDELNULLS,>  ,> è,>  Z4  94( Þ0h  +  Þ,> 9, H¢,>  , Hø,> 9,&,< ?,< ?,	},< ?,< ?,
, _;+  b,> 9,&,< ?,< ?,	}, _;, i¼@j 9 P  / 9È+x    K   Ó    H k             ê    lH  jP9®j8â   9´}PêCSETMARK ,>  ,> ,>  Z4  94, ø0l  +  ø,> 9, Hà B ~5" w,> 9,&,< ?,< ?,	},< ?,< ?,
, _;+  x,> ~, H$+  |,> 9,&,< ?,< ?,	}, _;, i¼@n 9 P  / 9È+x ~   d   l    H                  op  mX9®m@ü   9´x   {XCGOTOMARK  940 0p  +  ,> 9, H¿,> 9,&,< ?,< ?,	},< ?,< ?,
, _;+  ,> 9,&,< ?,< ?,	}, _;, i¼@r 9,~   ,>  ,> .,>  Z47  9+     91`  +  ,> 9,&,< ?,< ?,	}, _;+  ¦, H¢ B ¨,> 9, Hà B )5" £,> 9,&,< ?,< ?,	},< ?,< ?,
, _;+  &,> ), H$,> 9,> ¨, Hø, ^´@b 9 P  / 9È+x )   þ       H 1             0    u   rP9®r8'   9´x   |°CSWAPPM  @d 9, h», mþ, ^g,> 9Ö, d,~   @f 9, ^g,> 9Ö, d,~   , H¢ B Q1"  +  O,> 9Õ, I, IÍ B Ð,> 9W, I,> 9Õ, I@h P 
 Ð0J  +  D, IÍ0B  +  D,> 9W, I,> 9Õ, IOn P, IÍ0B  +  I,> 9Õ, I, IÍ1B  +  I,> 9W, I7@ P+  M,> 9Ò, I:,> 9V, I:@p P+  N,> Ð, I:,> Q, H$@r 9,~   }HQ6` 9+  Ó     @ 97@ 9+  ä, IÍ B e1"   +  Ù0b  -+  Ù  e."   B e+  Ý  e1$  °+  Ý0d  =+  Ý  e/&   F e, IÍ3B e+  á,> 9W, I,> e, I:+  â,> 9W, I  9/(   H 9+  Ó,~   ~`e7@ KÚ+  ç@j 9+  o6@ 9+  é ,   L 9, IÍ. 9A"  ¿ B ï,> 9W, I,> ï, I:,> 9Õ, I@n 9,~   ~`ï7@ KÚ+  r@p 9+  ù6@ 9+  t 2   R 9, IÍ/ 9A"  ¿ B z,> 9W, I,> z, I:,> 9Õ, I@` 9,~   {Xz7@ 9+  ü  9+  }  9%/"  ,>  , Z@d 9,~   , ³,>  ,&,< ?,< ?	,	}, _;@f 9,~   , IÍ,>  ,-,< ?,< ?,	}, _;@h 9,~   \* >,J ,J ,< ,< ,> 9R,> 9Ò, 	³4B ,< 9,< 9
,Q B ,< ,< ,< 9,< 9
,
, _;  0l  ¿+  ,> ,-,< 9,< 9
,
v4B   9 N    P 9, â   R 9+  +  
,< ?ä,< ?e, _;,~   |8     ¥Of 9$@h 9,~   , H0 B <,>  , H¢,>  , Hø, 	&, ³ 
 9¤.*  3b  +  ·, H0 B ¼,>  , H¢,>  , Hø  9¤.,  ,>  , K,> 9Õ, %,> 9Õ, ,> 9Õ, %,> 9Õ, , ³ B »,> ;,> ¼,> 9%,> 9¤, #,> <, Hà,>  , H$,> ¼, H¿+  ¹,> <, Hà,>  , H$,> <, H¿,~      »|(¼, ³ B Þ  9 N Ý@p 9\2 >|,R [,R Ú,< Ú,< [,> 9Ò,> 9R, 	³4B Ø   Ý3` Þ+  Ø  9 B ^  9 D ] & â F 9\( 9
,H \,H ÛZ
 Û4J L>
 Û
 \ J Ü,>  ,> Þ, 	 B _. Þ2b Ý+  V  Ü L 9, â  Þ. _ P ÞZ Û5R Õ\  9
,@ \,@ Û+  J  ^ B 9  ] D 9+  Z,< ?ä,< ?e, _;,~   |_  Ú   ,>  ,> ,>  Z47@ KÛ+  å@f 9Z6 ,z+  }6@ 9+  ç (   H 97@ 9+  }7@ KÚ+  ë@j 9Z6 ,z+  }, Z4B n,> 9W, I+  î+  o+  è, IÍ    0õA 9Ë L þ,> 9W, I7@ KÚ+  õ@n 9Z6 ,z+  }, IÍ     þA@õ R þ(Rw5R ù+  {,> 9W, I+  ò   9/    @ 9+  ç P  / 9È+x ~xþ   ©   à    H                  x   9®}   9´x   x   þx   þx   þ{CDELTOKENF    ,>  ,> ´,>  Z47@ KÛ+  @b 9Z6 ¶,z+  ­6@ 9+   $   D 97@ 9+  )7@ KZ+  @f 9Z6 ¶,z+  ­,> 9Õ, I, Z4B ,> 9W, I+  +  +  , IÍ     õA 9Ë H /,> 9W, I7@ KZ+  @j 9Z6 ¶,z+  ­,> 9Õ, I, IÍ     /A0õ N /(Nw5N ¤+  &,> 9W, I+  ,> 9W, I  9/2   R 9+  , ` B ¯, H¢2B ¯+  ­, 	,> 9Õ, d, 	 P  / 9È+x ~x¯          H 9             ¶      09®­   9´x   x   þx   þx   þ|p¸CDELTOKENB    ,>  ,> W,>  Z46@ 9+  ¾     @ 97@ 9+  Ð,> 9W, 7@ KÚ+  Ã@b 9Z6 Y,z+  Ð, IÍ    õA 9Ë D R7@ KÚ+  I@f 9Z6 Y,z+  Ð,> 9W, I, IÍ    
 RA
 õ J R(Jw5J N+  Î+  F  9/,   L 9+  ¾ P  / 9È+x  R   0   º    H [             Y    0  @9®(Ð   9´x   x   þx   þ|@ÚCMOVTOKENF    ,>  ,> |,>  Z46@ 9+  à .   N 97@ 9+  õ7@ KZ+  ä@p 9Z6 ~,z+  õ,> 9Õ, I, Z5B g+  ç+  á, IÍ    HõA 9Ë R w7@ KZ+  m@` 9Z6 ~,z+  õ,> 9Õ, I, IÍ     wAõ F w(Fw5F r+  ò+  j,> 9W, I  9/(   H 9+  à P  / 9È+x ~xw   Ò   Ü    H              ~       `9®Hõ   9´x   x   þx   þx   þ{P CMOVTOKENB    ,>  ,> ),>  Z47@ KÛ+  @j 9Z6 +,z+  "6@ 9+  	 ,   L 97@ 9+  ",> 9W, 7@ KÚ+  @n 9Z6 +,z+  ", IÍ    @õA 9Ë P £7@ KÚ+  @r 9Z6 +,z+  ", IÍ B $     £Aõ F £(Fw5F +     $1(  °+   
 $0j  =+  ,> 9W, I  $/,  ,>  , I:+  ,> 9W, I+    9/.   N 9+  	 P  / 9È+x  $   ÷       H -             +    $P   89®  "   9´x   x   þx   þ{X¬CTOKENUC ,>  ,> U,>  Z47@ KÛ+  3@p 9Z6 W,z+  N6@ 9+  5 2   R 97@ 9+  N,> 9W, 7@ KÚ+  :@` 9Z6 W,z+  N, IÍ    õA 9Ë D Ï7@ KÚ+  ¿@f 9Z6 W,z+  N, IÍ B P    
 ÏA
 õ J Ï(Jw5J D+  L  P1,   +  Ê  P0n  -+  Ê,> 9W, I  P.0  ,>  , I:+  Ë,> 9W, I+  ¼  9/2   R 9+  5 P  / 9È+x  P   ¤   .    H Y             W    *  %x9®%`N   9´x   x   þx   þzpØCTOKENLC ,>  ,> ,>  Z47@ KÛ+  _@` 9Z6 ,z+  6@ 9+  a "   B 97@ 9+  ,> 9W, 7@ KÚ+  f@d 9Z6 ,z+  , IÍ    õA 9Ë F 7@ KÚ+  ë@h 9Z6 ,z+  , IÍ B  
    A(õ L (Lw5L p+  þ  1.   +  ö  0p  -+  ö,> 9W, I  .2  ,>  , I:+  ~   1   °+  }  0b  =+  },> 9W, I  /$  ,>  , I:+  ~,> 9W, I+  è  9/&   F 9+  a P  / 9È+x     Ð   Z    H                  08  +89®+    9´x   x   þx   þ{`CTOKENTOGGLE  6@ 9+   (   H 97@ 9+  -,> 9W, 7@ KÚ+  @j 9+  -, IÍ B ­    0õA 9Ë L .  ­1.  °+  0n  =+  ,> 9W, I  ­A 9Å,>  , I:+  ,> 9W, I7@ KÚ+  @` 9+  -, IÍ B ­     .Aõ F .(Fw5F £+  +  ­1(   +  ©0h  -+  ©,> 9W, I  ­G,  ,>  , I:+  ª,> 9W, I+    9/0   P 9+  ,~   xX.6@ 9+  ° 2   R 97@ 9+  7,> 8,> 9W, K5B 4+  7,> 9W, I  9/&   F 9+  °@h 9,~      a6@ 9+  º *   J 97@ 9+  @,> A,> 9Õ, K5B >+  @  9/.   N 9+  º@p 9,~      a@r j\  >õ,@ é,@ i6@ j+  ç,< i,< é,> 9Ò,> 9R, 	³5B È@b j+  ÒZ 94D Ê  9
  1$  °+  Ï0d  =+  ÏZ 94F Î  9
  A 9Å+  RZ 94H Ñ  9
      F j7@ j+  æ 
 j0J   +  Ö,< >ó,< >t+  Ý  j0L  ©+  Ù,< >r,< >ò+  Ý  j0N  (+  Ü,< >p,< >ð+  Ý,> j,,< i,< é,	}, _;,> 9Õ, d  j1P   +  e  j1R  (+  e   j0@  ©+  f+  ç+  æ@b j, i¼+  Ã  j+  è,~   {@j  i   `@d \& >ê,F ,F 6@ +  ,< ,< ,> 9Ò,> 9R, 	³5B ò@h +  üZ
 94J ô 
 9

  1*  °+  ù0j  =+  ùZ 94L ø  9
  A 9Å+  |Z 94N û  9
      L 7@ +    0P   +  ,< >ó,< >t+    0R  (+  ,< >p,< >ð+  ,> ,,< ,< ,	}, _;,> 9Õ, d   1@   +    0B  (+  +  +  @d , i¼+  í  +  ,~   yX     k  9 F Â@h 94&  
 Â1j  +  ,> Â,&,< ?,< ?,	}, _;, i¼+  B,> Â, Hà5" ,> Â,&,< ?,< ?,	},< >h,< >è,
, _;, i¼+  B,> Â, Hà B D, H¢2B D+  (,> Â,&,< >e,< >å,	},< >á,< >b,
, _;, i¼+  B, H¢,> Â B D, Hà/ D#   B C1b  (+  0, ë1B  (+  /+  B+  0 ,  ( L C\. ?e,N 9,N 9, H¢,> Â B D, Hà2" D+  9, H¢ B Ã,> Â, Hà,>  , H$,> Â,> Ã, Hø7` C+  À, IÍ,< 9,< 9,>  ,
®,\ 9,\ 9,> 9W, I  C/2   R C+  9,< >Þ,< >_, _;,~   u0D6@ KÛ+  Æ7@ KÚ+  Ç@` 9+  6@ 9$+  Ð " Ä3B 9+  Ð $ *3D 9+  Ð & 3F 9+  Ð,> 9Ó ( Û,>  ,> 9Õ, B 9¡@j 9"@l 9$  91.   .   N 9@p   9¡ R    9" @ , H¢ B 6@ KÚ+  ý7@ 9+  ý6@ KÚ+  {, IÍ B 0B  +  \+  ý, ä4B l6@ +  e  9"1" Ã+  e, Á B 0B  ©+  c@d +  ý+  e  0F   +  e+  ý,> 9W, I,> 9W, I6@ +  ë (  H 9¡ *  J 9¡  9"..   N 9"+  ú6@ KÚ+  ú, ä5B ú, IÍ B 6@ +  õ  9"10 D+  õ, Á B 1B   +  u  0R  ©+  õ+  ý,> 9W, I6@ +  z   @ 9¡  9".&   F 9"+  l+  û+  ý 
 9/*   J 9+  ×  0L   +  
   N   9"/  P 7@ +   ,>  , I:  /&   F +     H 9¡ 
  J 9",< >\,< >Ü, _;+    0L  ©+  7@ 9"+  . 9¡ N 1N  +    1P  +  ,> , I:,> 9Õ, I,> 9¡, rª B 9¡   9"/    @ 9"+  ,< >Z,< >Ú, _;,> , H$, ^´@b 9,~   u`6@ KÛ+  7@ KÚ+   @d 9+  o6@ 9$+  © & Ä3F 9+  © ( *3H 9+  © * 3J 9+  ©,> 9Ó , Û,>  ,> 9Õ, B 9¡@n 9"@p 9$  912   2   R 9@` ï  9¡ B p  ð D ð, H¢ B q6@ KÚ+  Ó7@ 9+  Ó6@ KÚ+  Ñ, IÍ B ñ, ä4B D  ñ1F  +  D6@ ï+  ¼  9"1( Ã+  ¼, Á B ï1B   +  < 
 ï0J  ©+  ¼+  Ó,> 9W, I,> 9W, I6@ ï+  C ,  L 9¡ .  N 9¡  9".2   R 9"+  Ñ+  Q6@ ï+  Ê   9"1  D+  Ê, Á B ï1B   +  J  ï0B  ©+  Ê+  Ó,> 9W, I6@ ï+  O  ñD 9¡  9".(   H 9" 
 ñ0J  +  Q+  Ñ+  ±  9/.   N 9+  °  ï0P   +  `  p R ò   9"/  ð @ s7@ s+  \ ò,>  , I:  s/&   F s+  ×  p H 9¡ 
 ð J 9",< >\,< >Ü, _;+  m  ï0L  ©+  m7@ 9"+  ë. 9¡ N r1N  +  ë  r1P  +  ë,> r, I:,> 9Õ, I,> 9¡, rª B 9¡   9"/    @ 9"+  á,< >Z,< >Ú, _;,> q, H$, ^´@b 9,~   y8s  9 D (@f 94$ w  (1h  +  {,> (,&,< ?,< ?,	}, _;, i¼+  §,> (, Hà5" ,> (,&,< ?,< ?,	},< >h,< >è,
, _;, i¼+  §,> (, Hà B ©, H¢2B ©+  ,> (,&,< >e,< >å,	},< >á,< >b,
, _;, i¼+  §, H¢,> ( B ©, Hà/ ©#   B ¨1b D+   
 ¨/* D,>  ,&,< >V,< >Ö,	},< >R,< >Ò,
, _;+  §,> 9Ó , Û,>  ,> 9Õ, B 9¡@n 9", H¢ B ),> (, Hà B ©, H¢3b ©+  ,> (, Hà,>  , H$7` ¨+  %, IÍB 9¡  9".2   R 9",> 9W, I  ¨/&   F ¨+  ,> ), H$,< >Ï,< >P, _;,~   w8©7@ KÛ+  ,@h 9+  n 
 9 J o@l 94* ¯  o1n  +  ³,> o,&,< ?,< ?,	}, _;, i¼+  n,> o, Hà5" º,> o,&,< ?,< ?,	},< >h,< >è,
, _;, i¼+  n,> o, Hà B q, H¢2B q+  C,> o,&,< >e,< >å,	},< >á,< >b,
, _;, i¼+  n 0 3P 9+  K 2 Ä3R 9+  K   *3@ 9+  K,> 9Ó " Û,>  ,> 9Õ, B 9¡@d 9", H¢,> o B q, Hà/ q#   B ï & D/ 9"3b  +  X, Á B î0B  ©+  Ô ( D/ 9" H ï+  X 
 î0J   +  X,< >M,< >Í, _;+  n, H¢ B p,> o, Hà2" p+  Þ,> o, Hà,>  , H$,> o,> p, Hø7` ï+  æ  9"0, D+  ã, IÍB 9¡  9".0   P 9",> 9W, I   ï/    @ ï+  Þ, H¢3B p+  ì,> o, Hà B ð,> o, H¢,>  , Hø,> ð, H$,< >Ê,< >K, _;,~   }(q,>  ,> ,>  Z4, H¢ B 6@ 9+  ö "   B 97@ 9+    9" D ,> 9Ó & Û,>  ,> 9Õ, B 7@ +    ,>  , I:  /,   L +  û  9/0   P 9+  ö6@ 9'+  ,> , H$,< >H,< >È, _; P  / 9È+x       ñ    H                  q  n09®n   9´x   zCYANK    , H0 B ¿, H0 B @, H0 B À,>  , H¢,>  , Hø, H¢,> 9Ö B B, Hà B A3b B+  ¡, 	 2   R Á,> ¿, H¢,>  , Hø,> A, H$, 	&, 	,> @, H¢,>  , Hø+  ), 	&, 	     @ Á,> @, H¢,>  , Hø,> A, H$, 	,> ¿, H¢,>  , Hø,> ¿, Hà,>  , H$, ä5B ., ¾.ÿ,>  , Z, 	&, 	6@ KÚ+  3, H¢,> @ B B, Hà2b B+  ³+  4+  +6@ 9'+  6  À+  ¹  Á0D  +  ¸  @+  9  ¿   ,>  , Hà,>  , H$,> ¿, H¿,> @, H¿,> À, H¿/ 9J+x ~hB,>  ,> Q,>  Z46@ 9+  Æ (   H 9 
 9$
 9¦ J L, ¾. L,>  , Z@l 9 P  / 9È+x L      Â    H T             S    yP  x@9®x(Ê   9´x   }0ÓCADDINDENT    ,>  ,> æ,>  Z4,> 9Ö, Hà5" \,< >E,< >Å, _;, i¼@n 9+  à6@ 9+  ^ 0   P 9  9$ 9¦,>  , @` 9 P  / 9È+x    Ì   Õ    H é             è    |(  zp9®zXà   9´x    ~PiCINDENTREGION ,>  ,> ù,>  Z46@ 9+  o "   B 9  9$ 9¦ D ô, ¾/ ô,>  , Z@f 9 P  / 9È+x ô   b   k    H ü             û    ~X  }H9®}0s   9´x   }8|CUNINDENT,>  ,>  ,>  Z4,> 9Ö, Hà5"  ,< >E,< >Å, _;, i¼@h 9+   	6@ 9+    *   J 9  9$ 9¦"`  ,>  , @n 9 P  / 9È+x    u   ý    H                    0  p9®X 	   9´} CUNINDENTREGION    @p 9, 	, H¢ B  (, Ö4B  ,> 9W, I+   , 	&,> 9Õ, I, H¢3b  (+   , Ö4B  ,> 9W, I,> 9Õ, I+   ,> 9W, I, H¢/  ( B  ¨5B  "+   §  9%/2     9¤/  9%.   /   ¨( ÿ.   ,>  , Z, 	&,~   }p ¨, H¢ B  :, 	&,> 9Õ, I, H¢3b  :+   °, Ö4B  °,> 9W, I,> 9Õ, I+   «,> 9W, I, ³/ 9¤"  ."   B  º,>  :, H$7`  º+   9,> 9Ñ, I:   º/&   F  º+   5@h 9,~   |( º,>  ,>  ^,>  Z4\* ?e,J  Y,J  ØZ 94L  À  9  4L  Ç,< >C,< >Ã,< 9,< 9,
,< >Á,< >B,
,<  Ø,<  Y,	},\  Y,\  ØZ 94N  É  9  4N  Ð,< >?,< >¿,< 9,< 9,
,< >Á,< >B,
,<  Ø,<  Y,	},\  Y,\  ØZ  Ø5P  U,<  Ø,<  Y,< ><,< >¼,
,\  Y,\  Ø,<  Ø,<  Y, _;@r 9 P  / 9È+x  Y        ;    H  a              `       H9®0 W   9´x   zP àCSHOWSEARCH      Ø   ,< >:,< >º,> 9R,> 9R, 	³5B  i,< >·,< >8, _;@` 9+  !Z 95D  sZ 95F  n,< >´,< >5, _;@h 9+  !+   ò,< >:,< >º,< 9,< 9,
,< ?F,< ?Æ,
, _;+   ô\* 9
,J 9,J 9Ol d§, N5B  w,> 9Õ, d@n d§6@ 9+   ù 0   P 97` 9+  !, H¢ B !,< 9,< 9, ô, H¢2B !+   ÿOr 9+  !   9/    @ 9+   ù6  9+  !,< >:,< >º,< 9,< 9,
,< >²,< >3,
, _;Ob 9!+  !,< >:,< >º,< 9,< 9,
, _;@d 9,~   |!Z 95F !,< >´,< >5, _;@h 9+  !«,< >:,< >º,< 9,< 9,
,< ?F,< ?Æ,
, _;Oj d§, N5B !,> 9Ö, d@l d§6@ 9+  ! .   N 97` 9+  !¡, H¢ B !,,< 9,< 9, ô, H¢2B !,+  !Op 9+  !!  9/2   R 9+  !6  9+  !(,< >:,< >º,< 9,< 9,
,< >²,< >3,
, _;O` 9!+  !+,< >:,< >º,< 9,< 9,
, _;@b 9,~   zx!,,< >¯,< >0,> 9R,> 9R, 	³5B !2,< >,,< >¬, _;@d 9+  !ÔZ 95F !<Z 95H !7,< >´,< >5, _;@j 9+  !Ô+  !»,< >¯,< >0,< 9,< 9,
,< ?F,< ?Æ,
, _;+  !½\, 9
,L 9,L 9On d§, N5B !@,> 9Õ, d@p d§6@ 9+  !Â 2   R 97` 9+  !Ê, H¢ B !U,< 9,< 9, 4, H¢2B !U+  !ÈO` 9+  !J  9/"   B 9+  !Â6  9+  !Q,< >¯,< >0,< 9,< 9,
,< >²,< >3,
, _;Od 9!+  !T,< >¯,< >0,< 9,< 9,
, _;@f 9,~   |!UZ 95H !Y,< >´,< >5, _;@j 9+  !ô,< >¯,< >0,< 9,< 9,
,< ?F,< ?Æ,
, _;Ol d§, N5B !`,> 9Õ, d@n d§6@ 9+  !â 0   P 97` 9+  !ê, H¢ B !u,< 9,< 9, 4, H¢2B !u+  !èOr 9+  !j   9/    @ 9+  !â6  9+  !q,< >¯,< >0,< 9,< 9,
,< >²,< >3,
, _;Ob 9!+  !t,< >¯,< >0,< 9,< 9,
, _;@d 9,~   z8!u,>  ,> "',>  Z4,< >*,< >ª, 
K5B !},< >',< >§, _;@f 9Z6 "),z+  " Z 95H "Z
 95J ",< >$,< >¤, _;@l 9Z6 "),z+  " +  ",< >*,< >ª,< 9,< 9,
,< ?F,< ?Æ,
, _;+  "\. 9
,N 9,N 9Op d§, N5B ",> 9Õ, d@r d§6@ 9+  "     @ 97` 9+  ", H¢ B "",< 9,< 9, r, H¢2B ""+  "Ob 9+  "  9/$   D 9+  "6  9+  ",< >*,< >ª,< 9,< 9,
,< >²,< >3,
, _;Of 9!+  " ,< >*,< >ª,< 9,< 9,
, _;@h 9 P  / 9È+x ""    Ù   !õ    H "*             ")    $0  p9®X"    9´x   wH"©CMSEARCH ,>  ,> "õ,>  Z4,< >",< >¢,> 9R,> 9R, 	³5B "³,< >,< > , _;@j 9Z6 "÷,z+  "lZ 95L "8,< >,< > , _;@n 9Z6 "÷,z+  "l\0 9
,P "n,P "í,< >",< >¢,< "í,< "n,
,< >,< >,
,> 9R,> 9R, 	³5B "C,< >,< > , _;@r 9Z6 "÷,z+  "l\  9
,@ "o,@ "îOb d§, N5B "G,> 9Õ, d@d d§@f "ð6@ 9+  "J  9T H 97` 9+  "a, H¢ B "p,< "í,< "n, ô, H¢2B "p+  "P@j 9+  "à ,   L "ïZ "í2l  +  "Ô,> 9Õ, I  "ï9 "Ð 0   P "ïZ "î2p  +  "Ý,< "î,< "o,> 9W,>  ,
ÒZwÿ4D "[p  / 9J,>  , I:  "ï9 "U  "ð.&   F "ð  9/(   H 9+  "J,< >",< >¢,< "í,< "n,
,< >,< >,
,< "î,< "o,
,< >,< >,
,> "ð,&,
,< >,< >,
, _;@j 9 P  / 9È+x "ð   "¢   "+    H "y             "÷    .  %H9®%0"l   9´x   x   þuX"øCCHANGESTRING   "í    c,< >,< >,> 9R,> 9R, 	³5B #,< >,< >, _;@l 9+  #KZ 95N #,< >,< >, _;@p 9+  #K\2 9
,R 9,R 9,< >,< >,< 9,< 9,
,< >,< >,
,> 9R,> 9R, 	³5B #,< >,< >, _;@` 9+  #K\" 9
,B 9,B 9Od d§, N5B #,> 9Õ, d@f d§@h #N6@ 9+  # 
 9T J 97` 9+  #Ä, H¢ B #M,< 9,< 9, ô, H¢2B #M+  #Ol 9+  #D,< >,< >,< 9,< 9,
,< >,< >,
,< 9,< 9,
,\ #L,\ #Ë,< #Ë,< #L,< >,< >,
, _;, Ó B #Í    8õA 9M4N #»,< #Ë,< #L,< >,< >,
, _;  #N.2   R #N $   D #ÌZ 92d  +  #1,> 9Õ, I  #Ì9 #- (   H #ÌZ
 92h  +  #:,< 9,< 9,> 9W,>  ,
ÒZwÿ4L #·p  / 9J,>  , I:  #Ì9 #±,> 9Ö, d+  #¿,< #Ë,< #L,< >,< >,
, _;,> 9Ö, d  #Í 8õA 9Ì4N #Â@p 9+  #D   9/    @ 9+  #,< #Ë,< #L,< >,< >,
,> #N,&,
,< >,< >,
, _;@b 9,~   w#N  #Ë   "{Z 95D #Ó,< >,< >, _;, i¼@f 9+  $Oh d§,< >,< >,< 9,< 9,
,< >,< >,
,< 9,< 9,
, _;, N5B #\,> 9Õ, d@j d§@l $6@ 9+  #_  9T N 97` 9+  $, H¢ B $,< 9,< 9, ô, H¢2B $+  #eOp 9+  $,< >,< >,< 9,< 9,
,< >,< >,
,< 9,< 9,
,\ $,\ $,< $,< $,< >,< >,
, _;, Ó B $    HõA 9M4R $,< $,< $,< >,< >,
, _;  $.&   F $ (   H $Z
 92h  +  #ú,> 9Õ, I  $9 #ö ,   L $Z 92l  +  $,< 9,< 9,> 9W,>  ,
ÒZwÿ4P $p  / 9J,>  , I:  $9 #{,> 9Ö, d+  $	,< $,< $,< >,< >,
, _;,> 9Ö, d  $ HõA 9Ì4R $@` 9+  $  9/&   F 9+  #_,< $,< $,< >,< >,
,> $,&,
,< >,< >,
, _;@h 9,~   { $  $   #O 
 9A*  ¿0J  +  $ ,   L $À .   N $AOp $Á+  $¥  9A2  ¿0R  +  $£     @ $À "   B $A $   D $Á+  $¥,< >,< >, _;+  $¿6@ 9+  $( &   F $B+  $)  9 H $B@j 9, H¢ B $@,> $Á, I  $Á0L  +  $®7@ KÚ+  $®+  $», IÍ B $Â2B $A+  $²  $B/.   N $B+  $µ  $Â2P $À+  $µ  $B.2   R $B6@ $B+  $7+  $»   $Á2@ 9Õ+  $:7@ KZ+  $:+  $»,> $Á, I+  $«7@ $B+  $¿,> $@, H$,< >,< >, _;Ob 9!,~   |0$Â, H¢ B $àOd $`, ±4B $Ë6@ KÚ+  $È, Z4B $È, 	+  $Å6@ KÚ+  $J, 	, H¢ B $`+  $Ý@f $aOh $á, 	6@ KZ+  $Û, IÍ0B  +  $R, H¢."   B $`+  $Û+  $Ú, ä4B $Ø7@ $a+  $V 
 $á J $`+  $Û+  $XOn $a, H¢."   B $á+  $Ú, Ö5B $Ú@p $aOr $á, 	+  $M   $`1    !     @ $`,> $à, H$  $`+  $ß,~   |0$á, H¢ B $ÿ, ±4B $g6@ KÚ+  $g, Z4B $g, 	+  $d7@ KÚ+  $é, H¢ B $+  $ü@b % Od %6@ KÚ+  $ú, IÍ0B  +  $ñ7@ % +  $o  %+  $p, H¢    F $+  $ú+  $ù, ä4B $÷7@ % +  $õ  % H $+  $ú+  $wOl % , H¢ B %+  $ù, Ö5B $ù@n % Op %, 	+  $ê7@ KÚ+  $ü, H¢ B $,> $ÿ, H$  $+  $þ,~   v8%  912   2   R 97@ 9+  %, ±5B %, 	, ±4B %, $C+  %, $b,>  , H$  9/&   F 9+  %,~     91(   (   H 97@ 9+  %, ±5B %, 	, ±4B %, 	6@ KZ+  %, Z4B %, 	+  %, 	&+  %, $C,>  , H$  9/,   L 9+  %,~     9%1.   .   N %Ï7@ 9¨+  %! 0   P %P7@ 9+  %  9+  %   9¤ R %Ð+  %$   91        @ %P  9¤ B %Ð  %Ï3d %Ð+  %®, i¼,> %Ï,&,< >,< >,	},< =ü,< =},
,> %Ð,&,
,< ={,< =û,
, _;@f 9+  %L, H0 B %O7@ %P+  %Ê7@ÿ+  %², $C+  %3, H¢ B %Í,> %O, $b,>  , Hø,> %Í, H$7@ÿ+  %Á, ¾ B %Î, , ¾/ %Î"B %Î,> %Í, H$,> 9W,> %O, J 
 %Ï.
 %Î1*   *   J %N/*  ,>  , Z+  %Â, ³ B %N,> %M,> %O,> %Ï,> %Ð, #,> 9Õ,> 9Õ, p6@ 9¨+  %H, 	Onÿ  %P/2   R %P+  %¯,> %O, H¿@` 9/ 9J+x    %Nx%Ð,> 9Õ, %,~   ,> 9Ö, %,~   7` 9+  %V  9+  %Ö, ³ B 9%,>  ,&,< =ø,< =y,	}, _;@d 9,~   7` 9+  %]  9+  %^, ³    F 9¤,>  ,&,< =v,< =ö,	}, _;@h 9,~   Ol d§,< ?ä,< ?e, _;,> 9Ö, d,> 9Ö, g¢@n d§, 2,~   7@ 9+  %j  9+  %ê  9%,>  , K@r 9,~   ,< =t,< =ô,> 9R,> 9Ò, 	³5B %r,< =r,< =ò, _;@` 9+  &,< 9,< 9
, 7V B &5b &" &   0$   0$  +  &+&,< =t,< =ô,< 9,< 9
,
,< =ï,< =p,
, _;+  &,< =t,< =ô,< 9,< 9
,
,< =m,< =í,
, _;+  &5 %÷5 %ü,É+  &  9 F &Z &*    F &,> &, 87,< =t,< =ô,	},< =ë,< =l,
,> 9,&,
,< =é,< =j,
,> &,&,
, _;@j 9,~   |(&@l 9,< =t,< =ô,> 9Ò,> 9R, 	³5B &,< =r,< =ò, _;+  &.,< 9,< 9
, 7V B &®5b &§" &®0.   0.  +  &¦+8&¥,< =t,< =ô,< 9,< 9
,
,< =ï,< =p,
, _;+  &',< =t,< =ô,< 9,< 9
,
,< =m,< =í,
, _;+  &'5 &5 & ,É+  &.,> &®, 87,< =t,< =ô,	},< =ë,< =l,
Z &®,>@  ,&,
, _;,~   |P&®,>  ,> &Ï,>  Z4,> 9W,> &É, B &J7R  ,I7D 9,I   DH 7F  ,I7H 9,I7J  ,I 
(  J 7L 9,I7N0 ,I    P8 7R 9,I  &J DH 7F &J,I  &J H &Ê,>  @@ &ÊZF &Ê, ¶A"ÿG 9E 
 &Ê B(   &JZ6 &Ò,z+  &H 6 &Ò,z P  / 9È+x    U~x&Ê   "q   &/    H &T             &Ñ    i8  f9®ep&H   9´H &Êx    H &Jx   |8&ÓCNEWNAMEMACRO ,>  ,> &v,>  Z4,> 9W,> &p, B &ð7L  ,I7N 9,I 8  N0 7P  ,I7R 9,I7DH ,I   D@ 7F 9,I7H ,I 
   J  7L 9,I  &ð N0 7P &ð,I  &ð R &q,>  @@ &qZP &q, ¶A"ÿG 9E  &q B   &ðZ6 &y,z+  &î 6 &y,z P  / 9È+x    U~x&q   &K   &Õ    H &ú             &x    n   jp9®jX&î   9´H &qx    H &ðx   xh&zCNEWSTACKMACRO@f 9\( =ç,H '´,H '4,< '4,< '´,> 9R,> 9Ò, 	³5B ',< =r,< =ò, _;+  '³,< 9,< 9
, 6û B '55b '"
 '50*   0*  +  '+(',< '4,< '´,< 9,< 9
,
,< =ï,< =p,
, _;+  ',< '4,< '´,< 9,< 9
,
,< =m,< =í,
, _;+  '5
 '5
 ',É+  '³On d§,> '5, 7þ,< '4,< '´,	},< =e,< =å,
,\ '´,\ '4,< '4,< '´, _;, è B 'µ@p d§  '5(Rw0R  +  '­, &Õ B '6,> '5, 8 B '¶7D '6,I\' 7H  ,I\+  ,J  ,Jÿ7L '6,I\/0 7P  ,I\3@ ,R8  ,R?ÿ7D '6,I  'µ  þ F 7H '6,I    H '5 
 'µ  '5 L( þ,> 'µ, »,< '4,< '´,	},< =ã,< =d,
, _;,~   {0'¶  '4   $,< =b,< =â, _;Op d§, è B 'Ý@r d§     þ D '],>  , 7þ,\ 'Ü,\ '\Z '\4F 'A  'Ü  5F 'Æ,> 'Ý, »,< =à,< =a,	},< =^,< =Þ,
, _;+  '[  '](Hw1H  +  'O,> 'Ý, »,< =à,< =a,	},< =Ü,< =],
,< '\,< 'Ü,
, _;+  '[,> 'Ý, »,< =à,< =a,	},< =Ü,< =],
,< '\,< 'Ü,
,< =[,< =Û,
,> '], 87J  ,I\-( ,<7ÿ,<0  , v,
, _;@n 9,~   y@'Ý  '\   '·  900  +  'â   9.    @ 9+  'æOf 9!,< =V,< =Ö, _;, i¼Z6 (,z+  (  9 HP @j 95h 'é ,   LP @n 9!,>W, 8 BP 7@P +  'ÿZ 9 PP 7RP ,I\%H ,<ÿ,<  ,< 9,< 9,
,\ 9,\ 9Z 93fP +  'ý, è BP ,>  , ¹7@ 9!+  '}Z 9/P .(  Z
 9,< 9,< 9,>  ,>  ,
Ñ,\ 9,\ 9+  'ÿ+  'ò P /.   NP +  'ë  9/2   R 9@` 9 6 (,z P  / 9Ä+x ,>  ,> (,>  ,> 9Ö,> 9Ö,> 9Ö,> 9ÖZ4}+  '_   &ñ   (    H (             (  (   X9®{p(   9´ 
   HP x   x    x    x    {P(CMACRODISPATCH,< =S,< =Ó,> 9R,> 9Ò, 	³5B (,< =r,< =ò, _;@b 9+  (5,< 9,< 9
, 6û B (µ5b («" (µ0$   0$  +  (©+(¨,< =S,< =Ó,< 9,< 9
,
,< =ï,< =p,
, _;+  (*,< =S,< =Ó,< 9,< 9
,
,< =m,< =í,
, _;+  (*5 (5 (£,ÉOh 9!@j 9+  (5,> (µ, 7þ,< =S,< =Ó,	},< ?F,< ?Æ,
, _;,> 9Õ, d  (µ(Lw0L  +  (´,> (µ, (+  (5, (µ,~   |H(µ@n 9Op 9 \2 ?e,R 9,R 9,< =M,< =Í, _;,~   ,>  ,> (×,>  Z4@` 9\" =K,B (R,B (Ñ,< (Ñ,< (R, _;, Ó B (Ò,< (Ñ,< (R,< =I,< =É,
,>  ,
®,< =Ç,< =H,
,\ (R,\ (Ñ,< (Ñ,< (R,>  ,>  , 
5B (M,< =r,< =ò, _;Z6 (Ù,z+  (P\$ 9
,D 9,D 9,< ?ä,< ?e, _; P  / 9È+x (Ò   (   (º    H (Ú             (Ù    
8  @9®((P   9´x   {(ZCREADMACRO      (Ñ   'Þ@f 9Z 95H (à,< =D,< =Ä, _;+  ),< =A,< =Á, _;Ol d§, è B )@n d§,>  , »,< =A,< =Á,	},< =¿,< =@,
, _;, &Õ B )7P  ,I\3@ \  ?e,@H  ,@Oÿ7D  ,I\' \( 9,H  ,Hÿ7J  ,I  ) 0 þ L(   )7P  ,I @  P8 þ,< ?ä,< ?e, _;Z KÉ,< KÉ,< KJ,> 9W,>  ,
ÒZwÿ4D (úp  / 9J1D  +  ) ,< KÉ,< KJ,< =>,< =¾,
,\ KJ,\ KÉ, ^g+  ),~   |()@f 9,< ?Ì,< ?M, _;Oj d§, è B )    0 þ L ) @n d§(Lw0L  +  ),> ) , 8 B )   )7R  ,I H  R@ þ7D  ,I   D )!7F  ,I   F )¡7H  ,I F  7J )¡,I D( ,> ), »,< ?Ì,< ?M,	},< =¼,< ==,
, _;+  ),> ), »,< ?Ì,< ?M,	},< =·,< =8,
, _;On 9!, i¼+  ),~   |)¡@p 9Z 95R )¥,< =D,< =Ä, _;+  )À,< =´,< =5,> 9R,> 9Ò, 	³5B )ª,< =r,< =ò, _;+  )À, &/ B )A7D  ,I\' \( 9
,H  ,Hÿ7J  ,I\-( \. 9,N0  ,N7ÿ,< =2,< =²,< 9,< 9
,
,< =0,< =°,
, _;Z KÉ,< KÉ,< KJ,> 9W,>  ,
ÒZwÿ4R )ºp  / 9J1R  +  )@,< KÉ,< KJ,< =>,< =¾,
,\ KJ,\ KÉ, ^g+  )À,~   zX)A@` 9\" =.,B )ì,B )l,< )l,< )ì,> 9R,> 9Ò, 	³5B )È,< =r,< =ò, _;+  )ë,< 9,< 9
, 6û B )î4b )Í  )î(Dw1D  +  )Í@f )î6` )î+  )^" )î0(   0(  +  )\+ )[,< )l,< )ì,< 9,< 9
,
,< =ï,< =p,
, _;+  )Ü,< )l,< )ì,< 9,< 9
,
,< =m,< =í,
, _;+  )Ü5 )Q5 )V,ÉOl 9!, i¼+  )k,> )î, 7þ,< =«,< =,,	},< =),< =©,
, _;,> )î, 8 B )m7N  ,I 8  N )n7P  ,I @  P )í7R  ,I PH 7D )í,I N +  )ë,~   zp)î  )l   (Ü  9 FP @h 95f )s *   JP Z 95L )÷,< =D,< =Ä, _;Op 9!Z6 *,z+  *Z 9 RP @` 9!7`P +  *,< 9,< 9,< 9,< 9,
,\ 9,\ 9Z 93dP +  *, è BP ,>  , ¹7@ 9!+  *Z 9/P .&  Z 9,< 9,< 9,>  ,>  ,
Ñ,\ 9,\ 9+  *+  )ý P /,   LP +  )y@n 9 P  / 9D+x ,>  ,> *,>  ,> 9Ö,> 9Ö,> 9ÖZ4ý+  )p   (S   *    H *             *    "  !`9® *   9´x   x    }x*CEXECLASTMACRO@p 9  9A2  ¿ R *),< =%,< =¥,>  ,
®, _;, Ó B *©3B *)+  *'  *© & m2F þ+  *£, Ó+  *¦  *© * û2J  þ+  *¦, û+  *'+  *,< ?ä,< ?e, _;,~   ~ *©,>  ,> *?,>  Z4Ol d§,< =#,< =£, _;, Ó B *:@n d§,>  , »,< =#,< =£,	},< =[,< =Û,
 P ,<Gÿ,<@  ,
, _;  *:Z6 *Á,z+  *8/ 9J P  / 9È+x *:   *   **    H *Â
            *Á  *A'0  %89®% *8   9´    x   ~h*BGETCHAR   ,>  ,> *Q,>  Z4,< = ,< =!, ** B *L     *L õG 9P DHõ@f 9 P  / 9È+x *L   *º   *Ã    H *T             *S    )P  (P9®(8*Ê   9´x   ~h*ÓCSETNUM  ,>  ,> *â,>  Z4,< =,< =, ** B *Ý    
 *Ý 
(õF
 9P J õ@l 9 P  / 9È+x *Ý   *Ì   *U    H *å             *ä    +h  *h9®*P*\   9´x   ~h*eCCLEARNUM,>  ,> *t,>  Z4,< =,< =, ** B *o     *o @õG 9Ï P8õ@r 9 P  / 9È+x *o   *^   *æ    H *w             *v    .   - 9®,h*í   9´x   ~h*öCSETTOKEN,>  ,> +,>  Z4,< =,< =, ** B +     + õF 9Ï Fõ@h 9 P  / 9È+x +   *ï   *x    H +             +    0  /9®/ *   9´x   ~`+CCLEARTOKEN   ,>  ,> +,>  Z4,< =,< =, ** B + 
    + 0õG 9Í L(õ@n 9 P  / 9È+x +   +   +
    H +             +    28  189®1 +   9´x   ~h+CSETDELIM,>  ,> +),>  Z4,< =,< =, ** B +$     +$ HõF 9Í R@õ@` 9 P  / 9È+x +$   +   +    H +,             ++    4P  3P9®38+¢   9´x   ~`+«CCLEARDELIM   ,>  ,> +;,>  Z4,< =,< =, ** B +6     +6 õG 9L Fõ@h 9 P  / 9È+x +6   +¤   +­    H +>             +=    6p  5p9®5X+´   9´x   ~`+½CSETSPECIAL   ,>  ,> +M,>  Z4,< =,< =, ** B +H 
    +H 0õF 9L L(õ@n 9 P  / 9È+x +H   +¶   +¿    H +P             +O    9  89®7x+Æ   9´x   {`+ÏCCLEARSPECIAL @p 9,< =
,< =,> 9R,> 9Ò, 	³5B +W,< =r,< =ò, _;+  +ñ,< 9,< 9
,< =,< =,
v4B +\\2 9,R +ò,R +r+  +ë,< 9,< 9
,< =,< =,
v4B +a, ¦,\ +ò,\ +r+  +ë,< 9,< 9
,< =,< =,
v4B +f, F,\ +ò,\ +r+  +ë,< =
,< =,< 9,< 9
,
,< =ï,< =p,
, _;, i¼+  +ñZ +r4D +pZ +r4F +î> +r +ò,>  , I:+  +ë,< ?ä,< ?e, _;,~   |8+ò  +r   )ï,>  ,> ,,>  Z4  9A(  ¿ H ,,< =,< =,>  ,
®, _;\* ?e,J ,,J ,, Ó B ,3B ,+  ,  , . û2N0 þ+  ,\0 ?e,P ,,P ,, û+  ,+  ,  ,   m2@H þ+  ,, Ó,< ,,< ,,>  ,
®,\ ,,\ ,+  ,,< ,,< ,,> ,,
®,\ ,,\ ,+  +û,< ,,< ,, _;@b 9 P  / 9È+x ,   +È   +t    H ,             ,    B   >X9®>@,   9´x   ~ ,CMSGTEXT   ,   +ó,>  ,> ,',>  Z4, ¦,< <,< <ÿ,
, F,
, _;@d 9 P  / 9È+x    ,   ,    H ,©             ,)    D0  CH9®C0,!   9´u8,)CDATETIMEMSG  @f 9, A_5B ,®,< <|,< <ü, _;+  ,2, B,< ?ä,< ?e,< <z,< <ú, FÍ, ^g,~   @h 9 
 d 2J d +  ,¶,< <ó,< <t, _;+  ,:, F54B ,¸, Ei+  ,:,< <o,< <ï, _;, ^g,~   @l 9\. <m,N ,þ,N ,~, A_5B ,À,< <|,< <ü, _;, i¼+  ,ü,< ,~,< ,þ,> 9Ò,> 9R, 	³5B ,E\0 ?e,P 9
,P 9Z 94R ,G  9
  5R ,K,< ,~,< ,þ,< <ê,< <k,
, _;+  ,ü,< 9,< 9
, UU B -4B ,]  -0$   0$  +  ,Û+,Z,< ,~,< ,þ,< 9,< 9
,
,< <h,< <è,
, _;+  ,\,< ,~,< ,þ,< 9,< 9
,
,< <å,< <f,
, _;+  ,\5 ,\5 ,U5 ,P,É, i¼+  ,ü,< 9,< 9
,> ,ý,> ,ý,> ,ý,> ,ý,> ,ý,> ,}, Mè,< 9,< 9
, P|,\ ,ÿ,\ ,,< ,,< ,ÿ,< - ,< -,
,< ,~,< ,þ,	},\ ,þ,\ ,~,< ,~,< ,þ,< <ã,< <d,
, _;Of d§,> 9Õ, d, B,< ,,< ,ÿ,< ?ä,< ?e, FÍ,< ,,< ,ÿ,> 9Õ,> 9Õ,> 9Õ, Sí4B ,÷,< ,~,< ,þ,< <a,< <á,
, _;+  ,ú,< ,~,< ,þ,< <_,< <ß,
, _;@h KX@j d§, ^g, ^´,~      -   -zH-   ,~   ,7@ KÛ+  -@l 9+  -­@n 9\0 <],P -®,P -.,< -.,< -®,> 9Ò,> 9R, 	³5B -\2 ?e,R 9
,R 9Z 94D -  9
  5D -,< -.,< -®,< <ê,< <k,
, _;+  -­,< 9,< 9
, P|,\ -¯,\ -/Z -/4F -  -¯  5F -,< -.,< -®,< 9,< 9
,
,< <h,< <è,
, _;, i¼+  -­,< -.,< -®,< -/,< -¯,
,\ -®,\ -.,< -.,< -®,< <ã,< <d,
, _;Oh d§,> 9Õ, d,< -/,< -¯, SE4B -*,< -.,< -®,< <a,< <á,
, _;+  --,< -.,< -®,< <_,< <ß,
, _;@j d§,~   xx-¯  -.   -,>  ,> -o,>  Z4@l 9,< <Z,< <Ú,< KÊ,< KK,
,< <Ø,< <Y,
,\ -i,\ -è,< -è,< -i,> 9Ò,> 9R, 	³5B -@,< -è,< -i,< <ê,< <k,
, _;Z6 -q,z+  -gZ 94N -B  9
  4N -W,< 9,< 9
, P|,\ -j,\ -éZ -é4P -G  -j  5P -N,< -è,< -i,< 9,< 9
,
,< <h,< <è,
, _;, i¼Z6 -q,z+  -g,< -è,< -i,< -é,< -j,
,\ -i,\ -è,< -è,< -i, _;,< -è,< -i,< =[,< =Û,
,\ -i,\ -è+  -Ø\2 KK,R -j,R -é,< -è,< -i,< <Ö,< <W,
, _;O` d§,> 9Õ, d,< -é,< -j, U74B -c,< -è,< -i,< <Ô,< <U,
, _;@b K[+  -f,< -è,< -i,< <Ò,< <S,
, _;@d d§, ^´ P  / 9È+x -j   ,¢   -1    H -r             -q    ]0  V(9®V-g   9´x   }-ñCWRITEFILE      -è   -°@f 9Oh d§, J©5B -ú,< <Ï,< <P, _;,> 9Õ, d,> 9Ö, JS+  .\* <Ì,J .,J .	, J½1b  +  .,< .	,< .,< <Ê,< <K,
,\ .,\ .	,< .	,< .,< <I,< <É,
, _;,> 9Õ, d@l d§,> 9Õ, JS5B .+  ., MÄOn 9,~   {x.  .	   -tOp Y, -ô@r 9,~   @` 9Ob .«, J©4B .#\$ <Ç,D .+,D .ª, J½1b  +  .,< .ª,< .+,< <Ê,< <K,
,\ .+,\ .ª,< .ª,< .+,< <D,< <Ä,
,\ .+,\ .ª,< .ª,< .+,  B .«5B .,< .ª,< .+,< <Â,< <C,
,\ .+,\ .ª+  .#,< .ª,< .+,< <A,< <Á,
,\ .+,\ .ª,< .ª,< .+, _;Of d§,> 9Õ, d6@ .«+  .(@h d§+  .*,> 9Ö, JS, MÄOj 9,~   ~0.«  .ª   .@l K[, B, ^´@n 9,~   \0 <?,P .¹,P .9,< .9,< .¹, _;@r 9O` d§,> 9Õ, d@b d§, B,< .9,< .¹,< <<,< <¼,
, _;,~   ~(.¹  .9   .¬\$ <?,D .H,D .Ç7@ K]+  .Å@f 9,< .Ç,< .H, _;Oh d§,> 9Õ, d@j d§, E®,< .Ç,< .H,< <¹,< <:,
, _;+  .G,< <µ,< <6, _;,~   wx.H  .Ç   .º6@ 9+  .L ,   L 9+  .Ï, F5A"ÿ2b 9  91"   "   B 97@ 9+  .Ó,> 9W, F  9/0   P 9+  .Ï, ^g,~   6@ 9+  .W 2   R 9+  .Ú, F5(Bw2b 9  91"   "   B 97@ 9+  .Þ,> 9Õ, F  9/&   F 9+  .Ú, ^g,~   ,>  ,> /,>  Z4@h 9\* <³,J /,J /	,< /	,< /,> 9Ò,> 9R, 	³5B .h\, ?e,L 9
,L 9Z 94N .j  9
  5N .ï, i¼,< /	,< /,< <1,< <±,
, _;Z6 /,z+  /,< 9,< 9
, P|,\ /,\ /
Z /
4P .t  /  5P .ú,< /	,< /,< 9,< 9
,
,< <h,< <è,
, _;Z6 /,z+  /\2 9
,R /,R /,< /
,< /, 8b4B /,< /	,< /,< /,< /,
,< <a,< <á,
, _;+  /,< /	,< /,< /,< /,
,< <_,< <ß,
, _; P  / 9È+x /   -ê   .ß    H /             /    qH  l9®kx/   9´x   }`/CCMDFILE   /	   .I,>  ,> /+,>  Z4@` 9,< <-,< <­, _;Ob d§,> 9Õ, d@d d§@@ /¥S"  @   	  O@ /¥6@ /¥+  /£ B /&\ /&U$   &  	fÑO@ /¥6@ /¥+  /£
<  , 2 P  / 9È+x /&   /   /    H /®             /-    tp  rp9®rX/$   9´x   x /-{@/.CPUSHFRAME    ,>  ,> /[,>  Z4@f 9\( <ª,H /V,H /Õ,< /Õ,< /V,> 9Ò,> 9R, 	³5B /<,< /Õ,< /V,< <ê,< <k,
, _;@j 9Z6 /],z+  /Ï,< 9,< 9
,> /R,> /Ñ,> /Q,> /R,> /R,> /R, Mè5B /Ç,< /Õ,< /V,< 9,< 9
,
,< <h,< <è,
, _;@l 9Z6 /],z+  /Ï,< /Ô,< /U,Î,>  ,< /Ò,< /S,Î,>  , E\,< /Õ,< /V,< <a,< <á,
, _;, ^g P  / 9È+x    /S   /U   /T/V   /¦   /0    H /^             /]    zp  v9®v /Ï   9´x   t /ÝCRECOVERCHECKPOINTFILE     /Ò   /@n 97  KÛ+  /d 0   P KÛ, ^g,~   @r 97  KÛ+  /ç@` KÛ+  /i,< <',< <§, _;, ^g,~   @b 9§Z KÉ,< KÉ,< KJ,> 9W,>  ,
ÒZwÿ4F /op  / 9J0F  +  /ò\( <¥,H KJ,H KÉ+  /t\* <£,J KJ,J KÉ, ^g@l 9,~   Op 9§Z KÉ,< KÉ,< KJ,> 9W,>  ,
ÒZwÿ4D /úp  / 9J0D  +  /~\& <",F KJ,F KÉ+  /ÿ\( < ,H KJ,H KÉ, ^g@j 9,~   @l 97@ 9ª+  0@n 9ª+  0 0   P 9ª, ^g,~   @r 9, c<, ^´,~   @` 9, c¡,~   ,> 9Õ, d, cæ, ^´@b 9,~   , cV@d 9,~   @f 9,< <,< <,> 9R,> 9R, 	³5B 0,< =r,< =ò, _;+  0\( 9
,H d,H d,~   ,>  ,> 0Ä,>  Z4 
P ,</ÿ,<(  , QÊ5B 0 ,< <,< < P ,<7ÿ,<0  ,
,< <,< <,
, _;Z6 0G,z+  0<  pj N 0¿@p pj\2 ?e,R 0¾,R 0>, RD B 0?1"  +  0¨,< 0>,< 0¾,> 0?,
®,\ 0¾,\ 0>+  0#,< 0>,< 0¾, a£   0?1@  +  0¬6` 0?+  0-+  00  0?0B  +  0¯, RD B 0?+  0¡7` 0?+  07,< <,< <, _;, Ó B 0?    õA 9Ã4D 06+  0º, `k+  0:,< <,< <, _;, Ó B 0?+  0º+  0¡  0¿ F pj, Rb/ 9J P  / 9È+x ~x0¿   /Ö   0    H 0I            0G  0Æ  h9®P0<   9´    x   x   þx   þzP0ÈSHOWFILEINBOX    0>   /a@h 9,> 9Õ, `ÛOj d§6@ 9+  0î, `k,< <,< <, a£,< ?ä,< ?e, a£,< <,< <, a£,< <,< <, a£,< ?ä,< ?e, a£,< < ,< <, a£,< ?ä,< ?e, a£, K,< <,< <, _;, Ó B 0u    0õA 9Ã5L 0n, `k,> 9C,< ;~,< ;þ, {k B 0õ(Bw,>  ,-,< ;ü,< ;},	},< ;{,< ;û,
  0õA.ÿ,>  ,-,
,< >,< >,
,\ 0ô,\ 0t,< ;y,< ;ù,< 0t,< 0ô,
, 0+  0ð,< ;u,< ;õ, _;, Ó,< ?ä,< ?e, _;@p d§,> 9Ö, `Û,~   ~p0õ  0t   0K\2 ;ñ,R 0ÿ,R 0,< 0,< 0ÿ, _;, Ó B 9#,>  , »,< 0,< 0ÿ,	}, _;@` 9,~   zP0ÿ  0   0ö,>  ,> 1°,>  Z4\" ;ï,B 1«,B 1+7@ KÛ+  1,< 1+,< 1«,< ;m,< ;í,
, _;,< ;ê,< ;k, _jZ6 1²,z+  1¨6  9£+  1,< 1+,< 1«,> 9Ò,> 9R, 	³5B 1,< 1+,< 1«,< <ê,< <k,
, _;Z6 1²,z+  1¨\$ 9
,D 9,D 9,> 1ª, rò B 9£+  1,< 1+,< 1«,< 9,< 9,
,< ;h,< ;è,
, _;@f d§,> 1*, t­, ^´7  9£+  1$,< 1+,< 1«,< 9,< 9,
,< ;e,< ;å,
, _;+  1¨,< 1+,< 1«,< 9,< 9,
,< ;b,< ;â,
, _; P  / 9È+x    9£   91«   0@   1    H 1³             1²    H  (9®1¨   9´x   eh13CCREAUX    1+   1   3,>  ,> 3
,>  Z4,> 9É,< ;~,< ;þ, {k,>  ,q,> 9Â,< ;~,< ;þ, {k,>  ,q,
,\ 9,\ 9 (   H 9 *   J 9@l 9@n 9 0   P 9@r 9$@` 9@b 9'@d 9§@f 9@h 9 \* ?e,J 9,J 9\* ?e,J 9,J 9\* ?e,J 9,J 9\* ?e,J 9,J 9\* ?e,J 9,J 9\* ?e,J 9,J 9@j 9¢@l 9" .   N 9 0   P 9% 2  $ R 9¤@` 9¨ "   B 9& $   D 9¦ &   F 9(@h 9 @j 9@l 9@n 9)@p 9* 2   R 9©     @ 9ª "   B 9«Od 9¬@f 9+@h 9-Oj 9,> 9W,> 3, B 97L  ,IZL 3,> 9W,> 3,  3 B8 7P 9,I7R@ ,I  9 DH ,> 9W,> 3, B 97F  ,IZF 3,> 9W,> 3,  3 B  7J 9,I7L( ,I  9 N0 @p 9­ 2   R 9#\  ?e,@ 9,@ 9Ob 9£ $  D  þ & ã F   ( Û H  ÿ *  J   ,  L  . e N    Ó @  $ û D  &  F  ( â H  *   J  ,  L  . 2 N    â @  $ v D  & { F  ( æ H  * m J  , !Õ L  . ! N    8 @  $  D 	 & ? F  ( * H 
 * û J  , ñ L  .  N    û @  $ û D  & û F  ( Ñ H  * û J  , ,>   . â N    ,>   ,> 9Ê,	D "  B > $ ?,>   & û F ¾ ( ¾,>  ,> 9Q,	D * Ü J ¿ , à L À . º N Á 2  R Â    ) @ Ã " ó B J $  D Ë & Ó F Î ( ­ H O * $ J Ò , $ L S . * N Ô 2 4 R Õ   ¸ @ Û " ® B \ $  D Ü &  ; F ] (  H Ý * 0Ë J ^ , Ü L ï L ß . "+ N p N ` 2 à R ð R à   º @ ñ @ á " l B r B b $  D ò D â & Â F s F c ( û H ó H ã * Ä J t J d , !õ L u L e . i N v N f 2 %Q R ö R æ   "û @ w @ g " !¬ B ÷ B ç $  ã D x D h & k F y F i ( X H ù H é * 0 J z J j , ( L ú L ê .  N û N ë 2 Z R í   s @ | " | B } $ .- D ý & ,>   ( û H þ * þ,>  ,> 9Q,	D , . L   . . N  2 -ô R    - @  " ,² B  $ .ß D  & ,+ F  ( 0	 H  * ,; J  , .¯ L  . , N  2 .; R 	   -1 @ 
 " +t B  $ /0 D  & %ì F . ( .Ô H  * & J  , .É L  . '8 N  2 /á R    /e @  " * B ¼ $ 0 D  & 0 F  ( &| H ¯ H  * (º J ° J   , (6 L 1 L ! . 0 N 2 N " 2 +Ñ R 3 R #   (] @ 5 @ % " /j B µ B ¥ $  D 8 D ( & /õ F ¸ F ¨ ( + H : H * * ® J ¹ J © , * L º L ª . · N , 2 Ã R - P  / 9È+x    U 3   1,   16    H 3             3    0`  x9®`3   9´H 3x    x    lh3CINIT       3~fx3        K    x    H ;a    H ;à    H ;`    H ;_    H ;^    H ;Ü    H ;[    H ;Y    H ;×    H ;V    H ;Ô    H ;S    H ;Q    H ;Ï    H ;N    H ;Ì    H ;Ê    H ;H    H ;F    	H ;D    H ;C    H ;Á    
H ;¿    H ;=    H ;<    H ;º    H ;¸    H ;6    H ;3    H ;2    H ;°    H ;¯    H ?    H ;.    H ;¬    H ;«    H ;)    	H ;'    H ;%    H ;£    H ;"    	H ;     H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H ;    H :ÿ    	H :ý    H :|    
H :z    H :y    H :÷    H :õ    H :t    H :ò    H :q    H :î    H :í    H :ì    H :ë    H :ê    H :i    H :ç    	H :å    H :d    H :â    H :a    H :ß    H :^    H :Ü    H :Û    H :Z    H :Y    H :×    H :V    H :Ô    H :S    H :Ñ    H :P    H :O    H :Í    H :Ì    H :K    H :J    H :È    H :Ç    	H :Å    H :C    H :B    H :Á    H :À    H :?    H :=    H :º    H :9    H :·    H :6    H :´    H :²    H :±    H :0    H :­    H :¬    H :«    H :*    H :¨    H :'    H :¥    H :¤    H :£    H :¢    H :¡    H :     H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H :    H : 4§H   @  3 	03   15+  4y   4.±   4­        Ê       Êk`4x@  4ª@@ 4.Q8 4.X8 4®*8 4x+  6¾,>  ,> 6,>  Z4    @ 4. " æ B 4® $ v D 4/ & Ó F 4¯ ( Û H 40 * º J 4° , Ü L 41 . ã N 4± 0 e P 42 2 ? R 4²   X @ 43 " * B 4³ $ 4 D 44 & s F 4´ ( | H 45 *  J 4µ ,  L 46 . ­ N 4¶ 0  P 47 2  R 4·    @ 48 "  B 4¸ $ à D 49 &  F 4¹ (  H 4: *   J 4º , Ä L 4; . + N 4» 0 ® P 4< 2 â R 4¼   U @ 4= " _ B 4½ $ m D 4> & = F 4¾ (  H 4? * { J 4¿ ,   L 4@ . ¹ N 4À 0   P 4A 2  R 4Á     @ 4B "  ) B 4Â $ Â D 4C & k F 4Ã ( Ñ H 4D *  J 4Ä , . L 4E . Z N 4Å 0  P 4F 2 8 R 4Æ   % @ 4G " % B 4Ç $ ¡ D 4H & %Q F 4È ( %Ò H 4I * %T J 4É , %[ L 4J . ú N 4Ê 0 %h P 4K 2 ÿ R 4Ë    @ 4L "  ã B 4Ì $  D 4M & ! F 4Í (  ; H 4N * !¬ J 4Î , !Õ L 4O . "+ N 4Ï 0 "û P 4P 2 #Ï R 4Ð   !õ @ 4Q " $ B 4Ñ $ ® D 4R & ¸ F 4Ò ( Ó H 4S *  J 4Ó ,  L 4T . l N 4Ô 0 ó P 4U 2 * R 4Õ   ñ @ 4V " Õ B 4Ö $ ý D 4W & 0 F 4× ( 0 H 4X * 0	 J 4Ø , 0 L 4Y . 0 N 4Ù 0 2 P 4Z 2 ,+ R 4Ú   ,² @ 4[ " .É B 4Û $ .Ô D 4\ & /á F 4Ü ( /e H 4] * .- J 4Ý , ,; L 4^ . - N 4Þ 0 -1 P 4_ 2 .ß R 4ß   -ô @ 4` " . B 4à $ .¯ D 4a & .; F 4á ( /0 H 4b * . J 4â ,  L 4c . /õ N 4ã 0 /j P 4d 2 0 R 4ä   i @ 4e " %ì B 4å $ & D 4f & &| F 4æ ( '8 H 4g * ( J 4ç , ) L 4h . (º N 4è 0 (6 P 4i 2 (] R 4é   )" @ 4j " )Á B 4ê $ · D 4k & Ã F 4ë ( * H 4l * *Ã J 4ì , *U L 4m . *æ N 4í 0 *x P 4n 2 +
 R 4î   + @ 4o " +­ B 4ï $ +¿ D 4p & 6 F 4ð ( ´ H 4q *  J 4ñ , / L 4r . i¼ N 4ò 0 0Ë P 4s 2 û R 4ó   * @ 4t " +t B 4ô $ , D 4u & +Ñ F 4õ ( å H 4v * p J 4ö , %â L 4w . 1 N 4÷ 0 0w P 4x P  / 9È+x    3   4û    H 6             6    bH  OP9®O86   9´{p6INITSYMCMDADDR    6 _x6            x     H :    H :    H :    H :    H :    H :    H 9ÿ    H 9~    H 9ý    H 9|    H 9{    H 9ù    H 9x    H 9w    H 9u    H 9t    H 9s    H 9ñ    H 9ð    H 9o    H 9í    H 9ì    H 9k    H 9é    H 9h    H 9æ    H 9e    	H 9c 6<H 4(@  6 h6    4©+  6Q   6Ân   6B               zp6P@  6?@@ 6ÂQ8 6ÂX8 6C*8 6P+  9,>  ,> 6÷,>  Z4 2 9 R 6Â   9 @ 6C " 9 B 6Ã $ 9 D 6D & ph F 6Ä ( Y H 6E * 9 J 6Å , 9 L 6F . d N 6Æ 0 9¥ P 6G 2 9 R 6Ç   9ª @ 6H " 9« B 6È $ 9© D 6I & 9* F 6É ( 9( H 6J * 9& J 6Ê , 9¦ L 6K . 9% N 6Ë 0 9¤ P 6L 2 9+ R 6Ì   9¬ @ 6M " 9  B 6Í $ 9 D 6N & 9 F 6Î ( 9' H 6O * 9¨ J 6Ï , 9 L 6P P  / 9È+x    6   6Ó    H 6z             6ù    n8  jP9®j86ñ   9´v 6ùINITVARLOCS    ,>  ,> 7Ð,>  Z4@n 7Ê  9 P 7Ë7R 7Ë,I H  R 7Ë4R 7 P ,<ÿ,<  7F 7Ë,I\) Z
ÿ,<'ÿ,<   ,>  ,> 9W,
Ò,
v4B 7 P ,<7ÿ,<0  7N 7Ë,I\18 ,<Gÿ,<@  ,
v4B 77R 7Ë,I H Z6 7S,z+  7H+  77@ 7K+  77D 7Ë,I\' ,<ÿ,<  7H 7K,I\+  ,</ÿ,<(  ,
v4B 7+  7\"ÿZ6 7S,z+  7H+  7  7Ë L 7K+  67@ 7K+  77N 7K,I 8  N 7Ê 0   P 7J0p  Ê+  7? P ,<Oÿ,<H  (P  ZOÿ,<@3,<@3,>  ,> 9W,
Ò,
v4B 7> P ,<ÿ,<    7J(H  ,< 3,< 3,
v4B 7/ 
 7J (4­Z6 7S,z+  7H+  7>7@ 7Ê+  7=  7Ê(Lw0L  +  7º  7J(N  ,<83,<837P 7K,I\3@ ,<Oÿ,<H  ,
v4B 78+  7:\"ÿZ6 7S,z+  7H+  7¼\"ÿZ6 7S,z+  7H+  7>   7J @ 7Ê  7J9 7 7@ 7Ê+  7Ä  7Ê(Bw0B  +  7C  7Ê+  7D  7Ê 4­+  7E!$      Z6 7S,z+  7H 6 7S,z/ 9J P  / 9È+x ~x7Ë   6s   6û    H 7U
            7S  7ÒyH  oP9®o87H   9´    H 7KH 7Ëx   |7ÔSYMCMDADDR,>  ,> 7z,>  Z4@h 7u *   J 7ô0j  +  7í P ,<7ÿ,<0  (J  Z7ÿ,<(6,<(6,>  ,> 9W,
Ò,
v4B 7ì P ,<Gÿ,<@    7ô(R  ,<H6,<H6,
v4B 7h  7ô 6BZ6 7ü,z+  7ò+  7ì7@ 7u+  7ë\"ÿZ6 7ü,z+  7ò+  7ì  7ô F 7u 
 7ô9
 7Y7@ 7u+  7p  7u  6B+  7ð!(      Z6 7ü,z+  7ò/ 9J P  / 9È+x 7u   7L   7V    H 7ý
            7ü  7|~`  zx9®z`7ò   9´    x   z7}SYMVARADDR,>  ,> 8±,>  Z4 
W(Jw0J  +  8  9 L 8¬7N 8¬,I 8  N 8¬4N 87P 8¬,I @ 2PW+  87R 8¬,I\%H ,<ÿ,<  ,< 9a,< 9á,
Z6 84,z+  8ª+  8  9 F 8¬7H 8¬,I    H 8¬4H 87J 8¬,I 
( 2JW+  87L 8¬,I\/0 Z?ÿ4P 87R 8¬,I\%H ,<ÿ,<  ,< 9a,< 9á,
+  8,< 9^,< 9ÞZ6 84,z+  8ª+  8+  8' &   F 8,0f  Ê+  8' 4­2FW+  8&  8,(H  ,< 3,< 3Z6 84,z+  8ª  8,9 8,< ?ä,< ?eZ6 84,z+  8ª 6 84,z P  / 9Ç+x ~x8¬   7õ   7þ    H 86             84  8³X    9®h8ª   9´ 
   H 8¬x   x   þ~8µSYMCMDNAME,>  ,> 8J,>  Z4 *   J 8E0j  +  8A 
(6B2JW+  8@  8E(L  ,<06,<06Z6 8Ì,z+  8Ã 
 8E9
 8¹,< ?ä,< ?eZ6 8Ì,z+  8Ã P  / 9Ç+x 8E   8-   87    H 8Í             8Ì  8L`  9®p8Ã   9´ 
   x   }P8MSYMVARNAME, ^g, è BP 5" 8Q+  8T,>P , ¹7@ 9+  8Ó+  8T+  8O P  / 9Ç+x    8Ù,>  ,> 8Ý,>  ,> 9ÖZ4þ+  8Î   8Å   8V    H 8a             8ß      
x9®	h8T   9´x   x    |H8àCLOOP    ,<wÿ,<wÿ, QÊ5B 8e!"   +  8èOn 9, 8V@p 9, Rb@r 9\"ÿ+  8è/ 9J,~      8~,>  ,> 9,>  Z4,< 9Ü,< 9],< 9,< 9,
,< ={,< =û,
,< 9[,< 9Û,
,< 9Ù,< 9Z,
,\ 8},\ 8ü,< 8ü,< 8}, 8b5B 8ù,< 9X,< 9Ø,< 8ü,< 8},
, _;+  8{,< ?ä,< ?e, _; P  / 9È+x 8}   8Y   8j    H 9             9    `  89® 8{   9´x   89CINI  8ü   6>, w7 6 9´,z P  / 9Æ,~   89    þ   Û   V   õxx3   4.x6    6ÂX9­   8ý    ø    
H 9µ   p9°       9´x92h  x94x   `95DED - Command modulep9·`  4û`  6Ó 9¹x'6x'¶x)x) x)!x)¡x)Ax)mx)íx)nx9x9p9@  H9   9}89Áÿ÷õ      8   H     ï            (   0         w       /    (9                                                ¿                    ?ÿ    	    ÿ    (9Ö            H 9YNo       H 9Ú.INI     H 9\PEAK     H 9Ý(        	H 9_"Un-named" (Macro)      H 9b (Macro)  CheckpointInterval  VariableFill   SwapPMRegion   JournalCommand JournalFile    JournalMacro   CRAsCtl   ExactCaseMatch RightMargin    LeftMarginIndentWidth    TabWidth  UseTabs   OverWriteOnInsert   EscapeAs$ BreakPageOnFF  WrapLongLines  Multiplier.StickyColumn  .Box .XMetaPrefix   .MetaPrefix    .ExitToRPG.ScreenWidth   .Arg .LastCmd  .Cmd .Debug    Set CreAux Esc Char CreAux    Set Terminal Type   Decrement Char Increment Char Insert Information StringDate Time Message   Start Message  Start Comment  Abort Command  Help Beep Frame PushNothing   XOFF SynchDelete NULLs   Not Special    Is SpecialNot Delim Is Delim  Not Token Is Token  Not NumberIs Number Execute Macro  Pop Binding    Push Binding   UnName Macro   Name MacroBind MacroDefine Macro by Example  Define Macro   UnBind KeyExecute Function    Query Function Bind Function  Query Variable Bind Variable  Toggle Overwrite Flag    Toggle Wrap Flag    Normal Mode    Text Mode Exit Safe Exit Recover CheckPoint File  Recover Checkpoint  CheckpointFinish to RPG  Finish    Command File   Write FileInsert File    Read File UnModify BufferUnlock Buffer  Lock Buffer    Last Buffer    Next Buffer    Delete Buffer  New BufferRefresh Window Window BarGrow Window    Switch Windows Unsplit Window Split Window   Unindent RegionIndent Region  Insert Kill Buffer  Wipe Region    Copy Region    Goto Mark Swap Mark Clear MarkSet Mark  Reverse Special Search   Special Search Match Parens   Multiple SearchRepeat Query Change Query Change   Change    Reverse Search AgainReverse Search Show Search String  Search Again   Copy to Search Search    Show OctalShow Column    Goto Column    Force Left Margin   Set Right Margin    Set Left MarginFill to End of Paragraph Fill Paragraph Fill Line Down Paragraph Up Paragraph   Transpose Capitalize Token    Toggle Token   Token LC  Token UC  Toggle Case    Unindent Line  Indent Line    Right Justify Line  Center Line    Indent Line Up Indent Line Down    Indent Column Down  Open Line With Indent    Open Line Insert Octal   Column Insert  Insert TABInsert CRLF    Insert    Delete Whitespace Backward    Delete Whitespace ForwardKill Partial Line   Set Append KillKill Line Delete Token Backward    Delete Token ForwardDelete BackwardDelete    Scroll Window Down  Scroll Window Up    Line to Top of Window    Bottom of Buffer    Top of Buffer  Bottom of Page Top of Page    Bottom of Window    Top of Window  Backward WindowForward Window End of Line    Beginning of Line   Backward Token Forward Token  Backward  Forward   Down Up   Argument      H ;c [circuit zapped]       	H ;f [circuit remains]      H ;i [continued]       H ;ë[buffer locked]    H ;n[failed]      H ;pLogin:        H ;rNew CreAux escape character:      H ;v-Type any character to clear-     H ;zPEAK.HLP      H ;|,        H ;ý[        H ;gettab        H <                     Open Buffers:     H <          Type any other character to continue        H <                  Type N or ^G to quit      H <                    PEAK Online Help        H <-No More-     H <-More-        H < for box display        H <% Can't lookup     H <New Bar:      H <!Text     H <¢Text+    H <$Normal        H <&Normal+       H <(Buffer is locked!       H <+Checkpoint File:        H <.Type POP to return to PEAK        H <2 [Aborted]    H <4Command File:      H <¶No checkpoint has been done.      H <º [Restored]        H <= [Complete]        H <¿Checkpoint         H <BYes      H <ÃNo       	H <E modified.  Exit?       H <HBuffer        H <J...      H <Ës        H <MWriting Modified Buffer      H <ÐNo Buffers Modified     H <Ó[Failed]      H <Õ[Complete]    H <×[Working]     H <Ù]:       H <[Write File [       H <ÝInsert File:       H <`  [Failed]    H <b  [Complete]       H <ä [Working]    H <æ [Bad Switch]      H <i [Bad FileSpec]    H <ë[Aborted]     H <íRead File:         H <pYou cannot kill your only buffer.      H <ôYou cannot kill a buffer while it is in two windows.       H <{(Scratch)     H <}No Free Buffers!        H =          H =Defining Text Message.  End with       H =TIME     H =DATE     H =	USERNAME      H =I-Str:        H =is not in <special>     H =is in <special>    H =is not in <delimeter>        H =is in <delimeter>       H =is not in <token>       H =is in <token>      	H =is not in <number>      H =¡is in <number>     H =$Char:         H =&Defining comment.  End with       H =*" removed [ok]     H =¬Macro: "      H =®Macro Name:        H =1" [ok]        H =3Macro named: "     H =µName for Macro:         H =¸ cannot be un-bound from a function.        H =½ [ok]    H =?+        H =À[ok]     H =BBind Macro to Key:      H =EKeyboard macro empty.        H =È>:       H =J <       H =ËDelimited Macro    H =NDefining Macro by example.  ^G to end definition.     	H =TExecute Function:       H =WMacro depth overflow - macro aborted.       H =\         H =Ý is:     H =_ isn't bound       H =áKey      H =cKey:     H =ä [Ok]    H =f$ To Key:     H =hBind Function:     H =ê, was         H =ì is      H =n is ambigious      H =ð is unknown        H =sAborted       H =uVariable:     H =wRight Margin:      H =ùLeft Margin:       H =|)        H =ý) must be less than or equal to the Right Margin (    H >The Left Margin (       H >Match Failed       H >	Not set up to match that!    H >No Previous Q-Change Command      H > [       H > [No]    H > [Yes]        H > ?       H >Q-Change Aborted        H >Q-Change:     H >]        H >  [      H > to:     H > Change Aborted     H >#Change:       	H >%No M-Search String      H >(M-Search Aborted        H >+M-Search:     H >-Reverse Search Aborted       H >°Reverse Search:         H >³  [failed]    H >µNo Search String        H >¸Search Aborted     H >;Search:       H >=No Search Strings       H >@   M-Search: "     H >Â"        H >DSearch: "     H >FMark 0 isn't set        H >IYank Complete      H >ËWipe Complete      H >NWipe Aborted       H >ÐCopy Complete      H >S characters.  Copy Aborted.       H >WKill Buffer would overflow by     H >[Kill Saved    H >]Kill Aborted       H >ßSearch String Set       H >â are in the same place       H >fThe Point and Mark      H >i not set      H >kSearch String Full - Enter (A)bort or (P)roceed:      H >qProceed       H >sSave     H >ôAbort    H >vKill Buffer Full - Enter (A)bort, (P)roceed or (S)ave:     H >üString to Insert:       H >ÿEnter Octal of the character to be inserted: '        H ?Octal of next character: '        H ?Column:       H ? cleared      H ? isn't set    	H ?Bad Mark Number -       H ? Set     H ?Mark     H ?Buffer must be unlocked to delete nulls.    H ?Quote    H ?:        H ?-    Dec  Nov  Oct  Sep  Aug  Jul  Jun  May  Apr  Mar  Feb  Jan      H ?%CSLEN        H ?'Too many search strings specified.     H ?«MATCH    H ?-CSSTR        H ?/[MovePast]    H ?1[MoveTo]      H ?3<Del>    H ?´<Esc>    H ?6<Null>        H ?8<Meta>        H ?:<XMeta>       H ?<^        H ?½Del      H ??Space    H ?ÀEsc      H ?BNull     H ?ÃMeta     H ?EXMeta         H ?G$        H ?È
       H ?JBinding Stack is empty       H ?ÍKey:     H ?OBinding Stack is full        H ?ÒArg:     H ?TUse ^X^C      H ?VKeyboard macro defined       H ?ÙXMeta    H ?[Meta     H ?ÜMaximum Macro length exceeded -- aborting definition       H ?c[CheckPoint]   p?ä    î  H x?æ    wx?ç @  à`?j   9Á   9B P  
   9®?m7    O@   -    ,>  ,> Kå,>  X4+  ?x   ?uù   ?ô               ?w@  ?ñ@@ ?uQ8 ?uX8 ?õ*8 ?w+  @   ?~ù   ?ý               @ @  ?ú@@ ?~Q8 ?~X8 ?þ*8 @ +  @   @wx@            x @@  @  (@   9A@@ @Q8 @X8 @*8 @+  @   @wx@            x @@  @  (@   @@@ @Q8 @X8 @*8 @+  @¦   @ wx@            x @¤@  @  (@    @@@ @ Q8 @ X8 @ *8 @¤+  @¯   @¬ù   @,               @®@  @)@@ @¬Q8 @¬X8 @-*8 @®+  @¸   @µù   @5               @·@  @2@@ @µQ8 @µX8 @6*8 @·+  @Á   @¾ù   @>               @À@  @;@@ @¾Q8 @¾X8 @?*8 @À+  @Ê   @Çù   @G               @É@  @D@@ @ÇQ8 @ÇX8 @H*8 @É+  @Ó   @Ðù   @P               @Ò@  @M@@ @ÐQ8 @ÐX8 @Q*8 @Ò+  @Ü   @Ùù   @Y               @Û@  @V@@ @ÙQ8 @ÙX8 @Z*8 @Û+  @å   @âù   @b               @ä@  @_@@ @âQ8 @âX8 @c*8 @ä+  @î   @ëù   @k               8@í@  @h@@ @ëQ8 @ëX8 @l*8 @í+  A   @ôc   @ôh@ò           8A@  @q@@ @ôQ8 @ôX8 @u*8 A+  A   Aù   A}HA           :   ,            @  A+  KÆ7@ÿ+  A!*  +  A!*    A.  (N  G
   þA0 ÿ(P  	 ~A2ÿG  G
  ,>  ,> Kõ, {o B A&7@ u2+  A£!    +  A$   A&    +  A%/ Ku+x ~ A&7@ÿ+  A¨!&  +  A)!&    F A77@+  A«!*  +  A,!*   G
 A7 þA, ÿ(L  	 ~A.ÿG  G
  ,>  ,> Kô, {o B A¶7@ u2+  A4!0   +  A´  A¶   +  Aµ/ Ku+x }XA7,o B AJ2B Kù+  A=,> Kz,> Kz,< Lì,< Lm,< Lk,< Lë, yÚ,> AJ,< Lé,< Lj,> Kt,> Kz,> Kz,> AÉ,> AIO` AÊ,> AÈ, k7@ AÊ+  AG,> Kz,> Kz,< Lf,< Læ,< Lk,< Lë, yÚ  AJ+  AH,~      AÊ   K|   Kü~AÊ,>ÿ,> Kz, -/ Kó+x Z Ks    D KÝ &H  F KT@h KÔ@j KÕ@l KV .   N KÖ 0   P AÚ0p  +  AØ00  0p  b Ld  AÚ.2   R@?ô  AÚ9 AS@` ?w, A· B K×,~   |AÚ ÿQ"  @d  @h  b  +    / Kó+x 6@ KÖ+  Aàg  "$     +  Ab,~   ,> Kz,< Lâ,< Lc, {k." t,>  ,&,> Kú,> Kû,
Ò,< La,< Lá,
,Î C & t. KV,>  ,&,> Kú,> Kû,
Ò,Î Cÿ/ Kò+x   K×Q"  b   ,~   @@ Aù  K×Q"    ÿ@h  b   F Aù7@ Aù+  Awg  "(     +  Aø/ Kò+x  Aù  K×Q"   Rÿ@h  @@ Bb  O@ B7@ B+  Aÿg
  "*     +  B/ Kò+x  B,> B
,> B, Aâ,> B,> B, Az4B B,> Kù,< LÙ,< LZ, }~/ Kr, Aï,~      B   B`B+  B   Bú   BhB           XB@  B+  BV   B<   BhB    ¿       @oBU@  B,> CÜ,> Kz,	Ï  KV0,  0l  b L×(L  \. KK,N0@,N0@  KV00  0p  b LÕ(P  \2 KL,R@@,R@@   Kñ @ B  KV0$  0d  b LÓ  KY F B F@G  KV0(  0h  b LÑ 
 KØ J B J @>  KV0,  0l  b LÏ  K[ N B N0@,  KV00  0p  b LÍ  KÛ R B R@@5  KV0$  0d  b LË  K^ F B F@P  KV0(  0h  b LÉ 
 KÞ J B J @Y  KV0,  0l  b LÇ  K\ N B N0@b  KV00  0p  b LÅ  KÜ R B R@@k,< KÊ,< KK,> Kx,> K{,
Ò,W B B,< KÊ,< KK,> Kx,> K÷,
Ò,W B B,< KÊ,< KK,> Kx,> Kö,
Ò,W B B,< KÊ,< KK,> Kx,> Kq,
Ò,W B B,< KÊ,< KK,> Kx,> Kð,
Ò,W B B,< KË,< KL,> Kx,> K{,
Ò,W B B,< KË,< KL,> Kx,> K÷,
Ò,W B B,< KË,< KL,> Kx,> Kö,
Ò,W B B,< KË,< KL,> Kx,> Kq,
Ò,W B B,< KË,< KL,> Kx,> Kð,
Ò,W B B,< KË,< KL,> Kx,> Kw,
Ò,W B B,< KË,< KL,> Kx,> Kø,
Ò,W B B  K].&   F K] F B   KÝ H B  
 KX J B!  KV0,  0l  b LÃ(L  \. KJ,N0@,N0@,< KÉ,< KJ,> Kx,> K{,
Ò,W B B¡,< KÉ,< KJ,> Kx,> K÷,
Ò,W B B"  KW P B¢!2    R C]0r  +  C=.2    C]0$   0d  b LB @ô DHB  C]9 C7  Kp F BU,> CÛ,> C[, Aâ,> C^,> CÞ, Añ  K×Q"   $  b  +      K×Q"   $ B/$  Q$@@   b    KØ. KÞ.(  &(   H CÝ@j B J B0(  +  CÏ" CÝ(L  	  KT/.  A.ÿG   L B+  CW  KT/0  A0ÿG Kï P B  CÝ/2~ "  (R  	   KT. ~ /   A ÿG    R B  K×Q"    B  B  Bb  , Aï,~      CÞ   C^   B   B`CÞ+  Ce   Ccú   CchCa           XCd@  Cß+  D©   Ci<   CihCg    ¿       @o8D¨@  Cå,>,>, Az  K×Q"   $  b  +      K×Q"   $ Ci/$  Q$@@   b    KV0$  0d  b LÓ  Cé F@G @G D KY  KV0(  0h  b LÑ 
 Cj J @>  @> H KØ  KV0,  0l  b LÏ  Cê N0@, 0@, L K[  KV00  0p  b LÍ  Ck R@@5 @@5 P KÛ  KV0&  0f  b LË 
 Cë J@P @P F K^  KV0.  0n  b LÉ  Cl R8@Y 8@Y N KÞ 
 KV0*  0j  b LÇ  Cì R(@b 
(@b J K\  KV02  0r  b LÅ   Cm @H@k H@k R KÜ4D DRg  "$   D KZ  KY3F KØ+  DUg  "(   H KÚ 
 Có J K]  Ct L KÝ  Cô N KX  KV00  0p  b LÃ(P  ,> Cu,ò,> Cõ,ò,
,\@@,\@@\0@@,P KJ,P KÉ,< KÉ,< KJ,> Ky,> K{,
Ò,< LÀ,< LA,
v B 9§  KV0$  0d  b L×(D  ,> Cí,ò,> Cn,ò,
,> Cî,ò,
,> Co,ò,
,> Cï,ò,
,\@,\@\$@,D KK,D KÊ  KV0&  0f  b LÕ(F  ,> Cp,ò,> Cð,ò,
,> Cq,ò,
,> Cñ,ò,
,> Cr,ò,
,> Cò,ò,
,> Cs,ò,
,\@,\@\&@,F KL,F KË  Cv H KW!*    J E­0j  +  E0*   0j  b LB ,  . E­ 0Ci L(@ô 
 E­9
 E  KØ. KÞ..  /.  &.   N E.,> Kv,> Ko,> Kù,> Kz, A¦4B E,> Kz,> Kz,< L<,< L¼,< Lk,< Lë, yÚ  E..0  /0  &0   P KÔ,> Kv,>  ,> Kú,> Kz, A4B E,> Kz,> Kz,< L·,< L8,< Lk,< Lë, yÚ@r Cd R Cã   E.0   +  E " E.(B  	  KT/$  A$ÿG   B Cc+  E(  KT/&  A&ÿG Kï F Cc  E./(~ "  (H  	 
 KT.*~ /*  A*ÿG   H Cã  K×Q"    Cc  Cã  Cdb  , Aï/ Kò+x    Cc   Ci8E.,> E²,> E2, Aâ,> E3,> E³, C_,~      E³   E3{E³6@ KÖ+  E¸,> Kz,> Kz,< L4,< L´,< Lð,< Lq, yÚ  KÖ L EÛ  KÖ0.  0n  b Ld 8?ô N KÖ6@ KV+  EÅ  EÛ P KÕ  EÛ02  0r  b Ld  EÛ0$  0d  b L2@f?ý ?ý DH?ô  EÛ H KV+  EÙ 
 EÛ0*  0j  b Ld  KV0,  0l  b Ld 0?ô L(?ô  EÛ0.  0n  b L2  KV P8?ý  KV02  0r  b Ld7@H?ô+  EÕ  KV0$  0d  b Ld ?ô0$  0d  b L2  EÛ F?ý  KV0(  0h  b Ld 
 EÛ J ?ô  EÛ L KV, B,> KV, ^!,~   ~8EÛ,> K×, A[,>,>, Az4B Eâ,>,>, C_,< L/,< L¯, _;+  Eä,< L©,< L*, _;, i¼7@ Eè+  Efg  ".     +  Eç/ Kò+x zHEè,> K×, A[  KÕ2P KV+  Eî  KV02  0r  b Ld H?ô R KÕ  KV0$  0d  b Ld7@?ô+  F  KV0&  0f  b Ld ?ô F F0&  0f  b L2  KV0(  0h  b L2  ?ý H?ý 
 KV0*  0j  b L27@(?ý+  F  KV0,  0l  b L2 0?ý0,  0l  b Ld  F N0?ô+  F  KV00  0p  b L27@@?ý+  F  KV02  0r  b L2 H?ý R F02  0r  b Ld  KV0$  0d  b Ld ?ô DH?ô+  F@f F  KV0(  0h  b Ld 
 KÖ J ?ô  KV L KÖ  F N KV4N F, E®,> KV, ^!,~   yF ÿ2P KV+  F+  F, B ÿ R KV,>ÿ, ^!, E®, ^g/ Kó+x   ÿ0@  +  F(  KV0$  0d  b Ld7@?ô+  F&, B  KV0&  0f  b Ld ?ô F KV,>  , ^!, E®, ^g+  F§,< L¦,< L', _;+  F4 ÿ2H Kù+  F4 
 KV0*  0j  b L27@(?ý+  F², B  KV0,  0l  b L2 0?ý L KV,>  , ^!, E®, ^g+  F4,< L£,< L$, _;/ Kó+x   KV N FM@p FL  FM02  0r  b L27@H?ý+  F¾   FL.    @ FL  FM0$  0d  b L2 ?ý D FM+  F¶  KV F FM@h FÌ 
 FM0*  0j  b Ld7@(?ô+  FH  FÌ.,   L FÌ  FM0.  0n  b Ld 8?ô N FM+  F@  FL(P  	  FÌA2ÿG     +  FË,~   v(FM7@ KV+  FO, B, E4Z KÉ5D FR\& L",F KJ,F KÉ  KV0(  0h  b LÃ(H  \* KJ,J @,J @  KV0,  0l  b L×(L  ,<wþ,<wþ,\ KK,\ KÊ\. KK,N0@,N0@  KV00  0p  b LÕ(P  ,<wÿ,<wÿ,\ KL,\ KË\2 KL,R@@,R@@  KV0$  0d  b LÓ@f KY F@G  KV0(  0h  b LÑ@j KØ J @>  KV0,  0l  b LÏ@n K[ N0@,  KV00  0p  b LÍ@r KÛ R@@5  KV0$  0d  b LË@f K^ F@P  KV0(  0h  b LÉ * 
  J KÞ J @Y!,    L G0l  +  Fù0,   0l  b LBOn0@ô  G9 Fu, H0 B KÙ,>  ,> Kz, Hø, H0 B K\,>  ,> Kz, Hø, H0 B KÜ,>  ,> Kù, Hø  KV00  0p  b LÇ  K\ R@@b  KV0$  0d  b LÅ  KÜ F@k@h K]Oj KÚ J KZ ,   L KÔ,> Kv,>  ,> Kù,> Kz, A¦4B G,> Kz,> Kz,< L,< L,< Lk,< Lë, yÚ,> Kv,> KÔ,> Kú,> Kz, A4B G,> Kz,> Kz,< L,< L,< Lk,< Lë, yÚ  KV0.  0n  b LÉ 0   P KÞ P8@Y/ Kî,~   {G  KØ. KÞ.2  /2     &0   P GB 2  2. KÔ,>  ,> K{,> Kù,> Kz, A¦4B G¦,> Kz,> Kz,< L,< L,< Lk,< Lë, yÚ    2.  KÔ,>   ,> K{,> Kú,> Kz, A4B G.,> Kz,> Kz,< L,< L,< Lk,< Lë, yÚ  KÔ."   B KÔ  K^2$ KØ+  G@  GB/&   F GC  GB/(  .(   H GÃ 
 K^.
 KÞ&*  /
 GB"J GÂ7` GÂ+  G@  KT. GÃ  KT. GC 8   N0    GÃ/0   P GÃ  GC/2   R GC   GÂ/    @ GÂ+  G7  KÞ." 
  B KÞ,~   }PGÃ  K^2$ KØ+  GU  KØ. KÞ.&  &&   F GW  K^. KÞ&(   H G×/(   H GX/ G× F GØ7` GØ+  GU 
 KT.
 GX  KT. G× 0   L(    GX..   N GX  G×.0   P G×  GØ/2   R GØ+  GL   KÞ/  
  @ KÞ,~   (GØ  K^/"   B GÞ&"  . KT B G_  GÞ&0  GHA+  G^,~   0G_  K^&0  . KT P Gä  K^&,  G8A   +  Gd,~   Gä  K^. KÞ/.   N Gë&.  . KT N Gl  Gë&0  GHA   +  Gk,~   Gl  K^. KÞ R Gs   &0  . KT P Gó  Gs&,  G8A   +  Gò,~   ~xGó  KY3. K^+  Gö  KÞ+  Gw!0   . KY P Gü&0  . KT P G}  Gü&,  G8A   +  G|,~    G}  KØ. KÞ N H&.  . KT N H  H&0  GHA   +  H,~   |`H  KY2R K^+  H+  H+  H   KY3` K^+  H, Gì B Kà, Gß B Kß  KY/ K^ D H &   F H2f H+  H( Kàh Kß` Kà` Kß  H9 H  KY N K^+  H, Ge B K`, GY B K_  K^/ KY P H 2   R H2r H+  H  K_` K`,> K_, rª B K_,> K`, rª B K`  H9 H  KY B K^,~   |H  KY$$  2& KØ   +  H",~     KY+  H£,~   @f KÚ F KZ ÿ H KY5h H§@j KYOl KZ  KY3. KØ+  Hª  KØ P KYOr KÚ/ Kó+x ,> KÙ, Hà+  H-,~   ,> KÙ,>, Hø/ Kó+x  $   D H?0d  +  H½0$   0d  b LB @ô2D Kù+  H¼  H?0&   0f  b LB\( H@ô 
 H?/*  2J KW+  H»  KW..   N KW  H?+  H¾  H?9 H°\"ÿ+  H¾,~   {xH?7 ÿ+  HÂ 0  . KW2pÿ+  HÆ,> Kz,> Kz,< L,< L,< Lk,< Lë, yÚ+  HÕ ÿ02  +  HS ÿ0$   0d  b LB @ô3D Kù+  HÒ ÿ0&   0f  b LB @ô0&   0f  b LBOh@ô 
ÿ0*   0j  b LBOl(@ô+  HÕ ÿ0.   0n  b LBOp8@ô 2  . KW/2   R H`12  +  H_02   0r  b LB H@ô2R Kù+  HÝ  KW/&   F KW+  H^+  H_  H`= HW/ Kó+x yH`7 ÿ+  Hã (  . KW2hÿ+  Hi,> Kz,> Kz,>þ,&,< L,< L,	},< Lk,< Lë, yÚ+  H÷ 
ÿ0*  +  Ht ÿ0,   0l  b LB 0@ô2L Kù+  Ho\.ÿ+  Hó ÿ00   0p  b LB @@ô00   0p  b LB @@ô+  Hö ÿ02   0r  b LB H@ô   +  H÷/ Kó+x 6 ÿ+  Hú@`ÿ+  H} ÿ3b KØ+  H}  KØ Dÿ7 +  I  &  . KW2f+  I,> Kz,> Kz,>~,&,< L,< L	,	},< Lk,< Lë, yÚ+  I 0(  +  I 
0*   0j  b LB 
(@ô2J Kù+  I 0,   0l  b LBZL I, H0  I B8@ô 00   0p  b LB @@ô00   0p  b LB ÿ R@@ô+  I 0$   0d  b LB ÿ F@ô/ Kò+x y8I@@ KZ@@ KÚ ÿ.v KY5v I@v KYO@ KZ36 KØ+  IO@ KÚ  KØ V KY/ Kó+x 7@ KÛ+  I!+  I9, H7`ÿ+  I¬  KY2( KØ+  I,  KY $ @ù  KW<& I§3"  >   9 I¥ 
 KÞ.*   J KÞ  KØ/,   L KØ2L KY+  I,On KÚ+  I77` KY+  I7  KY $ @ù  KW<& I13"  >   9 I/  KY/0   P KY  K^/2   R K^   KÞ.    @ KÞ  KØ/"   B KØ6@ K[+  I9Od K[, ^´/ Kó+x 7@ KÛ+  I»+  IL  KY $ @ù  KW<& I?3"  :   9 I=, H  KÞ0f 
 +  IÁ, G, Gß B IM  K^.(   H K^ 
 KÞ/*   J KÞ ÿl    KØ..   N KØ  KY.0   P KY@r KZ6@ K[+  ILO` K[, ^´/ Kó+x w`IM  KY3" KØ+  IP!"   +  IÕ  KY28 K^. KÞ&8  . KT `  $:  .:  )Vh  A6  ¿   ,~   7@ÿ+  I×g  "$   D J ÿ.&  /&  &&  .&   F KÔ (   H KÞ,> Kv,> Ko,> Kù,> Kz, A¦4B Ic,> Kz,> Kz,< L,< L,< Lk,< Lë, yÚ,> Kv,> KÔ,> Kú,> Kz, A4B Ié,> Kz,> Kz,< L,< L,< Lk,< Lë, yÚ 
ÿ$*   J KØ ,   L J@n KU ÿ P J7@ÿ+  Iþ 2  2rÿ ÿ R J,>   KT.  JZ   ,>  ,>  ,6@ KU+  I{  KT. J  J0D  <D I{?` J+  I{   aF  O@ KU."  =d I÷ ÿ/ J Fÿ  J. J H J+  Ií6@ J+  J 
 J/*   J J ,   L J .   N J0n  +  J  KT. J @  A J4P J+  J+  J  J(R   R J   KØ/    @ KØ  J9 JOb KZ7@ KØ+  Jg  "$   D KÚ/ Kò+x }(J  KY F J§  KØ H KY, H, Gß B J¨!*   j  !,   L J¨!.   N J¨!0   P J¨@r J)   KØ.   &    @ J(7@ J(+  J%  J(0b   "   B J¨,>ÿ  KT. J),>  ,>  ,w/ J("B J(  J). J¨ F J)+  J  J§ H KY@j K[/ Kó+x }HJ)  KÕ L J=7@ J=+  J»  J=2N KV+  J/7@ K[+  J/Z KÊ5P J7  J=3R KV+  J8  J=0$  0d  b LÏ7@@,+  J8  J=0&  0f  b L×(F  Z@4H J8\"ÿ+  J¼ 
 J=0*  0j  b Ld 
(?ô J J=+  Jª!"   +  J¼,~   }8J=  KÕ L JÒ@n JR7@ JÒ+  JÐ  JÒ2P KV+  JÃ7@ K[+  JÃZ KÊ5R JË   JÒ3@ KV+  JM  JÒ0$  0d  b LÏ7@@,+  JM  JÒ0&  0f  b L×(F  Z@4H JM  JR.,   L JR  JÒ0.  0n  b Ld 8?ô N JÒ+  J?  JR+  JÑ,~   zpJÒ  KV00  0p  b LÏ  K[ R@@,7@ KV+  Jf7@ÿ+  Je  KV0$  0d  b LÏ7@@,+  Je  KV0&  0f  b L×(F  Z@4H Je 
 KV0*  0j  b L×(J  ,<(@,<(@, U75B Jd!"   +  Jh, Ei+  Jå, Ei+  JV,> K×, AK\"ÿ+  Jh/ Kó+x 6@ KØ+  Jk!"   +  Jû  KÞ&0  . KT @   P JüA0  5P Jï!"   +  Jû  Jü(Rÿ R Jü $   D J|0d  +  Jú  JüA&  ¿ F J}1&  +  Jw  J}1h  +  Jx!"   +  Jû 
 Jü(Jü J Jü  J|9 Jñ\"ÿ+  Jû,~   |0J}  KU+  Jþ,~   ,> Kz, H$6@ KÚ+  K	, IÍ5B K, H  KÞ..   N KÞ  KØ/2   R KØ2R KY+  KOf KÚ+  K,> K{, I+  K ,> Kz, H$,~     KÞ&0  . KT P K  KØ&,   L K7@ K+  KZ K 8  A.  4N KZ K@r@     K.   Z     K.&     A Kn F    K.(   H K 
 K/*   J K+  K, J,~   zxK  KÕ L KE7@ KE+  KÃ  KE2N KV+  K!\0 L,P KÄ,P KD+  K¢\2 K,R KÄ,R KD  KE0$  0d  b LÕ(D  Z@4F K' @  4F K.  KE0(  0h  b LÕ(H  ,< KD,< KÄ,< @,< @,
,\ KÄ,\ KD+  K4 
 KE0*  0j  b L×(J  ,< KD,< KÄ,<(@,<(@,
,\ KÄ,\ KD  KE2L KV+  K¶6@ K[+  K;  KE3N KV+  K¾  KE00  0p  b LÏ7@@@,+  K¾,< KD,< KÄ,< K},< Ký,
,\ KÄ,\ KD,< KD,< KÄ, a£  KE02  0r  b Ld H?ô R KE+  K,~   @KE  KD   @&, w7 6 Kç,z P  / Kò,~   KL   ?u   ?~x@x@x@    @¬   @µ   @¾   @Ç   @Ð   @Ù   @â   @ë   @ô   AXKà   9.   ?o    
H Kè   pKã       KçxKe	<  xKgx   PKhDED - buffer manager   9·`  AÍpKë  KÉ   KF~8Kmÿ ÿ       N@    >>>>>        B,e          ¯      e  ( ä    2                        ÿhKz            qHKü    H K~ *       H Kÿ         H L >       H LVCreate Error in B!Read      H LVClear Error in B!Read       H LBad call to B!SetM, M =      H LBad call to B!GetM, M =      H LError in B!DeAllocateMark    H LVCreate Error in ExpandGap        H LVClear Error in ExpandGap    H LVCreate Error in B!Make      H LVClear Error in B!Make       H L¢Normal        H L¤No buffers left <       H L§No buffers left >       H LªLookup Failed!  Further editing may be fatal!    H L0Restore Complete        H L3BLAST       H L5Out of buffers in B!Setup    H L¸VCreate Error in RestoreCheckpoint     H L=VClear Error in RestoreCheckpoint      H LÁText     H LCMARKS    H LÄBMODE       H LÆBWS1        H LÈBWS0        H LÊBGSIZE      H LÌBGSTART     H LÎBLOCK       H LÐBMODP       H LÒBSIZE       H LÔBPOINT      H LÖBALIAS      H LØBFILE       H LÚ
Checkpoint file already exists!  Continue at your own peril.       H LbPEA      H LãPjob     H LeBNEXT       H LgOpen Error in B!GtChan!      H LêDSK      H Llx        H LíOut of channels in B!GtChan!  pLð   ?e  H xLò   ?íxLó @  à`Lv   Km   Kí P  
   Ká(Ly7    O@   -    ,>  ,> Y,>  X4+  MÁ   M<   MhL    ¿       @|(MÀ@  Lý@@ MQ8 MX8 M*8 MÀ+  Y   Mß,>  ,> Mã,>  Z4,> Y´,> Y°,> Yµ,Ì B MÞ7@ Y+  M\, h',> Y³,< Z ,< Z!, }~/ Y®  MÞ!*>¹ J     MÞ!., N0   MÞ  MÞ  MÞ  MÞ@h    F    DH  H  R@  
 MÞA*ÿG
 Y.,>  ,> Y¯, {o,> Y´,> Y´,< Z,< Z,< Z,< Z, yÚ 6 Må,z P  / Y­+x MÞ   Ka   MÄ    H Mg             Må    	[x  	X`Y	XHM]   Y MÞx   PMæFEXIT       Pî,>  ,> Pò,>  Z4,< Z",< Z¢\W,\0  ,\7ÿ\W,<?ÿ,<8  \Wþ,\@  ,\Gÿ\Wþ,<Oÿ,<H  \W~,\  ,\ÿ\W~,<ÿ,<  \Wý,\   ,\'ÿ\
Wý,</ÿ,<(  \W},\0  ,\7ÿ\W},<?ÿ,<8  \Wü,\@  ,\Gÿ\Wü,<Oÿ,<H  ,\ Pì,\ Pl,< Pl,< Pì,\ Pë,\ Pk,< Pk,< Pë,\ Pê,\ Pj,< Pj,< Pê,\ Pé,\ Pi,< Pi,< Pé,\ Pè,\ Ph,< Ph,< Pè,\ Pç,\ Pg\  Pç,@ Pæ,@ Pf P Zÿ4B N>ÿ   B PmA Y-1"   +  N0b  -+  N+  NT  Pm1(  +  N0h  +  N+  NT 
 Pm0J  +  N+  N+  PÑ P Z?ÿ5L N+  PÑ P ZOÿ4P N>OÿH   P PmA Y-10   +  N1p  -+  N'  Pm1&  +  N1f  +  N'  Pm1H  +  N' 
 Pm1J  +  N'  Pm1L  +  N'  Pm1N  +  N'  Pm0P  +  N§+  N(+  PÑ  Pm12  °+  N,0r  =+  N,  PmA Y-+  N¬  Pm,< Pf,< Pæ,>  ,
®,\ Pæ,\ Pf 
P Z/ÿ5H N±+  PÑ P Z?ÿ4L N4>?ÿ8   L PmA Y-1,   +  N71l  -+  NA  Pm12  +  N¹1r  +  NA   Pm1@  +  NA  Pm1B  +  NA  Pm1D  +  NA  Pm1F  +  NA  Pm0H  +  NÁ+  N( 
 Pm0J  +  NÃ+  ND+  PÑ P Z?ÿ4L NÆZ Pf5P NG+  PÑ P Zÿ4R NÉ>ÿ   R PmA Y-12   +  NM0r  -+  NM+  NT  Pm1(  +  NP0h  +  NP+  NT 
 Pm1J  +  NS  Pm0L  +  NÓ+  ND+  PÑ  Pm1.  °+  NX0n  =+  NX  PmA Y-+  NØ  Pm,< Pg,< Pç,>  ,
®,\ Pç,\ Pg P Zÿ5D NÝ+  P³ 
P Z/ÿ4H N`>/ÿ(   H PmA Y-1(   +  Nã0h  -+  Nã+  NT  Pm1.  +  Næ0n  +  Næ+  NT  Pm0P  +  Nè+  O  Pm1R  +  Në   Pm0@  +  Nl+  P¦  Pm0B  +  Nn+  P  Pm0D  ­+  Np+  OÊ  Pm1F  +  Ns  Pm0H  +  Nó+  Nt+  PÑ P Z
7ÿ5J Nv+  P³ P ZGÿ4N Nø>Gÿ@   N Pm0N  +  Nú+  O  Pm0R  ­+  Nü+  OÊ   Pm1@  +  Nÿ  Pm0B  +  O +  P¦  Pm0D  +  O+  P  Pm1F  +  O  Pm0H  +  O+  Nt+  PÑ P Z
7ÿ5J O+  P³ P ZGÿ4N O>Gÿ@   N PmA Y-1.   +  O0n  -+  O+  O   Pm1   +  O0`  +  O+  O  Pm0B  ­+  O+  OÊ  Pm1D  +  O  Pm0F  +  O+  P¦  Pm0H  +  O+  P 
 Pm1J  +  O  Pm0L  +  O+  O+  PÑ  Pm1.  °+  O 0n  =+  O   PmA Y-+  O!  Pm,< Ph,< Pè,>  ,
®,\ Pè,\ Ph P Zÿ5D O&+  P³ 
P Z/ÿ4H O¨>/ÿ(   H PmA Y-1(   +  O,0h  -+  O,+  O  Pm1.  +  O/0n  +  O/+  O  Pm0P  ­+  O1+  OÊ  Pm1R  +  O4   Pm0@  +  O´+  P¦  Pm0B  +  O¶+  P  Pm1D  +  O¹  Pm0F  +  O:+  Oº+  PÑ 
P Z/ÿ5H O¼+  P³ P Z?ÿ4L O?>?ÿ8   L Pm0L  ­+  OA+  OÊ  Pm1P  +  OD  Pm0R  +  OÄ+  P¦   Pm0@  +  OÆ+  P  Pm1B  +  OÉ  Pm0D  +  OJ+  Oº+  PÑ P Z'ÿ5F OÌ+  PÑ P Z
7ÿ4J OO>
7ÿ
0   J Pm1*  +  OR0j  +  OR+  OÒ+  PÑ  Pm1.  °+  OÖ0n  =+  OÖ  PmA Y-+  OW  Pm,< Pi,< Pé,>  ,
®,\ Pé,\ Pi P Zÿ5D O\+  PÑ 
P Z/ÿ4H OÞ>/ÿ(   H Pm1(  +  Oá0h  +  Oá+  OÒ  Pm0L  +  Oã+  Od+  PÑ P ZGÿ5N Of+  PÑ P Zÿ4R Oè>ÿ   R Pm12  +  Oë0r  +  Oë+  Ol+  PÑ  Pm1&  °+  Op0f  =+  Op 
 PmA
 Y-+  Oð 
 Pm,< Pj,< Pê,>  ,
®,\ Pê,\ Pj P Z?ÿ5L Oõ+  PÑ P ZOÿ4P Ox>OÿH   P Pm10  +  O{0p  +  O{+  Ol   Pm0@  ®+  O}+  Oý+  PÑ P Zÿ5D Oÿ+  P³ 
P Z/ÿ4H P>/ÿ(   H Pm1H  +  P  Pm0L  +  P+  P¦  Pm0N  +  P+  P+  PÑ P ZOÿ5P P
+  PÑ   Pm1   °+  P0`  =+  P  PmA Y-+  P  Pm,< Pk,< Pë,>  ,
®,\ Pë,\ Pk 
P Z/ÿ4H P>/ÿ(   H Pm0H  +  P+  P+  P  Pm1,  °+  P0l  =+  P  PmA Y-+  P  Pm,< Pk,< Pë,>  ,
®,\ Pë,\ Pk P Zÿ5R P +  P³ P Z'ÿ4F P¢>'ÿ    F Pm1F  +  P¥ 
 Pm0J  +  P&+  P¦+  PÑ  Pm1,  °+  Pª0l  =+  Pª  PmA Y-+  P+  Pm,< Pl,< Pì,>  ,
®,\ Pì,\ Pl P Zÿ5R P0+  P³ P Z'ÿ4F P²>'ÿ    F Pm+  P¦Z
 Pf4J P9,< Pf,< Pæ,> Y²,> Yµ,
Ò\Wü,\0  ,\7ÿ+  PÃ,< Pi,< Pé,> Y0,> Yµ,
Ò,Q(B  	,< Pj,< Pê,> Y0,> Yµ,
Ò B Pí,QA"ÿG Pí,>  ,-\W~,\8  ,\?ÿ,< Pg,< Pç,> Y0,> Yµ,
Ò\W},\@  ,\Gÿ,< Ph,< Pè,> Y5,> Yµ,
Ò\Wý,\H  ,\Oÿ\  Pë\Wþ,@  ,@ÿ\& Pì\W,F   ,F'ÿ\"ÿZ6 Px,z+  Pd,< Z",< Z¢\
W,\(  ,\/ÿ\W,<7ÿ,<0  \Wþ,\8  ,\?ÿ\Wþ,<Gÿ,<@  \W~,\H  ,\Oÿ\W~,<ÿ,<  \Wý,\  ,\ÿ\Wý,<'ÿ,<   \
W},\(  ,\/ÿ\W}\Wü,L8  ,L?ÿ!"   Z6 Px,z+  Pd/ Y¬ P  / Y,+x ~XPí   M_   Mè    H Py
            Px  Pô
h  	] Y	]Pd   Y                            x   xPøFDECOMPOSE      8Pf   Kì   Q@,>  ,> QD,>  Z4 P ,<Gÿ,<@  ,> Q·,> Q7,> Q¶,> Q6,> Qµ,> Q5, Mè4B Q°,< Q;,< Q»,Q B Q?\2 Z¢,R Q¾,R Q>Z Q84D Q,< Z,< Z,< Q8,< Q¸,
,< Z,< Z,
,< Q>,< Q¾,	},\ Q¾,\ Q>,< Q>,< Q¾,< Q9,< Q¹,
,\ Q¾,\ Q>Z Q:4F Q,< Z,< Z,< Q:,< Qº,
,< Q>,< Q¾,	},\ Q¾,\ Q>7@ Q?+  Q¬,> Y«,< Z,< Z, {k3B Q?+  Q¬  Q?(Hw. Y.,>  ,-Z
wÿ,>  ,> Y6,
Ñ,< Z,< Z,	},< Z,< Z,
  Q?A,ÿ. Y.,>  ,-Zwÿ,>  ,> Y6,
Ñ,
,< Z,< Z,
,< Q>,< Q¾,	},\ Q¾,\ Q>/ Y¬,< Q>,< Q¾Z6 QGQ6  ,z+  Q³+  Q³/ Y¬,< Z",< Z¢Z6 QÆ,z+  Q³ P  / Y­+x    Q½   Q¼   Q»   Qº   Q¹   Q¸ Q?   Pn   P|    H QH            QÆ  QF
   
XY
@Q³   Y    x   x QÆQÇFPARSE     8Q8   P{   R,>  ,> R,>  Z4+  QT   QÐy   QÐhQÎ           y0QS@  QM,o B Y 0  @ P Y@r Y,>  ,< Z,< Z,> Y+,> Y´,> Y´,> R,> R,> R, k7@ Y+  Qà,< Z,< Z, _;, i¼!"   Z6 R,z+  R,> Y P ,<ÿ,<  ,> R,),> R,@7@ R+  Qw  QQA(ÿ H R5H Qé,< Z,< Z, _;+  Qó 
 R0J  +  Qm,< Z,< Z, _;+  Qó  R0L  +  Qð,< Z,< Z, _;+  Qó,> R,-,< Yþ,< Y,	}, _;,> Y,> Y´, -!"   Z6 R,z+  R  QÑ(Nò N Y  QS P Y$0   P Y@r Y   Y1`  +  R,< Yù,< Yz, _;, i¼,> Y,> Y´, -!"   Z6 R,z+  R\"ÿZ6 R,z+  R/ Y¬ P  / Y­+x    R   Y   Y   Y   QÐR   Q¿   QÊ    H R
            R  R
!  
@Y
(R   Y    x   0RFLOOKUP  ,>  ,> R?,>  Z4+  R   Ry   RhR           |R@  R,o B Y $  @ D Y@f Y,>  ,< Z,< Z,> Y+,> Y´,> Y´,> R9,> R¸,> R8, k7@ Y+  R),> Y³,< Z,< Z, }~/ Y®, i¼!"   Z6 RÁ,z+  Rµ,> Y 
P ,</ÿ,<(  ,> R·,)7@ R:+  R°,> Y,> Y´, -!"   Z6 RÁ,z+  Rµ,> R¹,@  R L Y$,   L Y\"ÿZ6 RÁ,z+  Rµ/ Y¬ P  / Y­+x    R:   Y   Y   Y   RR:   R	   R    H RÂ
            RÁ  RA
'0  
"8Y
" Rµ   Y    x   }RBFLKUP       RZ,>  ,> R^,>  Z46@ Y+  RH6` Y+  RJ\"ÿZ6 R`,z+  R×6@ Y+  RÑ,> Y3 . M,>  ,> Y³, B Y,> Y 0 M,>  ,> Y2, 2 @ R Y  Y @ RY  Y/&   F Y 
 Y/*   J Y    Z6 R`,z+  R× P  / Y­+x RY   Rº   RD    H Ra
             R`    
+   
(XY
(@R×   Yx   | RàFGETC    ,> Y,> Y´, -,~      S ,>  ,> S,>  Z4,o B Y ,  @ L Y@n Y,>  ,< Z,< Z,> Y+,> Y´,> Y´,> Rþ,> R~,> Rý, k7@ Y+  Rq!"   Z6 S,z+  R{,> Y P ,<Oÿ,<H  ,> R},«7@ R+  Rø,> Y,> Y´, -!"   Z6 S,z+  R{@` Y\"ÿZ6 S,z+  R{/ Y¬ P  / Y­+x    R   Y   Y   YR   RÙ   Rä    H S
            S  S
0   
,`Y
,HR{   Y    x   |hSFENTER      S,>  ,> S,>  Z46@ Y+  S,> Y,> Y´,	Ï,> Y3 " M,>  ,> Y³, B Y WD Y  Y.&   F Y0F @+  S,> Y ( M,>  ,> Y2,w@j Y P  / Yª+x    Rÿ   S	    H S¡             S  S
3  
1(Y
1S   Y 
   x   x Sx S|xS!FPUTC       S»,>  ,> S¿,>  Z4  Y.,  &,   L S:4l S*,> Y . M,>  ,> S:,w,> Y P ,<Gÿ,<@  ,> KX@r Sº,> S¹,í7@ Sº+  S6,> Y´,> Y´,< Yu,< Yõ P ,<ÿ,<  ,
,< Z,< Z,
,< Z",< Z¢, yÚ,> Y,> Y´, -/ Y¬ P  / Y­+x    Sº Sº   S   S#    H SÃ            SB  SÁ
78  
4HY
40S·   Y    x   x SB|SCFCLOSE      Sd,>  ,> Sh,>  Z4 P ,<ÿ,<  , QÊ5B SË!"   Z6 Sê,z+  Sà, H¢ B Sâ7@ Y+  S[, RD B Sc4" SÐ,> Sc, I:+  SÍ, H¢/ Sâ0b   "   B Y7@ Y+  S[,> Y³, I, IÍ4B SX,> Yµ, I+  S[+  SY,> Yµ, I 
 Y/*   J Y+  SS,> Y,> Y´, -6@ 9'+  SÞ,> Sâ, H$\"ÿZ6 Sê,z+  Sà/ Y¬ P  / Y­+x  Sc   S;   SE    H Sl
            Sê  Sj
<@  
8hY
8PSà   Y    x   x Sêw8SëFREAD       T¦,>  ,> Tª,>  Z46 W~+  Sñ  Y LW~6 Wþ+  Só  Y NWþ6 W+  Sõ  Y PW P ,<Oÿ,<H  , QÊ5B Sy!"   +  T$   Y @ KX,> Y,> Y, IV,> Y,> Y´, -, ^g, Ji4B T,< Yñ,< Yr, _;Ob d§,> Y³, d, K@d d§+  T
, Jý4B T
7@ 9,+  T,< Yo,< Yï, _;, J+  T	,< Yì,< Ym, _;,> Y´, d W~/(   HW~7`W~+  T7@ KÚ+  T+  T, IÍ0B  +  T W~/,   LW~,> Yµ, I+  T Wþ/0   PWþ7`Wþ+  T7@ KÚ+  T+  T, IÍ0B  +  T  Wþ/    @Wþ,> Yµ, I+  T W/&   FW7`W+  T"7@ KÚ+  T+  T" 
W/*   JW,> Yµ, I+  T  Y L KÛ\"ÿ+  T$/ Y¬ P  / Y*+x    Sã   Sí    H T1
            T®  T¬
Dh  
=pY
=XT$   Y     
    
    
   x    x  Mx  Mx  Mz T°FLOAD    \. Z¢,N Tá,N Ta@p TbZwÿ4R T6 p    0R  +  TÄZwÿ4D T9 p    1D  +  T¿Zwÿ4F T<>wÿp  ,< Ta,< Tá,>  ,
®,\ Tá,\ Ta+  T7Zwÿ4H TÁ>wÿp  ,< Ta,< Tá,>  ,
®,\ Tá,\ TaZ
wÿ4J TÆ 
p  
  4J TZ6@ Tb+  TÔZwÿ4L TJ p    0L  +  TÔ,< Ta,< Tá,< Yk,< Yë,
,\ Tá,\ TaOn TbZwÿ4P TQ p    4P TTZwÿ4R TÓ> wÿ`p  +  TO+  TÙZ wÿ4@ TÖ> wÿ p  ,< Ta,< Tá,>   ,
®,\ Tá,\ Ta+  TÄ6@ Tb+  TÞ,< Ta,< Tá,< Yk,< Yë,
,\ Tá,\ Ta/ Y¬,< Ta,< Tá+  Tà,~   uxTb  Ta   QÉ,<wÿ,<wÿ, T2,\ U³,\ U3,o B U4,>  ,< Z,< Z,> Y+,> Y´,> Y´,> U²,> U2,> U±, k7@ U´+  Tn!"   +  U/,> U4,< U3,< U³,> U1,)6@ U5+  Tz,> U4,< Yé,< Yj,> Y´,> U1,í,> U4,> Y´, -7@ U5+  Tù,< Yå,< Yf, _;!"   +  U/+  U7@ U5+  T}  U5A&ÿ5F T}+  U  U5A(ÿ,>  ,&,< Yc,< Yã,	},< Y`,< Yà,
, _;,> U4,> Y´, -!"   +  U/,o B U4,>  ,< Z,< Z,> Y+,> Y´,> Y´,> U°,> U0,> U±, k7@ U´+  U!"   +  U/,> U4,<wÿ,<wÿ,> U1,)6@ U5+  U#,> U4,< U3,< U³,> Y´,> U1,í,> U4,> Y´, -7@ U5+  U¡  U5A,ÿ0L  +  U,< YÚ,< Y[, _;+  U  U5A.ÿ,>  ,-,< YX,< YØ,	},< YÔ,< YU,
, _;, i¼!"   +  U/+  U¢\"ÿ+  U/+  U.  U5A0ÿ5P U§,> U4,> Y´, -\"ÿ+  U/+  U.  U5A2ÿ,>  ,&,< YX,< YØ,	}, _;,> U4,> Y´, -!"   +  U/!"   +  U// Y¬,~      Y¶   Y7   U5   U´   Y·   Y8|(U5  U3   Tc   UL,>  ,> UP,>  Z4 P Zÿ4F U»     5F U>\( KK 
P ,H(  ,H/ÿ P ,<7ÿ,<0  , Tã5B UÁ!"   +  UÉ P ,<?ÿ,<8  , Rä5B UE!"   +  UÉ,> Y, J P ,<Gÿ,<@  , S#, ^´\"ÿ+  UÉ/ Y¬ P  / Y­+x    T&   U7    H UÓ
            UÒ  UR
Y@  
WY
VpUÉ   Y    x    m0USFWRIT       Vñ,>  ,> Võ,>  Z4O` 9,@b Y@d Y@f Y F Y F Y 
P Z/ÿ5H UÝ!"   Z6 Vx,z+  Vc P ,<7ÿ,<0  ,> Vh,> Vç,> Vg,> Væ,> Vf,> Vå, Mè5B Ue "  Z6 Vx,z+  Vc\. Z¢,N Y,N Y,< Vì,< Vm,Q B VïZ Vé4P Up,< Z,< Z,< Vé,< Vj,
,< Z,< Z,
,< Y,< Y,	},\ Y,\ Y,< Y,< Y,< Vê,< Vk,
,\ Y,\ YZ Vë4R Uù,< Z,< Z,< Vë,< Vl,
,< Y,< Y,	},\ Y,\ Y7@ Vï+  V,> Y«,< Z,< Z, {k3B Vï+  V   Vï(@w.  Y.,>   ,-Zwÿ,>  ,> Y6,
Ñ,< Z,< Z,	},< Z,< Z,
  VïA&ÿ. Y.,>  ,-Zwÿ,>  ,> Y6,
Ñ,
,< Z,< Z,
,< Y,< Y,	},\ Y,\ YZ
 Ví4J V>
 Ví
 Vn J Vî\, Z¢,L Y,L Y  Vî1N  +  V  Vî1P  +  V+  VaZ Ví4R V  Vn  0r  +  V+  Va\  Z¢,@ Vi,@ VèZ Ví4D V&Z Ví4F V  Vn    9.'ý   A Y±5F V +  V&Z
 Ví4J V¢>
 Ví
 Vn,< Vè,< Vi,>  ,
®,\ Vi,\ Vè+  V,< Vè,< ViZ Vè,< YS,< YÓ,>  ,> Yµ,
Ñ,
v4B V,@n 9,+  V^,< Vè,< ViZ Vè,< YÑ,< YR,>  ,> Yµ,
Ñ,
v4B V2Or Y+  V^,< Vè,< ViZ Vè,< YP,< YÐ,>  ,> Yµ,
Ñ,
v4B V8Of Y+  V^,< Vè,< Vi,< YÎ,< YO,
v4B V½,> Vå,> Ve,  B Y+  V^,< Vè,< Vi,< YM,< YÍ,
v4B VC,> Vå,> Ve,  B Y+  V^,< Vè,< Vi,< YË,< YL,
v4B VÈ,> Vå,> Ve,  B Y+  V^,< Vè,< Vi,< YJ,< YÊ,
v4B V[Z Ví4H VÍ> Ví Vn H VðZ
 Ví4J VÚZ Ví4L VQ> Ví Vn L Vp3L Vð+  VÚ,< Y,< Y,> Vp,
®,\ Y,\ Y  Vp0N  +  VZ,< Y,< Y,> Y4,
®,\ Y,\ Y+  VN+  V^Z Vè4P V^ "  Z6 Vx,z+  VcZ Ví4R V`> Ví Vn R Vî+  V!"   Z6 Vx,z+  Vc/ Y¬ P  / Y­+x    Vo   Vn   Y   Vm   Vl   Vk   Vj~pVð   UË   UU    H Vú
            Vx  V÷
n  
ZhY
ZPVc   Y    x   x  Mx
 Vxx  MwVzFSCAN      0Vè   U6,>  ,> WJ,>  Z4,< YÈ,< YI,> WÁ,,\ WÂ,\ WB6@ WE+  W,> Y´,> Yµ,> Yµ,Ì B WD   !&Y F    WD@j    WDA,ÿG Y©,>  ,> Y), {o 6 WM,z,< YG,< YÇ,> WÁ,,\ WÂ,\ WB7@ WE+  W#,> Y´,< YÅ,< YF, {k." t,>  ,&,> Y5,> Y6,
Ò,< YÃ,< YD,
,\ WÃ,\ WC,< WC,< WÃ, R5B W,< Z",< Z¢Z6 WL,z+  W@\. Z¢,N WÂ,N WB, RD B WÄ1"  +  W¢,< WB,< WÂ,> WÄ,
®,\ WÂ,\ WB+  W, Rb\0 WÂ,P Y,P YZ WB4R W¦  WÂ    9.ý H  A Y±4R W«Z WB4F W+>  WB` WÂ+  W¤Z WB4H W­  WÂ   
 9./ý    A Y14H W²Z WB4L W2>  WB` WÂ+  W«Z WB,< WB,< WÂ,> Yµ,>  ,
ÒZwÿ4P W7p  / Y¬0p  +  W½Z WB/2  ,< WB,< WÂ,>  ,> Yµ,
Ò,\ WÂ,\ WB+  W²,< WB,< WÂZ6 WL,z+  W@ P  / Y­+x    WE~xWE   Vq   Vü    H WÎ             WL    
x`  
o`Y
oHW@   Yx   x  M WDx WLz8WNREADTMPFILE      WB   V|,>  ,> X,>  Z4Ob W}
,  ab  @@ W}6@ W}+  WØ,< Z",< Z¢Z6 X,z+  Wù
0   , ¨,\ Wû,\ W{\  Z¢,@ Wü,@ W|\" Wû,B Y,B YZ W{4D Wß  Wû    9.ý   A Y±4D WçZ W{4H Wd> W{ Wû,< W|,< Wü,>  ,
®,\ Wü,\ W|+  WÝZ
 W{4J Wé 
 Wû
    9.
7ý 
(  A
 Y14J WîZ W{4N Wn>  W{` Wû+  Wç,< W|,< WüZ W|,< YB,< YÂ,>  ,> Yµ,
Ò,
v5B Ww,< Z",< Z¢,\ Wû,\ W{\2 Wû,R Y,R Y,< W{,< WûZ6 X,z+  Wù P  / Y­+x W}   WÅ   WQ    H X             X    
`  
z(Y
zWù   Yx   0XRESCANCOMMANDLINE     W{   WÐ+  X   Xy   XhX
           zXX@  X,> Y¨,> Y(, {o! Lõ @ X  Y§ B X@d X@f X  Y' H X@j X , X,>  ,> Y¯, {o,> Yµ,> Y4, {o,~      X,> Y¦,< Z,< Z, {k B X;,> Y&,< Z,< Z, {k B X:2B Y¥+  X +  X9  X;A0 @ 5P X,  X:(Rw1R _+  X,   X:(@w1@ ;ª+  X,  X:3B Y%+  X,  X:3D Y¤+  X,  X:3F Y$+  X,,> Yµ,> Y4, {o,> Y£,< Z,< Z, {k B X¹3B Y'+  X5  X¹3H Y#+  X5 
 X¹3J Y¢+  X5  X:(Lw1L  +  X5, X,> Y",< Z,< Z, {k B Xº3B Y¡+  X9, X,~   {X;   Xe,>  ,> Xi,>  Z47@ u²+  XA, Vü,\ Xc,\ Xâ+  XE, WQ,\ Xc,\ XâZ Xâ5N XE, Vü,\ Xc,\ Xâ, XZ Xâ5P XHZ6 Xk,z+  Xà,< Xâ,< Xc, UU B Xd4B XÜ, i¼  Xd0R  +  XT,> Y³,< Z ,< Z!, }~,< Xâ,< Xc, }~,< Y¿,< Y@, }~,< Z ,< Z!, }~/ Y®+  X[,> Y³,< Z ,< Z!, }~,< Y¼,< Y=, }~,< Xâ,< Xc, }~,< Z ,< Z!, }~/ Y®,> Yµ,> Y4, {oZ Y4D Xà,< YG,< YÇ,< Y,< Y,> Xb,9 P  / Y­+x    XãXd   Wý   X<    H Xl             Xk    P  XY@Xà   Yx   |`XëFRPG  Xâ   X   Xÿ,>  ,> Y,>  Z4Z Y4F Xú,< Y,< Y,< Y,< Y, FÍ,< Y,< Y,> Y,> Y,> Y, Sí4B Xø  Y H KÛ+  Xz,< Yº,< Y;, _;+  X},< Y¸,< Y9,< Z",< Z¢, FÍ@j K[ P  / Y­+x    Xä   Xn    H Y             Y    x  xY`Xý   Yx    @YFINIT    , w7 6 Y,z P  / Y/,~   xY   MXY   X   L{    H Y   pY       YxYp  xYx   XYDED - File I/O    Y   Xm}HY ÿa0 x     }õv3R!ì(o  ;7öx    ip æB,e          8   (    x   P    ï                                       @        ÿ    hY´            y`Y8    H Y¹NONAME.TXT    H Y»New File      
H Y½? Bad command line:     H YÀ [Bad FileSpec]    H YCPEAK     H YÄEDS.TMP       H YÆPJOB     H YHEDS      H YÉEDT      H YKS        H YÌC        H YNL        H YÏP        H YQRPG      H YÒREAD     H YTNulls    H YÕ creating Backup file        H YY? Rename Error     H YÛ? Protection Failure creating backup file        H Ya for BACKUP file        H Yd? Lookup Error     H Yæ? Couldn't Delete Backup File     H YêyYê    H Yl.BAK     H YíNulls Exist        H YpRemoving Nulls     H YòRemoving sequence numbers    H YvCannot apply protection to file (      H Yú? File is too large to edit with PEAK       H YÿCannot LOOKUP File, error         H ZFile is Protected       H ZBad FileSpec       H Z	Nonexistent File        H Z? Can't open DSK:       H ZDSK      H Z]        H Z,        H Z[        H Zgettab        H Z.        H Z)        H Z(        H Zx        H Z??? Unable to run RPG - contact SQA    H Z¡
   pZ"   Lq  H xZ$   LùxZ% @  à`Z§   Y    Y! P  
   Y~pZª7    O@   -    ,>  ,> d¬,>  X4+  ]   Z4})   Z&                          Ñ ]@  Z/@@ Z4Q8 Z4X8 Z´*8 ]+  ^   ]   ]                    
       xt^@  ]@@ ]Q8 ]X8 ]*8 ^+  d (   H pg,> d,> d¹,	Ï, `k,> d: * Z4,>  ,> d;, B d¢  pg/,   L d#0,  0l  b dï$,  ,> d: ,0Z¦,>  ,> d;, B d$  pg N d£0.  0n  b dï$.  ,> d: .8Z¦,>  ,> d;, B d¥@p d@r d@` d  pg/$   D d¡@f d"\( dn,H d,H dOl d,~   7@ 9+  ^(,>ÿ,&,< dë,< dl,	},< dé,< dj,
,> d,&,
, a£7@ d+  ^ª ÿ N d +  ^« ÿ P d  ÿ R d!/ d9+x Zwÿ4D ^3Zwÿ4F ^°>wÿp  G 	ÿ.(   Iÿ+  ^­/ d9/ d¸+x  
 d¤ J ^f  d% L ^æ7@ KZ+  ^»7@ KÚ+  ^»,< dh,< dè,> ^ä,> ^d, ^­+  ^I7@ KZ+  ^¿,< dæ,< dg,> ^ä,> ^d, ^­+  ^I7@ KÚ+  ^Ã,< dä,< de,> ^ä,> ^d, ^­+  ^I, H,>  ,&,> ^ä,> ^d, ^­,< dc,< dã,> ^ä,> ^d, ^­,< dá,< db,> ^ä,> ^d, ^­7@ K[+  ^O,< d`,< dà,> ^ä,> ^d, ^­@@ ^e@@ ^å\"  	b  @   `B  O@ ^å`b  O@ ^e6@ ^å+  ^Õ7@ ^e+  ^X,< dÞ,< d_,> ^ä,> ^d, ^­7@ ^e+  ^Û,< d],< dÝ,> ^ä,> ^d, ^­7@ ^å+  ^_,< dÛ,< d\,> ^ä,> ^d, ^­  ^æ2n ph+  ^ã,< dZ,< dÚ,> ^ä,> ^d, ^­+  ^_,~      ^æ   ^fup^æ  d$ P _8@r _¸,< dØ,< dY,> _·,> _7, ^­Z d8   (Dò,>  ,-,< dZ,< dÚ,	},> _·,> _7, ^­Z d8   (FwA& ÿ,>  ,-,< dÛ,< d\,	},> _·,> _7, ^­Z d8    A(ÿ,>  ,-,< dW,< d×,	},< dÕ,< dV,
,> _·,> _7, ^­,< dW,< d×,> _·,> _7, ^­,< pÝ,< p^,> _·,> _7, ^­,< dZ,< dÚ,> _·,> _7, ^­,< KÉ,< KJ,> _·,> _7, ^­7@ 9ª+  _,< dT,< dÔ,> _·,> _7, ^­7@ 9*+  _,< dÒ,< dS,> _·,> _7, ^­,< dQ,< dÑ,> _·,> _7, ^­, F5 B _9A"ÿ B _¹ 
 _9(Jw J _94J _ ,   L _º2l _9+  _,< dÏ,< dP,> _·,> _7, ^­  _º9 _,< dZ,< dÚ,> _·,> _7, ^­Z KË4N _  KL  4N _¢,< KË,< KL,> _·,> _7, ^­+  _%,< KÊ,< KK,> _·,> _7, ^­7@ KÛ+  _¨,< dN,< dÎ,> _·,> _7, ^­7@ _¹+  _±,< dZ,< dÚ,> _·,> _7, ^­ 0   P _:2p _¹+  _±,< dÌ,< dM,> _·,> _7, ^­  _:9 _¬,< dK,< dË,> _·,> _7, ^­  _8 R d¤   _¸ @ d%, ^´,~      _¸   _8z0_º7@ d+  _ä, ^´ $   D _h0d  +  _E  d£0&  0f  b dï$&  0$  0d  d dï.    d¹ HZ&  _h9 _= 
 d¥ J _i@d _hZwÿ4L _cZwÿ4N _É>wÿp   N _è1.  +  _N  _è00  ¿+  _N  _èR _i+  _ß   _è0@  +  _V7@ 9©+  _R "  B _i+  _Õ $  /D _i &  ­F _i 
 _h.*   J _h+  _ß ,  /L _i6@ _è+  _Ù .   N _i+  _^  _è0P  ¿+  _Ü 2  R _i+  _^   _è.    @ _i  _h.&   F _h 
 _h.*   J _h3* ph+  _â+  _c+  _Æ  _h L d&+  _g,> d;,<wÿ,<wÿ, }~/ d·/ d9,~   }x_i   _|,>  ,> ` ,>  Z4  d¥ N _z P ZOÿ P _ú $   D _{  ph/ _ú/&  2d  +  _s` _z9 _o P Z
7ÿ4J _x P ZGÿ4N _w>Gÿ@  N _z+  _s/ d9 P  / d7+x _{   Y   _j    H `            `  `@  }8d¨} _x   d®    x   yx`WMSG2      d0R  +  `,> KÜ, Hà+  `,> K\, Hà+  `	,~      d0@  +  `,> KÜ,>, Hø+  `,> K\,>, Hø/ d9+x   d0B  +  `  d"+  `+  `  d¡+  `,~   , `&"   B `6 $   D `µ &   F `5, H¢ B `4  `µ2( `6+  `ª@j `´7@ KZ+  `+  `ª,> d;, I, IÍ B `´0B  +  ` +  `ª+  `&  `´0L  +  `¤  `µ..   N `µ 0   P `5+  `&  `5.2   R `5   `52@ ph+  `*  `µ."   B `µ $   D `5+  `  `´1F  +  `­  `´0H  +  `/,> d<, I+  `16@ KZ+  `1,> d<, I, H¢,>  , `,> `4, H$,~   |x`6,>  ,> `V,>  Z4 
 d¡.*  0*  0j  b dï$*  ,> d: *(Z¦,>  ,> d;, B `P\, dñ,L `Ï,L `O@n `Q  `Q20 ph+  `ÍZ `O5R `Ä\  d,@ `Ï,@ `OZ `O4B `Æ> `O `Ï B `Ð1"  +  `É  `Ð1d  ?+  `Ê &   F `Ð  `ÐH `P 
 `Q.*   J `Q+  `À P  / d7+x `Q   _û   `¶    H `Y             `X    
    d¨h`Í   d®x   }x`ØBUILDBAR    `O   Y    `c,>  ,> `g,>  Z4 W L d6@W+  `a7@ d+  `a, `¶ P  / d¶+x    `Ñ   `Û    H `j             `é  `i0  Pd¨8`a   d® 
   |p`éWBSET    ,> d,> d¹,	Ï .   N a0n  +  `u0.  0n  d dÉ  a00  0p  d dÉ  d6 R@] @] P8]  a9 `m $   D a0d  +  `þ0$  0d  
b dÉ$$    dµ F]  a0(  0h  
b dÉ$(   
 d5 J ]  a9 `õ  d´ L ]ÿ L ]  d4 N ^ N ] 0   P d,~   |a ÿ12  +  a  ÿ1`  	+  a,> d»,> d»,>þ,&,< dF,< dÆ,	},< dÄ,< dE, yÚ "  .ÿ   0$  0d  
b dÉ$$  ,> d: $],>  ,> d;, B a#` a#` a# *   J a"  a"0l  +  aZwÿ4N aZwÿ4P a>wÿp   P a¢10  +  a  a¢1r  ?+  a     @ a¢  a¢B a#  a".$   D a"+  a ÿ F d/ d9/ d9+x {xa#  d.(   H d0(  +  a¨,> d,<wÿ,<wÿ, a+  aC *   J aD0j  	+  a¹ ,   L aÄ0l  +  a¸  aD0.  0n  
b dÉ$.  0,  0l  d dÉ.   0  . aD00  0p  
b dÉ$0    aÄ02  0r  d dÉ.   H] R0]  aÄ9 a+ 
 aD9
 a) $   D aÄ0d  +  a?0$  0d  d dÉ  d¹ F]y  aÄ9 a:  dµ H ]ù 
 d5 J ],> dº,<wÿ,<wÿ, a/ d9,~   jPaÄ@l bp, H¢ B bt6@ÿ+  aL,> K\, Hà,>  , H$ .   N bñ  d¡ P bó+  aÐ,> KÜ, Hà,>  , H$  d¡.2   R bñ   d" @ bó  bñ D br  bñ. bó/&  2d  +  aÝ (   H bò0h  +  aÜ 
 br0*  0j  b dï$*  0(  0h  d dï.    d¹ L Z&  bò9 aÔ  br9 aQ  bñ0.  0n  b dï$.  ,> d: .8Z¦,>  ,> d;, B bs 0   P bq  bq32 ph+  b@` bô  bq2B ph+  aê, IÍ1B  +  aê $  >D bs+  ax, H¢2B bt+  ap ÿ2F d+  apOh bp 
 bñ J d¦  bq L d',> d<, I, IÍ0B  +  at,> d<, I+  a÷7@ 9¬+  aö .  /N bs+  a÷ 0  P bsO` bô6@ 9ª+  b
6@ bô+  b
, H¢2B bt+  aÿ ÿ2B d+  aÿOd bp  bñ F d¦  bq H d'7@ KÚ+  b+  bm, IÍ B bð,> d<, I 
 bð0J  +  b+  bm  bð0L  +  b, IÍ0B  +  b	,> d<, I+  b
+  az  bó/0   P bó5P b+  bm   bñ.    @ bñ    0$  0d  b dï$$  ,> d: $Z¦,>  ,> d;, B bs &   F bq, H¢2B bt+  b ÿ2H d+  bOj bp  bñ L d¦  bq N d'7@ KÚ+  b+  bm, IÍ B bð,> d<, I  bð0P  +  b9, IÍ0B  +  b&, H¢2B bt+  b¤Or bp   bñ @ d¦  bq B d',> d<, I+  b®7@ 9¬+  b© $  /D bs &  ¦F bs+  b®  bq2( ph+  b­` bs  bq..   N bq+  b© 0  P bs   bó/    @ bó5@ b1+  bm  bñ.&   F bñ0&  0f  b dï$&  ,> d: &Z¦,>  ,> d;, B bs (   H bq+  bì 
 bð0J  +  bÈ ,  /L bs .  &N bs7@ 9«+  b>+  bm  bó/2   R bó5R bÀ+  bm  bñ.&   F bñ0&  0f  b dï$&  ,> d: &Z¦,>  ,> d;, B bs (   H bq+  bì 
 bð0J  +  bÑ7@ 9&+  bÑ  bq& 9&4R bO` bs  bq.&   F bq+  bK` bs  bq.,   L bq+  bì  bð0N  +  bW7@ 9©+  bW 0  P bs   bq.    @ bq+  bì  bð1"  +  bZ  bð0D  ¿+  bj  ph/&  2F bq+  b` (  >H bs  bq.,   L bq,> d;, I+  bé .  /N bs6@ bð+  bã 0   P bs+  bh  bð0R  ¿+  bæ    @ bs+  bh  bð."   B bs  bq.&   F bq+  bì  bðH bs  bq.,   L bq+  ad,> bt, H$  bp+  bo/ d9+x zPbô,> d, aE5B bw, `,~     d 2N d!+  c,> d», aE5B c6@ d+  c, bu, ^´,> d», aE5B c,> d»,> d»,< dB,< dÂ,< dq,< dñ, yÚ7@ d+  c  d 2P d!+  c,> d<, aE5B c  d0R  +  c, bu, ^´,> d<, aE5B c,> d»,> d»,< dB,< dÂ,< dq,< dñ, yÚ7@ d+  c $   D c 0d  
+  c &   F c 0f  +  c (  . c 0(  0h  b dï$(  .&  0&  0f  d dï.   
 c 0*  0j  
b dÉ$*    c 0,  0l  d dÉ.   0] LZ&  c 9 c  c 9 c,~   |hc    c´,>  ,> c¸,>  Z47@ d+  c¥, i¼+  c²On d 0   P d  d  R d  
 d¡&*   J d"/
 d¡"
  /*   J d¡,> KÜ,> K\, Hà,>  , Hø, `¶, H¢,>  , H­7@ 9+  c²,< d¿,< d@, a£ P  / d7+x    `â   c¡    H c;             cº    6H  40d¨4c²   d®|`cºW2     cÎ,>  ,> cÒ,>  Z46@ d+  c@, i¼+  cÌ@l d  d0N  +  cÇ  d 2P d +  cÆ,> K\,> KÜ, Hà,>  , Hø+  cÇ  d  R d ,> KÜ,> d³, Hø@` d @b d  d¡. d".$   D d¡@f d" P  / d7+x    c4   c<    H cÕ             cÔ    9h  7Xd¨7@cÌ   d®x   {@cUW1  6@ d+  cX, i¼+  cå7@ d+  cß  d¡1h  +  cÞ 
 d¡/*   J d¡  d".,   L d", `¶+  c_, i¼+  cå  d"1n  +  ce  d"/0   P d"  d¡.2   R d¡, `¶+  cå, i¼,~      cú,>  ,> cþ,>  Z46@ d+  cë,< d¼,< d=, _;+  cx   d 2@ d +  cs, H¢ B cù, H«,>  , H$,> cù, H­ "  / d B d, ^g+  cx $  / d D d5D cö,> d , F+  c÷,> d , F, ^g P  / d7+x cù   cN   cæ    H d             d    ?(  = d¨<hcx   d®x   }(dWSWITCH     d,>  ,> d,>  Z4, N5B d, b÷7@ d§+  d,> d,>W,> pg  d&.&  ,>  , nÒ+  d,> d,>W,> d¦,> d', nÒ P  / d¶+x    cz   d    H d             d  dB   @Hd¨@0d   d® 
   x    @dWDISP    , w7 6 d®,z P  / d¸,~   pd   Z4   ]Xd§   d   Z¬    
H d¯   pdª       d®xd,E  xd.x   Pd/DED - window manager  d   `Ú~xd²ÿ----++----    !!    -----  (            ¯                   	ÿy0d»        
H d½Window is not split.    H dÀ[split screen]     H dCW!Set lost big!    H dÅx        H dGBad call to W!BMsg, Line=    H dÊWBOX    H dL -       H dÍ>        H dO $       H dÐ<        H dR)        H dÓ,Over    H dU,Wrap    H dÖ)        H dX (       H dÙPEAK     H d[         H dÜ.        H d^!        H dß Mail    H da *       H dâ-        H dd%        H dåBottom        H dçTop      H diEmpty    H dê), W!Num=     H dìW!SetB(       H dî+-------      H dðWBUFpdq   Z¢  H xds   Z+xdt @  à`dö   d²   d3 P  
   d¨(dù7    O@   -    ,>  ,> põ,>  X4+  e   eî   ehdÿ           oxe@  d~@@ eQ8 eX8 e*8 e+  e5   e^xe            x     H q    H qþ    H q~    H qý    H q}    H q|    H qû    H qú    H qz    H qù    H qø    H qx    H q÷    H qö    H qv    H qu    H qô    H qt    H qó    H qs    H qò    H qr    H qñ    H qq    H qp    H qï    H qo    H qn    H qí    H qm@  e pe   d2+  eØ   e9^xe¸            x     H q    H q    H q~    H q~    H q~    H ql    H ql    H ql    H ql    H ql    H qk    H qk    H qk    H qk    H qk    H qj    H qj    H qj    H qj    H qs    H qò    H qò    H qñ    H qñ    H qp    H qp    H qp    H qi    H qm    H qm@  eµ pe9   e´+  el   eÜm   e\                                                                                                                                       @  eY+  eÿ   epm   eï                                                                                                                                       @  eì+  f   fm   f                                                                                                               xxf        @  f +  f¦   fm   f                   (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (    (@  f+  f:   fªm   f*                                                                                                                                       @  f'+  fÍ   f>m   f½                                                                                                               }`fK            @  fº+  fa   fÑm   fQ                                                                                                               fÞ            @  fN+  fô   fem   fä                       0fg                                        `fî                (fò        @  fá+  g   føm   fx               Xf}                    pg        ~Hg@  fu+  mÕZ g2(ÿ+  g,< g,< g,> q,
®,< g,< g,
,\ g,\ g+  g,< g,< g,>ÿ,> q,
Ò+  g/ q+x ~ g  g   eX *   J g"0j  +  g ,<wÿ,<wÿ0*  0j  b qg(J  Zwþ,<(e,<(e,>  ,> q,
Ò,
v4B g  g"+  g! 
 g"9
 g\"ÿ+  g!/ q,~   rhg"7@ÿ+  g-On h,> q,>  ,> q, ,>  ,q,\ h,\ h,< h,< h,< qe,< qå,
n4B g¬\0 r ,P h,P h+  g®\2 r ,R h,R hZ h4D g°  h  5D g¿,> q,< qâ,< qc, }~/ q7@ pf+  g>, h_ B h1B  +  g½  h1F  +  g½,< h,< h,> h,
®,\ h,\ h,> q,> h,> q, +  g´+  g¿, ¨,\ h,\ h,< h,< h, g B h4b gá  h0(  0h  b qà  e\ H pæ 
 h0*  0j  b qÞ(J  \*(e¸,J p^,J pÝ  h0,  0l  b qÜ 0eï L pg  h0.  0n  b qÚ 8f N pç  h00  0p  b qØ @f P ph  h02  0r  b qÖ Hf* R pk  h0$  0d  b qÔ f½ D pê  h0&  0f  b qÒ fQ F pë 
 h0*  0j  b qÐ 
(fä J pj  h0,  0l  b qÎ 0fx L pé+  h,< h,< h,< qM,< qÍ,
n5B gç,< h,< h,< qË,< qL,
v4B h,> q,< qÇ,< qH, }~/ q .   N h0n  +  g~0.  0n  b qÞ(N  ,<8e8,<8e¸,< h,< h,
v5B g},> q,< qF,< qÆ, }~  h00  0p  b qÞ(P  ,<@e8,<@e¸, }~,< qÄ,< qE, }~/ q  h02  0r  b qÞ(R  \2He¸,R h,R h  h9 gê,> q,< qÄ,< qE, }~/ q+  h	,> q,< qA,< qÁ, }~,< h,< h, }~,< qÄ,< qE, }~/ q,> q,< q»,< q<, }~/ q\  r ,@ h,@ h+  g®/ q+x }h  h   g   h,>  ,> h",>  Z4,> q, g¢O   
,   B pll"  H
.  \"  B f@@ pì\"  B pì+    ,> q " e,>  ,> q, B pm@d píOh pf P  / q+x    d(   h    H h¥             h$    `  pñxh   p÷x   x h$}@h%TINIT       h3,>  ,> h7,>  Z4,> pg,> q, iê, hòQ"  X"  	b  +      pl
.  \"  B   +    \"  B pì+     P  / q+x    h   h'    H h:             h9    0  pñph1   p÷x   }hh¹TFINI       hÄ,>  ,> hÈ,>  Z4O   
,  l"  H
.  \"  B f@   \"  B  +     P  / q+x    h²   h»    H hL             hÊ    H  Ppñ8hÂ   p÷x    x   ~hhËTRSET       hÖ,>  ,> hÚ,>  Z4\"  B   k  O    B hÕ  hÕZ6 hÜ,z+  hT P  / q+x hÕ   hD   hÍ    H hÝ
             hÜ    
h  	ppñ	XhT   p÷x   ~Hh]TCHRP       hj,>  ,> hn,>  Z4\"  B  +  hc+  hä\"   B  +    A$  ¿ D hi  hiZ6 hp,z+  hç P  / q+x hi   hV   h_    H hñ
             hp       pñphç   p÷x   x hp}HhqTGETC    !*   J pm,> q , e,>  ,> q,',> q . e,>  ,> q, B pm@p pí,~   Zwÿ. pí02  ¾+  iZwÿ4D iZwÿ4F h>wÿp   F iF pm 
 pí.*   J pí+  h|+  i, hò+  i   i{   ihi           i@  iZwÿ B i p   B i,> q , i,>  ,> q,'/ q,~      i}pi  pí0N  >+  i, hò ÿP pm   pí.    @ pí/ q+x \" r ,B i ,B i 7@ÿ+  i ÿ&0  .2  ,>  ,< i ,< i ,
­,\ i ,\ i  ÿ&0   Pÿ+  i,< i ,< i , hz/ q+x cXi   i    h,< q:,< qº, hz 1r  +  i&,>, i  ÿ1`  +  i©,> q, i,>ÿ, i,> q, i/ q +x  ÿ0"  +  i7 ÿ0D  +  i0 &   F pi+  i¶ ÿ0H  +  i³  pè.,   L pè+  i¶ ÿ0N  +  i¶  pi/2   R pi+  iº  pi.&   F pi3f ph+  iº\(| H pi,>ÿ, i/ q+x ,> q,> q,> q, ,~    *   J pè ,   L pi  pæ0.   0.  +  iW+8iR,< q¸,< q9, hz+  i×,< q¶,< q7, hz+  i×,< q5,< qµ, hz+  i×,> q, i+  i×,> q, g,< q3,< q³,	}, hz+  i×,> q, i+  i×,< q±,< q2, hz+  i×5 i×5 iÃ5 iÅ5 iÇ5 iÉ5 iK5 iK5 iÎ5 iÃ5 iP,É,~     pæ00   00  +  ié+@iä,< q0,< q°, hz+  ij,< q®,< q/, hz+  ij,< q-,< q­, hz+  ij,< q0,< q°, hz+  ij,< q«,< q,, hz+  ij5 ij5 iÚ5 iÚ5 iÜ5 iÚ5 iÞ5 iÞ5 ij5 ià5 iâ,É,~     pæ02   02  +  j+Hj  .   ,< q*,< qª,>   ,
® ÿ."  ,>  ,
®, hz+  j,< q¨,< q), hz /$  ,>  , i,> pÿ, i ÿ/&  ,>  , i,> p, i+  j .(  ,< q',< q§,>  ,
® 
ÿ.*  ,>  ,
®, hz+  j,< q:,< qº, hz,>, i,> q, i,>ÿ, i,> pþ, i+  j5 j5 im5 is5 i{5 im5 j5 j5 i{5 im5 im,É  L pè ÿ N pi/ q +x   pæ00   00  +  j*+@j¦+  jª,< q¥,< q&, hz7@ÿ+  j,> q
, i  ÿ/    @ÿ+  j,< q$,< q¤, hz+  jª7@ÿ+  j,< q¥,< q&, hz ÿ/&   Fÿ+  j+  jª,< q¢,< q#, hz7@ÿ+  j¤,> q
, i 
ÿ/*   Jÿ+  j ,< q!,< q¡, hz+  jª5 jª5 j5 j5 j5 jª5 jª5 j,É/ q+x   pæ0,   0,  +  j@+0j¼+  jÀ7@ÿ+  j3,< q,< q , hz ÿ/0   Pÿ+  j®+  jÀ7@ÿ+  j8,< q,< q, hz  ÿ/    @ÿ+  j³+  jÀ,< q:,< qº, hz,>ÿ, i,> q, i+  jÀ5 jÀ5 j.5 j®5 j³5 jÀ5 jÀ5 j¸,É/ q+x   pæ0$   0$  +  jÝ+jØ,< q,< q, hz+  j^,< q,< q, hz+  j^,< q,< q, hz,> pè,> pg, i",< q,< q, hz,> q, g,< q,< q,	}, hz,> q,> pg, i",< q,< q, hz+  j^,> q, g,< q,< q,	}, hz+  j^,< q,< q, hz+  j^5 j^5 jD5 jD5 jF5 j^5 jH5 jS5 j^5 j^5 jÖ,É,~     pæ0&   0&  +  jý+jø,< q,< q, hz+  j~,< q$,< q¤, hz+  j~,< q,< q, hz,> pè,> pg, i",< q,< q, hz,< q:,< qº, hz,> pg, i,> pþ, i,> q, g,> q,
­, hz,> q,> pg, i",< q,< q, hz+  j~,> q, g,< q,< q,	}, hz+  j~,< q,< q, hz+  j~5 j~5 ja5 ja5 jc5 j~5 je5 js5 j~5 j~5 jö,É,~      k})   jõ                          ÑmÔ@  jþ@@ kQ8 kX8 k*8 mÔ+  mè   mÛï   m[               mç@  mX@@ mÛQ8 mÛX8 m\*8 mç+  mû   mîï   mn               |0mú@  mk@@ mîQ8 mîX8 mo*8 mú+  pÚ   n,>  ,> n,>  Z4@h pî *   J po ,   L pï, i? .   N pp0n  +  n 0   P pð0p  +  n  pp$2  .     p~ @Hjõ9 n  pp9 n $   D pp0d  +  n  pn Fm[  pp9 n P  / q+x    hé   mþ    H n             n    b  ` pñ_hn   p÷x   xpnRINIT      pp3( pè+  n6  pi+  n,> pp,> pð, iê+  nÐ 
 pp3j pè+  n«  pp/ pè  pð/ pi#  .   L nÑ3l pk+  n&,> pp,> pð, iê+  nÐ  pp/ pè P nÑ7@ nÑ+  n«,> q, i«  nÑ/2   R nÑ+  n§   pi2@ pð+  n.+  nÐ+  nÐ  pð2" pi+  n¸  pi/ pð D nÑ2$ pk+  n¶7@ nÑ+  n6,> q, i«  nÑ/&   F nÑ+  n2+  n8,> pp,> pð, iê+  nÐ  pð/ pi H nÑ2( pk+  nO 
ÿ  pp2,/~2l/þb q$/ .  2./ü2n/}d q./|,> q ,0 ,>  ,> q, B nR  pi P nÑ7@ nÑ+  nH` nR   nÑ/    @ nÑ+  nÄ  pð/ pi B nÑ7@ nÑ+  nÎ$ nR,>  , i«` nR  nÑ/(   H nÑ+  nÉ+  nÐ,> pp,> pð, iê/ q+x `hnR7@þ+  nU, hÍ4B nU+  pK,>~,> q,	¼ B pV,>~,> q	,	¼ B pÖ@j pn ,   L pÎ2l pÖ+  n^  pn(.  F p~ N pn9 nZ 0   P pÎ2p pV+  ní@r pÙ $   D pZ2d pÖ+  nk  pÙ(&   ~ 
 pÎ2*'~2j'þb q$
'2$'ü2d'}d q.  .'|F   F pÙ  pZ9 na  pÎ  pÙ N0mn  pÎ9 nÞ7@ pj+  oq@p pO@r pÏ   pg/        D pÎ1$  +  nx  pÎ m[3Dmn+  nw  pÎ H pO  pÏ.,   L pÏ  pÎ= nq7@ pÏ+  o ~  pO20?~2p?þb q$? 2  22?ü2r?}d q.?|  pO$$   @ 2Pjv+  o  pO.(   H pO  pÏ/,   L pÏ  pÏ0n  +  o+  oq  pg/0  / pO P pÐ@r pS@` pT/0   P pÑ"P pR  pÑ D pÒ3$ pR+  o§  pO F pÔ4d o 
 pÔ.
 pÒ J pÔ  pO L pU6  pÒ+  o  pU/ pÒ P pU# pÒ/ pÐ"R pQ@` pÓ $   D pP2d pQ+  o#  pU  pÔ m[2F mn+  o 
 pU 
(m[2J pn+  o  pÓ. pî N pÓ+  o  pÓ. po R pÓ  pU.&   F pU 
 pÔ.*   J pÔ  pP9 o  pÓ3l pT+  o¦  pÓ N pT  pÒ P pS  pÒ= o  pT22 pï+  o©+  oq#  pS3` pç+  o«+  oq6  pS+  oO,> pO,> q, iê\$ÿ D pÎ3$ pS+  o±, jÞ  pÎ= o®  pg/&  . pS,>  ,> q, iê\(ÿ H pÎ3( pS+  o8, jÁ  pÎ= o5 
 pO J pp  pg/,  2j  +  oÎ/
 pS J pÎ  pg/.  2*  +  oG 0   P pð2p pÖ+  oÄ  pp$2  .    pÎ$$  .   jõ DHjõ9 o¾  pp  pÎ  m[ Hm[+  oÍ *   J pð2j pÖ+  oL  pp$,  .    p~ N0jõ9
 oÇ  pp  pn R@m[ 
 pp9
 o¸+  oð7` pS+  oð   pg/   /  pS,>   ,> q, iê $   D pÎ2d pS+  oÖ, jÞ  pÎ9 oÓ,> pO,> q, iê &   F pÎ2f pS+  oÛ, jÁ  pÎ9 oØ  pg/(   H pp3( pO+  oð/ pS H pÎ2( pO+  og *   J pð2j pÖ+  oe  pp$,  .    p~ N0jõ9
 oà  pp  pn R@m[+  oï $   D pð2d pÖ+  oí  pp$&  .    pÎ$(  .    jõ Hjõ9 oç 
 pp  pÎ 0m[ L(m[  pp= oÜ, hò .   N pp  pV$0  2p pg  pg2n  +  pÅ7@þ+  ox, hÍ4B ox, hò+  pK  pp$2   2Hjv R pU ~  pp2&~2fþb q$ (  2(ü2h}d q.| &  F pÔ@@ pÕ  pÖ  pU  pÔ   2H  O@ pÕ.$  .&  =b p6@ pÕ+  p+  p· 
~  pp2,/~2l/þb q$/ .  2./ü2n/}d q./|,> q ,0 ,>  ,> q, B pM  pp$0  ,> q 0@jv,>  ,> q, B pL  pM R pØ B pY@` p× @ pW $   D pX  pÖ$&  2f ph  ph2d  +  p!( pØ1H  +  p 
 pX J pW, pY1L  +  p  pX N p×` pØ` pY  pX9 p@` pN "   B pð  pÖ$$  2d ph  ph3$ pð+  p·& pL F pÌ( pM H pÍ 
 pð3j pW+  p¯  pÌ1L  +  p¯7@ pê+  p¯  pð2n p×+  p®,>~, n, iX+  p·+  p´  pÍ3P pÌ+  p´,>~, n,> pÍ, i«  pM R pN` pN` pL` pM  pð.(   H pð+  p¢ *   J pð2j pÖ+  pÂ  pp$,  .   ~  pp20?~2p?þb q$?2*?ü2j?}d q.
  .
?| 
(   J0jõ 
 pð9
 p8  pp  pp mn DHm[  pp9 oñ7@+  pÊ7@ÿ+  pÊ  F pp ÿ H pð,>~, n, hò/ pý+x PpZ, w7 6 p÷,z P  / q ,~   p^   exexe¹   eÜ   ep   f   f   fª   f>   fÑ   fe   fø   k   mÛ   mîXpð   n   dû    H pø   ppó       p÷xpu  xpwx   @pxRedisplay for a Canonical CRT   pÝ   i¡oXpüÿ  (          $    ¡    ¼       9                                 ÿ                (                ¿                ÿ                    H qBUFFER        H qO       H q[M      H qN       H q[L      H qM       H q8       H q7       H qE       H qL       H qW       H q P       H q"[4l     H q£[4h     H q%R       H q¦Q       H q(=       H q©&a      H q+Y       H q¬I       H q.[K     H q¯T       H q1K       H q²p       H q4[H[2J       H q6Y:    H q·&a0r0CJ     H q¹HJ     H q;[       H q¼Type ? for a list of supported types.

        H qB
Unknown terminal type:     H qÅ
       H qG         H qÈ
Supported terminals are:
      H qÌhelp     H qN?        H qÏTICP        H qÑTILP        H qÓTELC        H qÕTELP        H q×TCPC        H qÙTWIDTH      H qÛTMAXS       H qÝTLINES      H qßTALIAS      H qáTENUM       H qãTerminal Type?     H qf______        H qhTTERM   Scanset   Tym420    Tym425    Tym444    Ti940940  SCANSET   ADM3A430  Tym430    *37* VT102*20* VT100ADDS ADM1AADM1 420  TYM420    *4*  ADM31A    ADM31425  TYM425    *33* *5*  HP2621    444  TYM444    *17* *15* VT52 Z19  H19  pqÿ   dñ  H xr   dzxr @  à`r   pü   p} P  
   pñ{pr7    O@   -    ,>  ,> r¶,>  X4+  r/7fÿ+  r þ "  b  ?fÿ+  r  B  =f r/ r¾+x QþX*"ÿ/ r¾+x  þ2H+  r+  r¨+  r¨ 
þ2j+  r þ.ÿ2,+  rZ,>  Z~,>  ,>þ,	D+  r¨ .ÿ/2   R r*  þ. ÿ/        D r©3$þ+  r¨Z r*    D   
 r*/*   J r*  r©= r#/ r¾+x ~`r* ÿ. r>7   / r½ Bÿ ÿ+  r./ r=+x , w7 6 r¸,z P  / r¼,~      pq   r
    H r¹   pr´       r¸xr6&(  xr8x   `r9Peak Utility Module @r»ÿ      F              r   H xrÀ   rxrÁ @  à`rD   r»   r< P  
   r²gPrG7    O@   -    ,>  ,> tT,>  X4+  tI!( @ H tÎ,> ta,> rÏ,> tb, B tO,~      tÎ\6  V  +  ræA8  ¿7@ tL+  rÔ X 9#@@ tL+  rP7@ tÍ+  râ@@ tÍ   d  0Z  ¨+  r[O@ tMQ tNX6  V tO+    +  ræ0Z  ¡+  r]O@ tL+  rP0Z  -+  r`  tN	víO@ tÌ+  ræ3X 9#+  rä\6  V  +  rP2X 9#+  räO@ tÍ+  rPQ tNX6  V  +  rP\6  V   ,~   ,> tÝ,> rí,> tâ, |E,> t], {s,> tb,> tâ,> tá, ,~      rP,> tÜ,> rñ,> tâ, |E,> t], {ò,~      rP   t,>  ,> t,>  Z4,> tâ,> t`,> tc,Ì B t\W,R t,R t\  u§\W,@  ,@ÿZ t4F sZ t4H rý> t t H t1(  °+  s0h  =+  s 
 t/*  +  s 
 t\W,<7ÿ,<0  ,>  ,
®\W,\8  ,\?ÿ+  rú\WZOÿ5P s
\  u&\W,@  ,@ÿ\W,<ÿ,<  ,> tc,> tc,
ÒZwÿ4H sp  / tÛ0H  +  s,> tß,> tà, {o,>  ,q,> t_,> tà, {o,>  ,q,
\
W,</ÿ,<(  ,
\W,\0  ,\7ÿ\WZGÿ\W,<Oÿ,<H  ,> tc,>  ,
ÒZwÿ4D sp  / tÛ0D  +  s&,> t[,> tà, {o,>  ,&\W,<ÿ,<  ,	}\W,\   ,\'ÿ,< u£,< u$\
W,</ÿ,<(  ,
,< u¡,< u",
, _;,> tb, d!,    L t0l  +  s80,   0l  b u . t .  $ t..   0  $ t.0  \W,<Oÿ,<H  ,>  ,>  ,
Ñ,W B0    t9 s¬  t,>  ,> tÞ, {o B t B t7@ u2+  sC,< u£,< u$\W,<ÿ,<  ,
,< u,< u,
, _;  tZ6 t,z+  t	  t(Hw0(   0(  +  ss+ sx 
 tA*ÿ0*  0*  +  s[+(sß\, u,L t,L t+  sä\. u,N t,N t+  sä\0 u,P t,P t+  sä\2 u,R t,R t+  sä\  u,@ t,@ t+  sä\" u,B t,B t+  sä\$ u,D t,D t+  sä\& u,F t,F t+  sä\( u,H t,H t+  sä 
 tA*ÿ,>  ,-,< u,< u,	},\ t,\ t+  sä5
 sI5
 sK5
 sM5
 sO5
 sQ5
 sS5
 sU5
 sW5
 sY+  s|\, u,L t,L t+  s|\. t~,N t,N t+  s|\0 t{,P t,P t+  s|\2 t÷,R t,R t+  s|\  tó,@ t,@ t+  s|\" tp,B t,B t+  s|\$ tl,D t,D t+  s|  t(Fw,>  ,-,< tè,< ti,	},\ t,\ t+  s|5 sF5 se5 sg5 si5 sk5 sm5 so5 sq,< u£,< u$\W,<'ÿ,<   ,
,< tæ,< tg,
, _;,< te,< tå,< t,< t,
,< tã,< td,
, _j@j u2\"ÿZ6 t,z+  t	 6 t,z P  / tÚ+x  t   r2   rò    H t
             t  tAh  .@tP.(t	   tV     tx   z(tACREAUX    t   p| ÿA,  ¿0,   0,  +  t+0t +  t¤,> tb, I,> tc, I+  t¤,>ÿ, I:+  t¤5 t5 t5 t5 t5 t5 t5 t5 t5 t/ tÛ+x Q tNX6   V  +  t,,>  , tQ tNX6  V  +  t¬,>  , t+  t¨O@ tÌ,~      t¼,>  ,> tÀ,>  Z4 W N tN4. tº@p tL@r tM@` tÍ@b tÌ, rh,> tb, d, t¥6@ tM+  t77@ tÌ+  t³, rn7@ tÌ+  t¹Od tN EW,> tb, d P  / tÚ+x    t   t­    H tÄ             tC  tÂGH  EptPEXtº   tV 
   x    x  rOtDAAUXWINDOW    7  tN+  tÈ,> tN,> t^, {o,~   , w7 6 tV,z P  / t\,~   XtO   t<   rI    H tW   ptR       tVxtÓJ   xtÕx   `tÖAuxWin       Kê_xrË~xtÙÿ  (  X       }    }ín÷w                ÿw@tâ        H tä]        H tf[        H tç [failed]     H té?unknown error: '       H tì?sup error on original request    H tð?sup supplied no circuit     H tt?sup ignored login message        H tx?sup ignored original req    H tû?no room in monitor     	H tþ?not your username      	H u?too many circuits      
H u?supervisor error: '    H u?long queue in supervisor    H u?error in ISIS     H u?access barred     H u?timeout      H u?download/dialout failure    H u?host unavailable       H u?bad MUD      H u?not in MUD        H u?format error      H u [Ok]    H u!X        H u¢ [Working]    H u¤Login:        H u¦:    pu'   r?  H xu)   rÇxu* @  à`u¬   tÙ   tZ P  
   tPxuÍ   TxuP    puU   t   u§xuÖ   u^hu×  J   tÏ   9¹xu[  `u\     u\     u]Puf   `e    dh 6   e  ¦xué~ ujXu{             +    pvgg  KND(}8v ^ v > v*> v+  vO@ u3Z  (+ `  g  "8   X u²  v¥	x   8 `  X uS-> v$	`   @@ u0  v& X    uj-< vÀ " vXB  (U4  , v, {E, }  u06@h b+  v#\"  B v+	`   	b  + x  +      v­ P , wÄSTRING PDLXv§STRING SPACE   SYSTEM PDL}0vª
End of SAIL execution  SOME FORTRAN ROUTINE HAS SEEN FIT TO COMPLAIN
ABOUT YOUR STYLE.  COMPLAIN TO DEC THAT THEIR ERROR MESSAGE
PROCEDURE IS NOT SUFFICIENTLY GENERAL TO ALLOW GRACEFUL INTERFACE
WITH SAIL.\Hv@@@ uK &   ,X  zé, w8    Dh ,>  . u|@@ÿ  uV R uÞ 2 uÞ+  vJ[H 0X 6@ u³+  vJ" { 4H 7NP  +  vâ   an  9 vÏ, zÀ(L  ., uåP0  d.  Z0 dn   . u0 "ÿ+  vÓ1P`  +  vÖ/"  6X  +  vR "x . u|@@  @@ P  ^`       4. vb`p  +  v]ev  +  v_5N v\m0  R`  +  v_`Xÿe0  e6   .   G  .  anÿP0  P   N 9 vÊ7RH  +  vf6 H +  vÇ  u0O@ +  vÇ h ,>` ,>` @@` @@ uú7@ u3+  vî
& z?
& zË
   
& z?D$  1D  ¬O@ uú1D  ':  uú@@ u{7Rÿ+  w!x  `Bÿ6  uú+  vu
&  
& z@[     
& zA, w:Q  [  4F wZ  0Xh +  vþZh 1&    &   Q  .$  1f   +  vÿ/&   S  /  ,  zz.&   +  vÿ,X  zgar  +  w DH  .2  ar  +  w   .   HH  .2  , w8`r @  DH  / u|+  vî7@ uú+  w	
& z?
& z?/ u}@@ u3 h @d  *h ¦*h '6@ u³O@h /   (  ,?\8 u×,Xh ,Xh ,Xh ,Xh ,Xh ,{ 8   Xh « 8h Q8   Xh ,@@ uJ@@ u6,> z¸, yì@@ uË@@ uL 6 uV7VX  +  w7XX +  wP  ¯*  ¯`Xÿ3X  ¯5 w. zl+  w, {:Z uØ4B w¥Z Z  4X w `  av@ +  w`v  9 w hv@ av@ 46 w%@A`  9 w   u0S"ÿ, w(  u0,~   Z uX4D w¶,>  ,>  ,>  7X +  w²[  1F  +  w°0&  28  9 wª0"   08   P  9 wªÿ,`  ÿ9 wªZ D5D wª/ uüY  h"ÿlbÿ+  w(,~   \"  +  w("`  /$  Q  ,~   : x  6@ u{,~   @f  
(  1D  ¾+  wB1D  +  wC0$  0d  +  w<O@  $&  .&h+  w<O@ u{
& z?6@  > x  ,~   ,>   ,>     " zG+wÑ,^  ,^  ,^  ,^  ,^   ,~   ,>  ,>  ,>  ,> z9+   ,>  S$ú,> *d wÍ,> z¹+   S:ù*:  / z<,~   +  xá+  xá+  xÆ+  xD+  xê+  xå+  wc+  xg+  x,+  wc+  wc+  yX+  xË+  xá+  xÜ+  xÔ+  x-+  xá+  xá+  xá+  xá+  xá+  xá+  xá+  xá+  xá+  xá+  xá+  xá+  xá+  xá+  xá 8  ,X  + h  -  wJ $ýZ  1b  .D  " zÇ "zá $ yÆ+  yU+    hbÿibÿQ"A`,>  ,>  +  wë, xÿ4B w÷0B   +  wkÿ0"   0b  &+  wk $  :x  "  +wQ   wø   wz   wk   wý   x
   x   x   x   x   x   x   x/ z;,~   @   Q"A`+  xabÿ+  x B uú " zÊ $ zT, wç+  wë5" x #   "  , x   ,> z8+  x,> z·* x  , x,^   +  wë&   QDx  4B x, x[x  ."  1B   "  1B   "  *F xB  ,~   )BnD$  4D wë)B  , x+  x)Bn4D wë)B  4B xA"  ."  , x+  xabÿ+  wë4B wëabÿ+  x! B uú " zÏ+  w|:x  $  ,>  x  4B x1B  +  x, x+  x,^  +  wë x   %  Zÿ,>  4D xx  , x=$ x "ÿ+  wzabÿ5B x!+  wëQ"A@ B uú "  , x!$z uú4B x' " , x*d x£ "  +  wkX$   *D x& uú4B x§ "  , x`D= x©" uú+  x¤" {	,~   a` `+  xI    -  wJ& zÃ1f  .&ý,>  ,>  @d   )@  )"  &   /   Z&  &&  4F xA0B   5B x¼ (  &   4" z×$"  ."   "    . x  P x  b zH Aÿ/ u|,~   Q$  & zI\&n&&  /B  [  1(  +  x¶=f x¶S" PGB|S(ü*(  / z»+x %   j    *   ( ®+  xI&   6@   h X h"6    " zD1b  ."ÿ @  +  wÈ,>  Z  5B xÍ "  d"  !$~ A   `d  h$~ . z5`d  +  z](B|G     ,^  +  xI,>         xÛdb  /     xÛ$ zB1d  .$ B    ,^   @  +  wÈ/X   tx\Z  5B x^7x    4  zw  xÛ*   2B xÛU ÿ+  xI7@ uÌ+  xä,^  ,^   +@ uÌ,~     z½ B  -  wJ( zC+  xë-  wJ" zÆ0B  :   !$   (  +  xl-  wJ (   $    " z¿X$ z¼((ÿ H uµ } F u? F  ,& zÄ1f  .&ý F uú  u0Z  0&  & zÄ1f  .&ý F u{, yËed  , wç  uµ "y< $yÅ, wç " z?, wç4& x{& zE &ÿZF uÊ@   D   H u¶6H u5+  zÛ7@ u4+  y. z¼5> {Q&  X&ö*&ú  u0Q&h 1X&{*&x  ,>h  @@ u´ ò/"  ,>  6@ u³+  {,>  ,< uÊ # uKQ"A`,<  7B u5 " zÐ,<  ,< , u46@ u³/ u},^    u0,^h  !&{X&h 1*&h 6S&öX&  *&  / z¼ B  6D u´ D}eh  
' uK },>  eh  , yQ,^   (   @@ u5, y B},~   + u?6B u07@ +  yZ      0   0aþ+  zî6@ u6+  y±6B  +  y'
$  +  y#
2   1B  +  y' "  7  uµ "  /
"  
   1B  
$   +    0"  °/"  1B  ¢+  yv1B  *+  yõ1B  ©+  y³1B  ,+  y91B  "+  y71B  !+  y´0B   1B  O@ u61B  ¡+  y:0b  +  y;7  uµ+  y:
& zâ+  y Z  (+     u07@h T+  zÓ " zÕ,~   7B  +  zÒ
& zý,~    " z¾,~   : x  ,~   
& {-+  y Py<@I   @I   @D   @B   @D   @F   (y¿
Invalid index for array @I. Index no. @D, value is @Dr yFX    uú   u{       .   uú7F uK  z> F uK(Fý[F uÊ" uÊ!&   ) uKQ(A` H u¶,~    B uú  u0Z   B u{ " {7  u³ " zà $ zQ, yË, wç@   D  
' uK,~   -  wJ( zÂ      +  xm  u0 Bh ± "  : h ,$ h ±`h , z¢,< z7,< z4,
 wþ*wÿ Xwþ w*p   Xw, z¢,< z7,< z´,
 8wþ X u5,^h  ,>h  7xÿ!p  1X  #p  18  +  yk /p  / u}/ uü+x , z ÿ $   1"  (+  yr   &&  .&  ,X  zÞb zÅ* uK4D yô %  0D u7,)  u|+  zg  O   ,>  @v  @z  @r  
(  0D  +  y}
(  6  u³+  z,> z¶, u4+  z1D  +  yø  z30D  1D  +  z1D  +  zÖeD   e  G$  1D  7 z³D  
(  +  yþ  u0,|+     h ¬ h - h .,^  ,^  (\  X6p  ,^  ,^     az  g  O   +  z1D  
(  ,^  *  5X z\> zt	~  + zarÿ5R { >*U  z:	b  + z  u0Z8h 1*8h 6 ÿ Xh  ,~     u0*x  ,>   8h 1*8h 6 þ Xh  ,~   !8h 12Th 6" zq*8  /  +h    u0Z8h ¼*8h B,~     u0S8h ¼*8  ,~     u0 8 zÉPh   5X z*8 zÈ: zF&8h    u0.Xh :h d8p l8@  Xh ,~   7xh ,~   9 z(axÿ+ `  ,>  7`   P  2T z¬+  z0[  + ` h4X atÿ+  z­,^    {+ `  H  H  H z¶H z¶y    ( 18 |hz¶                   wG   wÏ  v        H   p    
 H    zØ  u7	`  
   
@A  (   $  ) =  +  *.  .  .  .  .  ..4 uK.4  0h 0  6$  6$  <   <h <x  @    @    @B,,@B    ALLOC?    No BAIL
 No DDT
  S   +  xI[@B,@B]   ~hzQ uú u{
& zÍ+  y 
& zÌ+  y $H uú H uú,> u?+h T,^  +  y ."  =  x8Illegal UUO       INX  ~hz[     +  x~(ò(B|+  xSCORGET OUT OF ROOM  Called from @J
    Can't continue
    @F   ~zå@D   @B   NO CORE AT ALLOCATION    NO CORE FOR ALLOCATION   VERSION NUMBER MISMATCH  
& {$   zÁ @ü@h u6+  yDRYROT: RF CLOBBERED AT RESTR gg  eB8  y(zö      xÛ2@ xÛ+  zÎ"   +  xIDRYROT -- NO CORE FOR SYSTEM!PDL   
TYPE DT.RET$G TO CONTINUE

    Called from @J  Last SAIL call at @J
  Procedure parameter almost non-simple   RECUUO CALLED IN NEW RECORD SYSTEM.  RECOMPILE.   
  zZ+  z      zº   S&YR@  +       +  z <x  Q<ý. u}4> y/ u},>  ,>  ,>  ,>  +  y/ z¼  z6,>  *f {  u0  zµ.&h  ,>  *f {+  yPOSSIBLE COMPILED CODE-RUNTIME INCOMPATIBILITY.
CONTINUE IF YOU DARE String space exhausted unexpectedly.
Any attempt to continue will cause a restart.
zH{¬Reply [CR] to continue,
[LF] to continue automatically,
"D" for DDT, "E" to edit, "B" for BAIL,
"X" to exit, "S" to restart
  ,>    u07Dh +  {D,>  ,>  ,>     ( Q('ÿ]
  "
  Q*  @@'ÿ*)  6D  +  {½,^  ,^  ,^  ,^  ,~     u07@h ,~    \x  <x *<x . {_a~    {b h 7B  +  {M    @    +  {J,o4" {Õ   {ß*   b {àb {a ÿ+      {`*   b {àb {á+   !<y*<  / {_,~     {Þ
   +  {Õ`  +  {Õ+  {Qx{ØW;   p{Z    INX  S({Û` +   +  {Õ    +  {ÓI      x :` ;@ .  .  .  PDL overflow in K.OUT routine   u0O@ u2,>    h ª  þ.!+@   @@ u2 Bh ª,^   / uü+x O@ u2,Î    ÿ  @@ u2/ u|+x O@ u2 ÿ 	b`  @@ u2/ uü+x g  !$    u06@h Ï+  {w,>  ,> |X, |,^  ZÿeF~ +  {ü"`  !"  (B  G  	dr+    / u|+x 1F  +  |1F  +  |1F  +  |0F  +  |\l$   +  {úZh Ð/"  `d  m"h !"  	bï+    l$ @ +  {úm$  l$   &   	fr+    ad  g  G  Zh Ð/"  `f  m"h !"Z 	bp+    +  {ú  u06@h Ï+  |" & §,X  |bQ$   Dh Ï.$   Dh P.$     Q"  	bò+    Q$î  |Ú " # B !"`X" F B # F £.$  *d |.$  F " Q"` B X"  B   |[ B X" |¾ B .$  Q$ö Dh Ð. |× Dh Ò ÿ,X  |bZDh ÎZDh MZDh Í.ÿZDh N/ u|+x  ^p ¢!>  	~ò+     > uÿ*> vp " v w\ B  «	nî+    d.  (n |®  |^1p  +  |e  u07Oh Ï+  |6 h Ð,>   h Ò,> uGO@ uG,> u2,8  ,^ u2,^ uG x     « 3D |Û/"   Bw\ vp "!: uÿ*:  !>  	~ñ+    !>  	~ò+    p "	`öd<@0 ^p !>@ a| @ h>  a|@0e>  d> @ 	~ñ+     p Q  -}wþ  u06@h Ï+  |Ç,> |X, | þeP  +  |QdP  +  |Î     |ZA0 ÿ,^þ,_h P,_h Ï+@  +    ,~   !  db  7 |Y  |Ù+  |K1P  +  |]1P   0  1P   0  1P   0  !$Z 0p   0   +  |K  |ßX     @   	bk	bo	bq-< |'-< |?6@ uF" |h+  {ø  |Ø+  |JDRYROT: INTMOD IRP spare routine called NOT ENOUGH SPACE FOR INTSET     v þ D  «   v+  |¯ENABLE or DISABLE of old-style interrupt channel  g   "   ÿ  u0 h Ó4B |r`f  +   `d  +   `f  +  |v`f @ +  |÷ad@ , }ad  +  |÷,<wÿ,<wÿ, `f   -( |þ4   `f  +  |üad 0 , }`d   -( |þ4   af  @@wÿ/ u|+x  #   ,>  ,<wÿ,<wÿ,Ô+   
& ~í!$ , }!$ P 
& ~Ô, }+  }h$ 0 ,oX  ,>  ,< ~E,< ~¸,> ~Á,> ~Á,> ~E,> ~Á,> ~Á,> ~Â@@ u2, k6@ u2+  ~É
& ~Ç,>  , ¨,> ~B,«6@ u2+  } Dh Ó,~   , ¨Z wÿ4@ } p  0@  ¬1@  ¼: x  / u|,~     u06Dh Ó`d  +  }ad   +  }Z`  ,>  ,> ~Á, -6Dh Zad  ,~   Z`  ,>  ,> ~Á, -,~     u0 x   Xh   ÿ0(  °0h  =7    /(  O   1H  ¡+  ~Ï1H  ¤+  ~Q1H  *!$   1H  #!$  1H  !!$  1H  '!$  1H  ©!$  1H  §!$  2D ~A+  }®
"  " ~e!$   +  }G h Z`h  `d  +  }3Z`  ,>  ,> ~Á, -+  }G`h  ad  +  }µX  +  }Gad  +  }GZwÿ5b }8, }Ä,o3B ~A  ~[X  ,>  ,< ~E,< ~9,> ~Á,> ~Á,> ~E,> ~Á,> ~Á@@ u2,> ~C, k6@ u2+  ~Ê,>  ,<wÿ,<wÿ,> ~Ã,«6@ u2+  ~N+  }G
& ~^, ¨,\w,\w,~    Dh Z/ u|/ u|+x   u0 x   Xh  [h ZO   1X    "  *1X   "  #1X   "  !1X   "  '1X   "  ©1X   "  §3B ~A" ~Ø,~     u06Xh Ú+  }Ý ÿ2X ~A+  }\7Dh Z+  `d  +  }Ù,<wÿ,<wÿ, ad  +  ~ËZ`  ,>  +  }Ü,>  ,Ô,~   ,>ÿ,`  ,~   ,`  ,^ÿ+  }S  u0 x   Xh  ,>ÿ6Xh [+  }_,&+  }ß  u0 x   Xh  ,>ÿ6Xh Û+  }_,+  }ß  u0 x   Xh  ,>ÿ6Xh \+  }_, ~+  }ß  u0 x   Xh  ,>ÿ6Xh Ü+  }_, ~ +  }ß  u0 x   Xh  ,>ÿ6Xh ]+  }_, ~(+  }ß  u0 x   Xh  ,>ÿ6Xh ^+  }_, ~¯+  }ß  u0 x   Xh  ,>,>7Xh Þ 8,`  ,^ÿ,^ÿ+  }~  u0 x   Xh  6Xh Ý,`  +  }S,> ~Á "x  ,>,>  ,7@x  +  ~/ u| 0b  +  ~,<~Ö,<~Ò+  ~,< ~Å,< ~<,>,> ~À, ~,
/ uü+x ANYMAINPIBINDITEVENT!TYPE,> ~Á,> ~Á "ÿ,>   "ÿ,>  ,Ê,>þ,> ~Á,H,>~,&,H/ uü+x ,< ~Á,< ~Á ÿZ  4B ~[  Z  ,>  ,>  ,>  , ~,
,^  ,^  4B ~,< ~Ä,< ~;,
+  ~/ u|+x 7@ÿ+  ~¦,< ~D,< ~»,>ÿ, ~,
,< ~D,< ~:,
/ u|+x ,< ~E,< ~¹+  ~¥7@ÿ+  ~.,< ~Ä,< ~º,>ÿ, ~,
,< ~Ä,< ~½,
/ u|+x ,< ~E,< ~=+  ~- ÿ4F ~¶     ,<ÿ,<  ,> ~Æ,
®,>ÿ,> ~Á, ~,
/ u|+x ,< ~F,< ~¼+  ~µDSK  H ~8H ~8H ~?H ~@H ~¿H ~GH ~¿H ~>H ~ÌH ~¾H ~@ITEM!NIL  PHI  {{   }}   ~ÿ}@~Á   u2   u2   u2   u2                        ,    File Id=  OPEN LOST " ~È+  }" ~a+  }8/ u|,~   NULL!RECORD    
& ~i, }Ä+  }À h Zd$  +  }G h Zl$  +  }GH ~ ~ ~H ~Output to file?~V                GETPRINT:  Illegal mode  SETPRINT:  GETCHAN failed}(~Ý
File for PRINT output  *    SETPRINT:  OPEN to the DSK has failed   
SETPRINT:  Above mode is not legal    SETPRINT:  ENTER failed, type file name
    
$PRINT called without initialization.
Output to teletype?rp~ó6@ uF+@ uý
:ÿ/ u|+x 6@ uF+@ uý
     u07Xh ,~   5x ~ü0"  °0b  =,~   F"  ,~   0"   0b  -,~   F"  ,~   
$  7 Ü+  ~x,~   6@ uF+@ uý
"ÿ/ u|+x ,>  \"  6@ uF+@ uýBwÿ,^  / u|,~   6@ uF+@ uý+Ax  , z: ÿ "  2.Bh 6`h ,$6@h , z¢S$N,< ],<h ,^  ,~   1X  
   \Dwÿ_  .Dh +  z\Dwÿ $  2.dh 5d a wÿQ$N,~   6 h +  08  °0x  =,~   F8  ,~   08   0x  -,~   F8  ,~   , 
     u|7ÿ
   6@h , 3X  +  Xh *d , +  , 
(    u|+  , +      uüOA
*  +  @A+  , 
(  7 uû
(  18  1X  +  ¬+  ¯6@h , Xh *d *, +  * X u2+  , +      u|OAÿ
*  +  @Aÿ+  ª
2   ,~   , +      uüOAÿ
*  +    ^+  ¾, 
(    :+  =, 
     <X.       uü@Aÿ 
 8ÿ,+    AR   .  \GóZOýA   Q2   & ÌZ   bXOþ+  ß7Xh  & Î4x   & Ò+   cC  +  ËaDÿcM  +  Ô+@  +   0(  °0h  =+  ÎF(  bH  +  gbA  +  IHh *d Ë, +  Ë0(   0h  -+  Î+  N IÿA O4@ `@ÿ+  ÞHh *b +    u0 ÿ*h / u|+x 
0   +    ,~   ÿs0]    2
   " ã+  bBO~ & Ò+   ,>  ,> Ý,,^  +  TTYIN: cannot retain break char    c@Oÿ+  ÐcBOÿ+  ËaDÿcLOÿ+  Ô+  Ë  u06@h a+@h a,>ü,> Â, -, z &  
,X+     @vH  !8H  X8H *8H / u|,^  ,^H ,^H ,^H ,^H ,^H ,^  ,^  dPx  TZ*P D
   JH D.P `nÿ" L NH   *H ,5L H[H !.  1X+   H 	x  `x  GNH Z.ÿ@@H * C0*  +   8H bNH QXH  8H bNH XXH +X*+  Æ .   , .2   .ÿ, /2   Sh ,@AH +  zZ  *XX  (+  Ä
& W
& a
& D
   0X  91X  )+  OAH +  6@@H ZH [H Z`H 4L ©4H !A( ?ÿS  , @@H 0*  +  ©.$  X  <l .   B  +   H  B Q"   BH ,~   .(     $  ,X  ZZDH ,~    "  0*  +  Å,> ÂZ^  ¨,> Â,> Â, ª( Ã/ uü, @@H 0*  +  © D  ¨   , ªO@  ¨,~   7@  +P*6@  +N*,~     u06@h á+@h áO@  ¨, z  uü dPx  Ý7Sh ,+  z@Ah ,Zÿ+L*ZH , ·ZH , ·Z  ,)+  z5D),~   , z ~,é,^  ,^H @AH ,^H 	@AH 	,^H @AH   uû+  z, z ÿ,é "H   Bh ±  u|+  z  Éi! Â H  $Dÿ?    " Î+ `   (  A+  &6AH +  6+  7AH " Q+  }DRYROT IN OPEN SPARES    OPEN: INVALID DATA MODE  TOO MANY CHANNELS OR I   INVALID DEVICE NAME FOR OPEN  OPEN&: INVALID CHANNEL NUMBER OPEN: DEVICE NOT AVAILABLE
  OPEN: NOT ENUFF CORE FOR BUFFERS   RELEASE&: INVALID CHANNEL NUMBER   TYPE "R" TO RETRY, "X" TO GO ON WITHOUT
    , z,#, {   Bh ± OH > H `H `H `H `H : H   u|+  z, z,8, {   Bh ±Z
<   `  `  `  `   R(  8   XP/ÿ Oÿ  uü+  z*x  ,>  +@ÿ0(  0h  1H  ,~   4( x1H  m   d   +  v@    , u4( }l   ,>0H  eÿ,@*x  ,>  ,>  ,>   ,>  @    0H   1H  ¢+ ¢1H  "+ $@j  @      / uûa`  7  "  ,^   afÿ6@  + ,^  ,^  ,^  + S, z,#, {h ±+  h, z,8, {h ±+  o, z,#, {,+  ç1"   "  2"-&d"~ )²`d  ."  ``  "  ,~   3b2$+ +   a`  + 2"3"+ "U"ÿ``  S"  ,~   , z,8, {,+  î  ",é@AH @AH   .  ,~   ? H + °H bOH + ²1H  + '4H'7@H +   1H  :H 0H  +   7@H 	+ :H 	@AH +   +B*+ 'O   +   6@H + : H "(  .hH 5('+B*?`H + ±`H + ' Zþ @  ZGÿ,~   <0±  1H  + º4Hº+   +@ÿ@j  @   +¿  Áeÿ*fA+@ÿ0(  0h  ,~   /(  4HÀ.&  `fÿ,Æ,K+ A[  4XÒ &   6   @   ,K=xÈ (X  ,~      %"  l$  .$   ed  ."     $(  +0l(  .(  eh  +O D   H  ,~      (bÕ   (bU.$   6ÿ)
X  /6  #"  /(  [  .(  4Hâ5hÛl   "  7 `H`+ ç`H  ``  + ß`H  + çdH  ,ê4Hâ(ÿ*xb9ß  )|BX @+"ç5.f``   .   ``  "  ,~   "Ob  a`  e"  @b  + ä,>  @@   `  %B   ` %x  l"  .  eb  :    B  ,^  %`  l$  .  ed  ."  .  `b  + õ)  /6  !  .`  !   B   D  ,~   (    yy2    yz'   y{/WB  |1|#C<M|    '8Zm pZg>                        µ3Lf3Lf3(zpQõ!#kÇ46q:ã2Jz*yG8Fag?9RY%{MpVf3vu5
9J.Æþ}ùsåKIN       iø y(ÿ)   -"'-"º6$  ?x   "+   . uû=Ò/ uü+ ç 	H  IH + ³NUMIN: Improper exponent NUMIN: Exponent range exceededyyRFIX: (INTIN or INTSCAN) Number too big DRYROT -- SETPL LOSSAGE DETECTED BY NUMIN    +@x  0H   1H  ¢+@x  1H  m   1H  +@x  ,>,Æ5F"+ , z "K,>I $  + ­, z "J,>É $    uü þ,é@A,|+ ·.   h ¬ X   *  *
h ¬*
h ­ Jh ® 
h .*
h - Jh .,^   H È+   ,^x  ZH `X  "P7Æ,»\Yÿ+  z h ®*h ­ Xh ¬ h -*h . Xh -,~   ,»+  z  u0,^h  ,^  7 _"L _ÿ28G2xÇ"L 8X Q6h ¬*6`  +h           ÿ+ :+ ?+Z*+\*ENTERzIÊLOOKUP    PASS 6 WORD INTEGER VECTOR TO FILEINFO  LOOKUP OR ENTER: INVALID FILE SPECIFICATION  , z  u| ÿ "í,é^wÿ,\  / uû7DH + î H + \<"ß
  J  =.Ú DH  BH 7 H +F*+  z+  z8n08  + d DH +F*+     H  H + Ú,>  ZH /(  Q(@ *   +H*+    Z  Q(  X(  @@'ÿ*( @,^  :H Q$ ` DH  " @ BH + ÚOUT   H  bï+  z  r  H H H 
OUT: No buffer. Channel @D file @F:  @F  @FmAö, z » þ "A,é8=18  ,Ò  ¿08  + ¶ 7$ÿ,J7jH + 4D z`H  H Z(  Q&  1$(  + .(/ÿ*&   ."(  /$(  @@H XHH +F*+    + ~4d z/$  .  *&   /*  JH .DH +  z, z  uü  "C,é"=0"  + > H + +F*+    +  ÿXH +  z ¼ 8ÿ,>,>  ,>;,x, z  u} þ "@,é@AH 8=18  ,N  ?08  + ¶ 7$ÿ,F4D z7jH + $`H QH  (  X  1d(  + ¥.(/ÿ*&   .  /  +B*+ + ).(ÿ*&   /
  /$   JH .DH +  z ÿ/X  XEH +  z, z  u| "B ÿ,é8=08  + ³@AH > H + 2+B*+ ¯g  H  Bh ±+  z < 8h ±,>ÿ,>  ,>;,"ÿ58½>Q   *    > ¾+     D          0   8  H  ,W+  z+  z+D*+H*ARRYIN    ARRYOUT   WORDIN    WORDOUT   DRYROT WRD SPARES   ARRYIN: negative word count, value is   ARRYOUT: negative word count, value is  ARRYIN: mode must be '10 or '14 or '17, not  ARRYOUT: mode must be '14,'10, or '17, not   DUMP MODE WORD COUNT NOT POSITIVE, VALUE IS  , z  uü  ",é& $   1F  + e $   4Fe g çdF  .&  (F  )"  A$  4DQ$ t p+@  +  zw@g\H   7 , z  ",é ÿ +     uü+  z, z@Aÿ  u} " þ,é,|+ õ fX"(8û Xh ­+^*+ ÷+  zZH `X  "7Zh -\Yÿ+  z, z@Aÿ  " },é,|+ õ7X~+ &f ýf	 f þf+ óUSET ~       8  ÿ  ,  h -+ ì+R*+T*.  .  6$  ERENAME   MTAPE~)RENAME    "+  zMTAPE: ILLEGAL CODE RENAME: INVALID FILE SPECIFICATION ATTEMPT TO SET MODE OR DATE VIA RENAME.
USE ERENAME INSTEADii  u0@AÿZ& ,X+ ^,>  S, X,ÿ p  ZwÿS"  ,M+ Ø4b¶0b  + Ù"  $"  6@h , z¢.Bh 6`h + [\Bwÿ h  Bp  @
   S(8  Xx  7D   + ÜdD  + / &  )B  aB  ¿=
¬Bh =fª*h(.Jh .Jwÿ+ 73D×+ ³FXcDÖ.WcDÖ+ ³    + */*  *H­    (D   &  =
ª@@wÿ,^  ,)/ u|+x Zwÿ.&  &&  ,>  ,X+ L@@   & Q&  Zx  .(  *&'ÿ    ,ÿ,^  "&ÿQ  Q$A` p  Zwÿ4BE  H  =bÃZwþ wS"  ,M+ Ê@cÿ   ,)/ u}/ u|+x \Cÿ\"  + H `+ I@
   4fÓ0f   &  ,>   V  eH   e  G(  H  =fP,^  X"  	b  ,~   : x  ,~   H  ppppp     00000\C+ ¶"c "  + ¡ Th 6,$+ %/*  *h(+ ­"fOAoÿ@@wÿ+ 8Couldn't get core for buffer. TMPIN: huge TMPCOR file found TMPIN: Insufficient CORE available  &  ,X+  h V B   Dh V "  .$   D uR@@ÿ.$  ZD=bn@@  uR,~   7B uR,é    D uR@@ÿ@@  ,~   7B  +   uRZD  @@ÿ B uR,~   7B  + 9vZ uÏ   aX  + Z
  1J  + \  j,7þ*L,>   x  ,>  .*  $1D  + 1D  + *l,^  Z
/ÿ0J  + ÿ/ uûZ'ÿ0H uP+ ú,~    (  /"  ,þ+ ,>  7H(  + "'Q   "'ÿ,~*h*h,^  + + + ,+ + + + 7Bÿ+  0D  Z  + "/ uü+x ,^  ,^  *x  1f  5',~   "¥,~   4B,>  [ÿZÿXFÿQDÿZ  ,> ,> Z /&  ."  Q&s ,>  ? ÿ+ ¥&x  f,9¢/ u|,^  .&  ,^  /$  0&  0f  + ). uÒ6Bþ,O+ ,~     .&  ,>   $X0&  0f  + ²7B uÒ+ ."þ7B  +  $æ,  +  " .&ÿ@@  Q  X$ *$  ,>  ,>     aD  + Â" !`  X ! : x  0D  01D + >+ B,>  ,>  ,ñ,^  ,^  1D  "ÿ Cx  *f;/ uû,^  ,^  ZD  .$  ZÿZFÿXBÿQDÿQBÿ,~    "   ,~   ",~      tX  ËwiK,> "h Õ,>  ,p þZB uO B uÏ. B uÎ " B uP " B uQ " B uÑ "   B uÐ7H uN,~    $ uO "  ,D ( Q   H Z5HU  u0@@ uR@@h V  Bh × &  ,X  " /$  ,$  ,$ÿ,$,$,$ZD uÒ &   ,X ©@@  Q&  X& *&  "   B   "  T B  B  "   B  "  ? B  B  "   B  "  2 B  B 	 "   B  "  * B  B  "   B  "   B  B  "   B  "   B  B  "   B  "   B  B  "   B  "   B  B : uÒ/&   "  ,&   " ,&   " ,&   " ,&   " ,&   " ,&   " ,&   " ,&   " ,&   " ,&   " ,&   " ,&   " ,&   " ,&  Z uY+ 	Z   4HZ$  7F  + @@  *f9
  ~q                
    
    
    2    .   $CLASSRECRNGHNDLERRECSIZTYPARRTXTARR    y]a        x         :    ,            ab  7A  ,~   `b  + ­ab  `b   ,~   808  + 1x  	+a° 9a¦0XÈ1X:+ ­,>   #  ,>  Zÿ4X¬,>  6@  ,ÿ?`x  9*,^  ,^  + .,>  ,?  @A  ,u,^  ,~     È  È  È  :  È  È  >  >  È  È  È  Â  È  È  È  È  È  <  <,>  ,u,^  + È,>  ,>ø,^  + È7E  + È,>  @A      *   ,,^  + È7E  ,~   @A  ,>  ,>  ,,^  + È,>     ,,^  `b  "2,~   4B[  5XX uËQX  XB uË,~   5&Z uËZ  4BRP  `bÿ+ RQX   8  *fÎXX uË,~   7F  ,~   ,Í9ÓZ uY4HZ$  ,ÓZ   + V[P 1N,~   Z8  (P  Q(  /(  Z8 Q$s<&â8  1X  =Ý1X  =]0X  + ]Z  ,J=&ÝZ8 7H  ,~   8~1X  + h0X  9cZ  ,J9c7G  9c"ÿQ  ,Í9c6X uÅ+ ð,>  ,n,^  ,~   ,ØZP  0Tÿ5Tn,~    T` S$xX u07X C+ w,>  ,>   ` ,n,^  Z`  5Xó,^  *dr  uÅ ` ,~     u06@h 7fh ,~   8h  h 1X  +  1X  + 1X  ,J=f{,~   ,>  ,=,^  + 4B,>  "ÿQ  !  ,Í,^  + ,JZ uË1Bÿ,~   [  XH uË[ uËQH  QB uËZ  Z  1H+ ,> ,>  ,   + ,>4BZ  ,> Z Q  af  + /&  ."  Q&s ,>  ? ÿ+ &x  f,=9/ u|,~   / uû,~   ,Õ,y,k,> uL,^  4B,>  , + Z uÏ   Z  aX  + ¥Z`  Zÿ0B  +  + ¦P  axÿ+ ¨Z`  Zÿ0B  + #Z'ÿ0H uP+ ,~   Zÿ,>  ,>  Z  Z` 0X+ .,,^  ,^  + ¥,>,>  ,`  + ¬O@ uË,,  u06Bh W+     uÒQ8y,>  6B`  O@ *x´,^  6B`  6  + <f h ×F  3&   3&    F *x¶,~   4Bab  `b   ,~   `b  ,~   81X  + J1X  + Ì0X  ,~   ,>  7D  + I"ÿ4XIQ  ,>     ,J*dG,^  ,^  ,~   ,>     ,J,^  ,~   ,>     ,=,^  ,~   ,>   & ,Ó+ R & ,Ó: ÿ,^  ,~   Z  4F_0$  0$ + Ó:  >  :  *  E 5DÚ,` $ ,ã>` ,~   ,`   ,)"$  &  .D ,~   : x  ,~   !  YX`  axÿ,~   !`  PX`  ,~   6X  QF`  Q8   X  ZF  ,~   ,>  ?  ,y:  7F + ï:  >    * 6@ + R,>  ,` $ ,ã,^  + R &  ,X+     $ ,ã@x  $  D     V  .d  1d 9ô/  /  @@  .X + é  u06@h Ö,~   :  ,>  ,0,^  ?  "¶,~   @  YpuO                      z        u.
.  .0  .4  "+ H"+ ²"+ H"+ ²""+ )"+ Ò*­+ ÉNULL ARGUMENT TO $RECFN  COULDN'T GET SPACE FOR $SPCAR NO CORE FOR RECORD STRINGS    NO SPACE FOR RECORD BUFFER    UNINITIALIZED SPACE SYSTEM?   ACCESS TO A FIELD OF A NULL RECORD COULDN'T GET BLOCK FOR A RECORD    STRANGENESS IN RELEASING RECORD    CALL ON $RDREF IN RECORD GC VERSION>A)CANNOT GET ROOM FOR SPACE DESCRIPTORS   DRYROT -- INVALID REFERENCE TYPE IN FLDKIL   FLDKIL NOT YET READY FOR CALL FOR REFITEMS   WARNING: TRIGGER SET TO ZERO AFTER $RECGC    ,>  ,>  ,>þ,?,^  ,^  / u|+x Zÿ7 /"  _ÿ#`  $	X.""ÿ/&  ,X 	ß,>  Q$  .&  *$ÿ,^  Z`  "`  ."  .B  .ÿXB ÿ7 > / u|+x , zZÿ $ &  <"S   .(  /ÿ7`  + 	Û$  /$  + Î68ÿ`x  (F  ,>  Z$"  .& ,>  afÿ,X 	Ü,^     Z  .  ,^  ,>  @@  Q`  .$  *$gÿZ$   Z7 "`  Q  ,>  .$  Zþ   (V  .6  Q`   (~ &   *   <"l     X .8  /'ÿ F $   'ÿ X  $ .
  .$  /(  + e,^  .$  ,^  ZDg7 ÿ\$  Dh ± ÿaf  5$ñ(J  /  Ph ± D`  4& z`f  PF` +  zZÿ,^ÿ7 /$  _ÿ#`  $	X.$Z`  + ),>  ,>  _
  Z   	× 0  "  ,		u9ü 	^,~   7G  ,~   *x  ,>  @A  + u7C  ,~   @A  ,>  ,>   *   ,,^  ,^  ,~   7C  ,~   ,>  ,,~   7C  ,~   ,>  @A  ,*x  ,>  + u=*	 ÿ /	Ø+x  -  =,	 	^7C  ,~   ,>  ,>  ,>  ,>   *  ,,^  ,^  ,^  ,^  ,~   7C  ,~   "	n,~   ,>  ,>  ,>  ,>  ,@  ,^  ,^  ,^  ,^  ,~   @A  ,~     u0,^h ÌZV  ]V  [P 1R    	e P RH Y  .  ZH ."P  Z  /  Q  /  3R  Z`  ZH 7P8  + 	0"	×1B  9	ª4,	/$	Y3d  9	ª,		u9	ª4,	±  u0+h ÌZH ZH    /& <d	»:    8  h0  `ap0 `p p9	³ 0  ,>  ,>  ,>  ,	ö,^  ,^  ,^  9	³ZP  + 	¢ 7 /"  78ÿ+ 	Ú4X	Ù(8ÿ"6  $6`  7   /6  Q"     / uü+x ?6ÿ+ 	GZþQ.6`  *8X  / u}+x ZZÿ6 g+ 	K/8  /6  Q  Z_ÿZgÿ2v  Z  .6gÿ*8X  / uü+x  ÿ 6 g+ 	S/8  0Z    	iQ6`  X6`  Z`  Zgÿ<z	Ö.8h  *6`  / uü+x @  þ    .$  Zÿ+ 	C_ÿ+ 	C"	á+ RARRAY no room  DRYROT: BEXIT  NO ROOM FOR ARRAY   ARRAY lower bound gtr  upper bound GO TO OUT OF A PROCESS WILL NOT WORK    YOU CANNOT CLEAR STRING ARRAYS TO OTHER THAN NULL UNTERMINATED PROCESS DEPENDS ON A BLOCK BEING EXITED 
MAY CONTINUE     þ  ÿ  ÿ  	  	
  	  	  	  	  	  ÿ  þ  þ  þ  þ  	wþ*wÿ*p  wþ+ 
wþ*wÿ*p  wþ+ 
g  O     u0,^h  Zwþ4X
ªZwÿ4X
© 8h 1*8h 3 Th 6(
Â8
B1H`  + 
1(`   (`  5V
0   .
L,i wFh `d ÿ+ 
6@h + 
Æ h   Zwþ&~.w4F
$ý8
C/X  4&
Ef
C`   p  `  3D  + 
, h `  3D  + 
"ZwÿZwþ.  .Bh 6`h ,$6@h , z¢\Bwþ h  w Vw  F  =d
Zwÿ+ 
%Zwÿ.Bh 6`h + 
I.Bwþ h  p    F  =b
¥ Vh @   ,i!8h 1*8  / u|+h  ,\w,\w+h  Zwÿ.Xwþ+ 
§ 6w+ 
/ 6p  Zwÿ4X
7  u0,^h  ,^h ³,<wÿ,<wÿ,6
A 8h ³Pp  d8p l8@  XX  `  V  + 
/ u|+   u0,^h   Th 6 Bh ± "  .Bh 6`h ,$6@h , z¢,<
Á,<h ,^  ,^  Xh Bh  h ±+h         0p  0w<  <þ@    @    8
Ã/&gn9
RwX&
D  5F
+ 
Zwþ.  ,$"`  .Bh + 
Incompatible string widths to CAT, will use MAXIMUM     + 
Ó>.ÿ  u0,^h  @@ u2Zwÿ3v  56
Ø46
×7  @   T` u2?:x  + 
[1zX  + 
\@   @   \` u2/6h  XVwÿ4V
a p  0z  + 
b4Z
a`  =z
ß Xp  / u|+x  Zx  @v  )V  )8  &6h  /x  56
l Zx   8  &8h  &6`  $x  .8  :p  /  x
k Zp  + 
a<  <p  $6h  .6`  v
ë+ 
aZwþ*wÿ0B  + 
t p   w<"
ô    3D  ="
ñ4"
ô "    wÿ/ u},~   Zwþ*wÿ0B  + 
 p   w+ 
ûD$  0$   0d  -+ 
<"
ÿ    F  4X
û1X  + 
ù "    wÿ/ u},~   ZvwÿZbwþ0bX  *     <"wp  F  4V0V  + G  06  °0v  =+ ="   2Bwÿ7  Z6w/_ÿ4BX  5X8"+ ._ÿ."  F  48+ /  6p  06  °0v  =1     6_p26  + 08  °0x  =+ 1vgp"  / u},~    "  /ÿ("} þxX/ u}+x 0    u0,^h  :`h + #6@h , z¢,<¢,<h ,^  Xh +h      Th 6,>   "  ,$,^  + , z,¿ (  6$+ °#  +0© ,   "  5$° O &  QFx  93, z,¿ (   )Dþ&N+ 1&  G&  QFx  ."  4D5,°[x  Fh ,~    (  6 h ++ ¸ (  4L¸Lh  ,   2"  + ºHh 9¸4L³Lh + ³\Bwÿ 8  38     /  .Bh +  z6@h , z¢  u|#
h + "  3"     .Bh 6`h ,$ "    ,   ,<  ,<h ,^  ,>Î+      u0,^  ,^h «,^h ++ `    u0 h « Yÿ h + Y/ uü+x B    <3Lf, z "  + R, z "  @d  +0S  uûZwÿ p  <&]
  1j  + Ô1J  i,  1J  + Ô0*  0* + ]$  +0ß/$/h<&]
  + ØF_+@  / u|+  z"Dh ±1B  h$  + [, z  u}@oÿ>
þZ(  4B ( 7J+ 8 8ÿ,+   AQ2  Z
þZOýA   c@Oþ+ (6,i.0H  \GóZOþPO~A   dFÿmy &{dfÿ &wZ(  .Bh 6`h ,$6@h , z¢,<  ,<h  ( R   <"  +   0(   0h  -+ {+ ú0(  °0h  =+ {F(  bH  + ÂbA  + ~Hh 9õcY  + õbM  4Nõ IÿA O4@a@ÿ9!x  (X  .$`  !  9Hh    /wÿ.Xh \Nwÿ1b   @b(  XB(   D( @   ,i+  z,<µ,<µ+  z.0H  \Gó,<(  ,<   Dp  <"  bH  + ¼cA  9bM  4N IÿA O4@a@ÿ9!x  (X  .$`  !  9XNwÿ1b   @b(  XB(   D( +  z4J¯.*  7@h 0*  	0j  £+ ¶4*&*  	 00    .
  7R( + %aXÿ+ $Z
O}cJA+ -: x  ,~   58- &  Ì,X : 2 @@  Q$  X$ *$H ¿ $OtQ$@[DÿQ$ÿ*$Oü R( + $$,  	.  /,  	.F,~   @    *h 6R( + $   ,>  ,¥ J,^      0   + $}Iµ0  /*  .?+ ¤*þ,<  ,<  +  zBKTCHK: CORGET failed    c@Oÿ9bLOÿ4N+ BKTCHK: Breaktable out of range:   c@Oÿ+ }cXOÿ+ õbLOÿ4Nõ+  BKTCHK: Uninitialized break table: haÉBKTCHK: break block allocation failure on 0?  "   Zwÿ4XV0x   8   |,>   p    eZ   e  G:  Z  =xÒ,^  / u|,~   , z,\  ,\  Z`   &   } "   <$Ü  L  =fÚ Bh ±  uû+  z, z "  .Bh 6`h ,$6@h , z¢,<~,<h  ÿ(8  Xh =bc  u|+  z, z &   6@h , z¢ "  .Bh 6`h ,$,<þ,<h  "   ü  4Fm4Xî.8  Xh =bë"  .Bwÿ.Bh   u|+  z, z &  + æ, z "  .Bh 6`h ,$,<~,<h  ÿ *   ""   ý  4FzFh 9x.Bh .Bwÿ  u|+  zH  HÿH  H        , z,>+ , z,>+ , z,>+   uü,F#
h «7 x  .
  5D5J "  6 x   Bx  5*
 $   + 0*  +  ,  /   1&  (ÿ2&  8   3$)+ 7 x  9
&$  8   #h «3"     ."  6 x  ."     #h +3b     .Bh 6`h ,$\  ,<  ,<h /   &  4B 6 h ++ 4@ &  Fh  &  Fh =b+ "Fh =b4@¡ &  Fh  .  6 x  + §   #h «/  5,«/  #
h «@   + «@   7`x  + «4(«2h  + «    (   ,>0J0  + ´<    &  6@h «+ ¶5D¶ &  6 ÿ+ ±=
´ ÿ0L  + ¶,^   + Ä0j8  + &$  G&  QFx  >   ,,[x  Fh ,~   7 x  + Å7@h «=<4H@   @    4(Q,  1(  + 
&(  G*  )Jü5h?7Jh _ *   Jh  *  6@   Jh 4LÅ)J  + Ã+  z@`   þ4DÕ5dMO`  )B  (DÿJ   4DLl$  "`  + ÎU$ÿ9Î@   )B  (Dÿ/"  @0"  + Y1b  + ì0"  + V1b  + ×/"  )  `f  8   .(  ,~   2d+ Y+ S3$+ ì+ S *  (  .)1b  + à,ÿG(  0"  =
Ù0B  + ß2d+ â(/}+ S0"  + ä/)=
Ù0J  =
Ù + S      ,ÿ0"  + \1b  + k2$+ \0j  + k + \      + á *  (  .)0"  + ô,ÿG(  1"  =
m0B  + s3$+ ö((  "`  + S1b  + x/)=
m=*m + ó      ,ÿ1b  + ï0"  + ~3d+ ï5j~ + ï      + õ%)`d  ,~   )  =,~   &h  /WA ÿrQ      ¹      0    + Ä &  + ¶O    "  + > *  )Jü+ ?, z , +  z ÿd&@ 4@Ü5`    l& @ 5B61v  l&   *   (   2 + Î3@2"ÿ3 + V6d ~ ) _D       #
h «#h +@   5B *  	 "   "  .Bh 6`h ,$,<,<h 4v .*  #  0j  	 *  	ef  + $0j   *     38     ^,ü/l  5v¹4l*l&  <X*    ,ç=x¨.  ,°    `f  ,ç    ,ç.
  56Â    ,ç86®+ Â    `f @    ,ç4.N0n  	+ Nl2  .9tl0  er  .0  .9jh0  50N  9N4l»    ,ç=x:/
  ^8_w4x½ 6  	.  ,°,á=v¾4xÁ    §,ç=x@    ,ç`f  + ^4jE,á=jD7@h _     ,ç7@h _     ,ç    5(J    "`  ,ç&(  2   &(      ,ç  ( ,ç,~   (  3@)2")3 )+ Ô .)þ0J  + Ó/.  ,[,[.(  <*=jÎ+ O(  3@)þ3")2`)þ+ Z .),[/(  <j=
V@8  +0\,~   l&  @p  +     ,ç *(     ,ç=jß+ N   %"            %   l"  .  eb  .      .   9lè,~   @h : wÿ,~        Lf3 (zpÑ $î  46q     C   Ú    Õ        }qtLf35a#kBc)}ù:cD²,#Fhx7P-=Ø?jy/3qA>A-y_lõ
/~^3 	8¦ 47  ë  fÊ      '    9Lf3Lf39Lf3Lf3T=8¨:pQuáz8]1bY¥U<c\#0sß|i,Ò=D&x«Y{úEe 0   y!   y!y   y#SD  y&wka u!-Qa^¦>   :s\-¶+8-³x     3Lf3Lf³6$                           µþ}ùsåK(    2    '   /WB  #C<M|'8Zm 3Lf³(zpQv46q:d*yG8Æ9RY%û3vuµ            2   t   '  P  B  1@ ka n5J Pd ,^  *ÿ ©,^  `fÿX  QÿO@ u26@ uF+@ uý+@  @@ u2/ u|+x ,^  *ÿ   Q$ D0+ ¡F  ,ª,>   ÿ&W4F²0&  + ¹1F  + ¯0F  + °7a=+ < ¾P  +@Æ+ ¸Q0  p   Fh D&  aF` G&  SGH D&  cFH + 8bZ: ÿ,^  ,~    ¾P  +@Æ+ ¸+ 84   .à+ 8  H   ÿ  H   `    `   h    h              0   8   p   X       (   H p   p  p   p  pH  ph ¬  u0,^h  4]+h  "×,~   ,^  *ÿ Ö,^  `fÿX  O@ u2Qÿ!`  6@ uF+@ uý+@  @@ u2/ u|+x ,^  *ÿ   Q$ F0+ Nf  .ÿDATUM OF ARRAY NOT THERE   d H  $IH H H H CASE INDEX OVERFLOW, VALUE IS }`NO BUFFERS ASSIGNED FOR I-O CHAN   
I-O device error, channel @D status @B   @F: @F  @F  Q" R0`Px+ í6Sh ,,~   +@  0   ,y+@  0   ,v  u06@h à+@h à.õ "  7A  ,~   1"  9ñ "   6A  \"ÿ,~      : CHANNEL NUMBER INVALID N	ø: CHANNEL OR FILE NOT OPEN    / u|@@h -@@h ­@@h . *h ¬,0L  + @@h 0@@h °Z`p  (   *h 0,0L  +  *h 0ZJh . *h ¬,4L0L  +  *h -,4L0L  ­+ 6@h .+ ,SJh .0L  + ,XJh .: x  ,~   4J+ @@h ¯ *h ¯, *   7Hh ¯,~    &   )F  0&  0f  + (J  G*x5H,~   Z`p  (  @@(  Q*A@ ,   ? p ,~   p 0L  + ª,>   (   *    ,   ? p + 'p 0L  1L  ­+ '0L  ®1L  + '4H1l  1,  + A,  (J  G*0  = Kx  ,^  ,~    ,   ? p ,~   p 0L  1L  ,~   0L  1L  ­,~   0L  ®1L  ,~   4H¨4L31,  + ³eL   e  G,  L  =¨ ,   ? p ,~   p <(´eL   e  G,  L  + ³+ ,>      $  &$   ,>     &x  .$     ,X+ â/ u|1f   ¥1h  5hÁ À $ /&  @@ÿ Hý F}(H  Q$$@  D.&ÿQ   Fþ &  &ý F~$f}((}Ghþ ý,\4BU   h  X"h .X 6Xÿ2Hgý+ Ð   + N Xÿ Dÿ D  Dh  }.X / / "Xh    ,í 'ý+ \4b® h  X  h  X 28  ó@@h \bh ,~   5H] (  7Bh + `2H +  4"g,~    "h 6B  2H 5Bà4BèZh 1X  + g   Xh '   Xh ¦   Xh    Xh ZBh ,~   ,\5Bè,>  Zh ¦,X ü,?,^  + \ &  ,X Ö 'ý X  '~ X  H  H  H @@  '} X /'~/'~"X Z'þ/8'üQ'} X (XþD8   X @@  7Fh + 6X  6F`  5XúG   D    6Xÿ6Fgÿ5XýG   Hÿ,~   *ÿ  u0 Th 6,$"`  .Bh  ÿ/ u|+x   u0,>  ,>  ,>  ,>   ý.Bh  wÿdhÿ5H.Hh 6`h + !6@h , z¢\`wÿ h *p  4H  Fh =h,^  ,^  ,^  ,^  / u|+x +  p  Fh 7`h ad `+ 
 p   h `  `  Z  /8  48
0x   + 
)DqA&  /  (&$    &  &&   $&`  .  Zwÿ3H  + + 
.   Th 6,$"  .Xh +   u02Th 6+ Lxh §58 Rh ; 2h ¶*2h º6@h (+ (6@ u@+ KZh  h   08ÿ0yþ"7Dh  Ç@@ ÿ5D.@@h ),>h ,>7Rÿ ÎZRÿ,Oÿ h 6Zÿ5R2/ u| &  (,X  Dh & h ,6Dÿ+ · h &,) h  h  ý3XP 2DP  4@@P    ,j,µ FP  h "XP  h  XP  X6TP  5D;2D  . h 6@@h © "h  
h [( 3Jh .h 7  ( @@(  ( 3D+ Ë2h( + O   6Dÿ2@ý+ U2D7@+ Ð7@(  D(    + Ë3h}5h7 ÿ Xÿ"}.X(  $},)+ Ë5h[  (  ( &   .Fh ©(   /`( 4 Ù Ú6J(  5DF+ ì[( 2h  + :Z( ,X+ æ $ /&   Fþ$(  F}.F(  F(  (  Fý(F  Q$@  D D(  D( .Dþ> þ (  H~$ý"( nh7@(  D(  ÿ Dÿ Fÿ      + U h    Bh   .h 7 Bh 4"ð  6@h ,#`h §6@h (+ &6@ u@+ ÞS2h ¶*2  ,~      exÿ+ 4XZ  $h 7Dÿ+ 08ÿ0yþ+ ø* ah`+ *&&ý  /8ÿ$~/   X  QF  ZB+    .«@@  ."  ,~   Zh 9,õ1"p  + ,~   7Rh ,~   ZOÿ[Oÿ+ ,õ=.
ZH  5R,~   [P 1L,~    0 7R0  + h2  `r@ 97C  9/"  6.ÿ ",9ZP  0Tÿ+ 7Jh ,~   [(   "?ÿ6.? =,Z
(  5J,~   Z`  (Nÿ+ ,õ=.,~    h &@@  ."  Q"ÿ & '*"  7B+ ­: h )[      
  $&  §&}.h &   Z     [  4F3* + «2J + ¦Z  3r  + ¦QB   QF      5B" h &Q&   (  § "   7K  + ±QB(  [  =(¯ B,~   7Dÿ,~    ý2Xý,~   Z
4J3 ( &~.  $ý".?nn,>  Q`  "( Z(  /  @@( [(  4LB3h0 + BZ0  .0 3(     .B0 X
  + ¼XLZ`(  [`  .  ,^  .Hh 6`h + ä6@h + K  h 3B   + T  X   =hÈ* h + T,>  &~4JO/
~"
  .jh 5j.(  6*h 9
$Z /ÿ.Hh 0"   ."  ,   =hÑ    ,^  @   P
(  \`(  2X( + Z @( [
  5JÔ4Hµ *h /  g  /( 28+ aã,&ý.  5,&~/   $ý..  n ( 9 Ö`   `   `   `   `    ( + Ö,l3F   D ý6Fÿ2Xý 2h}+ ,j+ Ä Fh "} Xh ,~    h  X3Fh ,~   "h .  .XP ,~   ,>,u  u0,^h  ,^  ,^_ÿQh YVX  XVh +x   u0,^h  ,^   6h    7Vh  +x 2X_ÿ+ wZX  XXh  +x 6@h ,7Rh ,~   ,>  S$ÿZOÿ[Oÿ<.bD  @@  ."  + ZH  5R~,^  ,~   7bh ab @ ."  @@  Q`  ."   h   *#þ,~   ~i@            @            @            @            @           ýw  õ Ò0h <   <  <  <þXB0  + « 1+ &
&,+¸ F+ e  Th 6+ ¥ ( .X( + Ë Hh  Dh ,~   $ý.  = ß4"`,W+ `DRYROT at Arrsrt    d*p l*@  Jh + P	b  .bh (.Bh ¨+ s "   	b  JBh (+ )*    .+ NO CORE FOR ALLOCATION
  ê  u07bh ,~   + ×DRYROT -- STRNGC recursion    DRYROT: WCR structure broken   D(  D(  D"}"H( + Î H(    &(  ( .&  + ]DRYROT -- LEAPing error at ARRSRT  DRYROT -- strange size for a byte  DRYROT STRNGC: got ahead of myself DRYROT STRNGC: no string space?    ,>h 7,>,>h §,>, u@  u0+ *DRYROT -- Empty SGROUT is very strange  DRYROT -- STRNGC:DEST alignment failure NO CORE for WCR of new string width|yZSTRNGC surprised, short on String space "h ,>  ,>h 7,>h §,>h ), u@  u0+ t,Ñ $|$x  3$ÿ x,X o+ ¾,Ñ^$|$( 3$(  x,X o+ ^CLRWCR: called with bad WCR - trying GOGTAB  DRYROT -- unexpected STRNGC core problem{sDRYROT: CLRWCR found String Space over-run   String GC: no core to expand string space    UNIMPLEMENTED case: no room for new SPACE    DRYROT -- RF (R12) not saved in RACS at STRNGC    DRYROT -- SIZE and SPC ran out at different times String garbage collector can't get core for sort  TOPBYTE out of range at STRNGC -- will continue   DRYROT -- No more room for strings -- very strangecaSTIDNT-- string encountered twice, descriptor addr =   STRNGC bemused beyond belief -- room from before gone. DRYROT -- abnormally tiny string space being constructed    String GC: Descriptor byte ptr. out of bounds, Addr. is     Z  [
  7@   *h  XB(  6@  QJ  ,~   ZD7ÿ F ,>   "h  + 91d  + ; *  Z  5B87    QD  XD(  ZB  0Jh  QJ  ,^  ,~   !8h "*8  ,~   6Z u0+ Ö 8ÿ X  ¨[  ( :h 7@  + ÆZ  '18  38  + Æ
&} 8hÊ38  + I	x  + Û Zoý Z u0@@o~ WZXoþ[Xo.8   Xoÿ@@ uK@@h  Q  X8h *8h â $h â Dh Z  ,R+ Ö@@  .,   Lh ,>     /  ,µ,^  ,~    8h "*8h %,~   ,@.&  6@h !+ æ $h  Z  4Dæ2f + Ú: x  ZDh #,±  1, + ä F Z  .  /     .  Q8   Xÿ,µ,
@@  "` .$  ,~   6@h  + 
,>  Zh 7 ÿ+ êZÿ,±   .8 ,^  7@ u¿+ t,>  ,>h   8 uÀ*8 uE ÿ,>  ,>  ,> uû,> uû, u¿!8 uÀ*8  ,^h  ,^  6@h `+ a	x  + Z  "`  7@ u¿+ ,>  ,>h   8 uÀ*8 uE ÿ,>  ,>  ,> uû,> uû, u¿!8 uÀ*8  ,^h  ,^  ,R2f + Ú+ Ü"`  "`  7@ u¿+ 
,>  ,>h   8 uÀ*8 uE ÿ,>  ,>  ,> uû,> uû, u¿!8 uÀ*8  ,^h  ,^  + ¾,Ö"   + ,@     /$  Z  / 3,h + 4@"` . Z`7ÿ+ æ780 + §/8  2f  + 4@"x ,>  ,>  ,>  .Xx     Z  ,±. .  ÿ,µ,^  ,^  ,Ü+ Ø,^: x  ,~   : x  + ¾.80 38h + ¦4@,>   &gþ/  "  .Xx  ,+ ×,^  "   + /80 7   &    Fh £+ ¾7Z u0+ Ù,Ö/$  "    .  3$h + Þ2Dh 7 ÿ+ °Zÿ,±. 2lh + Ý2Lh 7 0 + 6,>  Z  ,±. . ,^  68h ¡3,h + Ð5X¸ 8 Z`  18   8  3&  + Ð.8  7@ u¿+ Ã,>  ,>h   8 uÀ*8 uE ÿ,>  ,>  ,> uû,> uû, u¿!8 uÀ*8  ,^h  ,^  6@h `+ ß	x   i   "`  7@ u¿+ Î,>  ,>h   8 uÀ*8 uE ÿ,>  ,>  ,> uû,> uû, u¿!8 uÀ*8  ,^h  ,^  .,   Lh    /  ,µ+ 
7Z u0+ Ü &    $h  Z  4DV3&   + Ó/&  ,~      â
&â+¤
&æ+
&+©
&r+ 
&õ+È
&ë+R
&y+1
&î+-+@h ` + F+@h `+ + öDRYROT NEAR MAYBE
 !8  .  PX7ÿ+ dDRYROT -- NEAR CRXXB
   DRYROT --CORSER&LNKRET   CORBIG: INITIALIZED WORLD
   DRYROT -- ADDR TO CORREL TOO LOW
 DRYROT -- EXPAND CODE GLUBBED UP
 DRYROT -- NO ROOM FOR USER TABLE
 DRYROT -- ADDR TO CORREL TOO HIGH
}9üYOUR SYMBOLS ARE SOON TO BE OBLITERATED
    DRYROT -- CORREL CALLED WITH INITIALIZED WORLD
  DRYROT --CORSER&LNKRET [simulated core release]    DRYROT-LIBRARY  DRYROT-LIBRARY  DRYROT-LIBRARY +   0    2PEAK.SUM     730-Apr-84 11:52:00  DAMTAF    To exit PEAK

    ^X ^C         Exit without writing files
    ^X ^F         Write files and exit
    ^X ^E         Write files and return to caller

Inserting

    All normally printing characters insert themselves 
    when typed. This includes RETURN and TAB.  To insert a
    control character you must "quote" it with ^Q.

    ^Q            Insert the next character.

Deleting

    ^D            Delete character
    ^H            Delete previous character
    <del>         Delete previous character
    ESC D         Delete token
    ESC H         Delete previous token
    ^K            Kill line
    ESC K         Kill to end of line
    ^W            Kill to a mark
    ^Y            Recover killed text

Setting the Argument

        ^U followed by a number.  If no number is typed,
        the default multiplier of 4 is used.

Moving Around

    ^F            Move forward
    ^B            Move backward
    ^A            Move to beginning of line
    ^E            Move to end of line
    ^N            Move to next line
    ^P            Move to previous line

    ESC F         Move forward over token
    ESC B         Move backward over token

    ESC {         Move to top of page
    ESC }         Move to bottom of page

Moving Around in the Window

    ESC ,         Move to top of window
    ESC .         Move to bottom of window
    ^V            Move to next window
    ESC V         Move to previous window
    ^Z            Scroll window up
    ESC Z         Scroll window down
    ESC !         Move point to top of window

Moving Around in the Buffer

    ESC <         Move to top of buffer
    ESC >         Move to bottom of buffer
    ESC <space>   Set a "mark" in the buffer
    ^X S          Exchange the point and a mark
    ESC G         Go to a mark
Searching/Replacing

    ESC S         Search
    ESC R         Reverse search
        (Complete command: "ESC S <string> ESC")
    ^S            Repeat last search
    ^R            Repeat last reverse search
    ESC M         Multiple string search
    ("ESC M <str1> ESC <str2> ESC ... <strN> ESC ESC")
    ESC =         Show search string(s)
    ESC (         Reverse search for matching open 
                  parenthesis
    ESC )         Search for matching close parenthesis
    ESC C         Change
    ESC Q         Query change
        ("ESC C <string1> ESC <string2> ESC")

Fancier Text Manipulation

    ESC ^W        Copy text between point and mark to kill buffer

    ^J            Start new line at current indentation
    ^O            Open the line
    ^T            Twiddle (swap) the last two characters
    ESC ^J        Right justify line
    ^X W          Delete whitespace
    ESC I         Indent a line (add leading whitespace)
    ESC U         Unindent a line (remove leading 
                  whitespace)
    ESC P         Fill paragraph
    ^^            Toggle case of character
    ESC ^         Toggle case of word

Manipulating Windows

    ^X 2          Use 2 windows
    ^X 1          Use 1 window
    ^X G          Enlarge window
    ^X ^O         Go to other window

Manipulating Buffers

    ^X <          Move to previous buffer
    ^X >          Move to next buffer
    ^X ^N         Build a scratch buffer
    ^X ^K         Delete this buffer
    ^X ^S         Checkpoint this buffer
    ^X ^U         Recover last checkpoint
    ^X !          Recover checkpoint file

Reading/Writing Files

    ^X ^R         Read a file into a new buffer
    ^X ^I         Insert a file into the current buffer
    ^X ^W         Write the current buffer
        (Complete form: "^X ^R <filespec> ESC")

Locking Files

    ^X +          Clear file lock
    ^X -          Lock file (prevents modifications)

Command files

    ^X ^L         Execute command file
        (Complete form: "^X ^L <filespec> ESC")
    ^X |          Start comment (| to end comment)

Macros and Key Bindings

    ^X D          Define a macro
    ^X M          Bind macro to key
    ^X B          Bind function to key
    ^X E          Define macro by example
    ^X [          Push key binding onto stack
    ^X ]          Pop key binding off stack

Modes

    ^X N         Put PEAK in "Normal" mode
    ^X T         Put PEAK in "Text" mode
    ESC O        Toggle "Overwrite" flag
    ESC W        Toggle "Wrap" flag

Information Strings

    ^X I        Insert information string
    (Complete form: "^X I <I-Str> ESC")
    I-Str is "date", "time" or "username"

Other Things of General Interest

    ^G            Abort command
    ^L            Repaint screen
    ESC ~         Clear "buffer modified" flag
    ESC ?         Type this list, list buffer chain
    ^X ?          Name of function bound to a key
    ^X "          Put string on message line (" to end)
    ^X ^T         Show date and time

Environment Variables

    ^X =          Query the value of a variable
    ^X _          Assign the argument to the variable
    (Complete form: "^Un^X _ <variable name> ESC")

CheckpointInterval  60     Interval for checkpointing
BreakPageOnFF        1     When nonzero, break page on ff
EscapeAs$            1     When nonzero, print ESC as $
ExactCaseMatch       0     Controls case matching in searches
                            When nonzero, matching is exact
IndentWidth          4     Width for ESC I, ESC U commands
LeftMargin           1     Margin control for fill paragraph
Multiplier           4     Default for "Argument" command
RightMargin         72     Margin control in "text" mode
SwapPMRegion         0     If zero, point does not change after indent
                            region commands, insert file and "yank"
TabWidth             8     Controls tab stops
UseTabs              1     Will use TABS where possible in
                            indenting, when nonzero
VariableFill         0     When nonzero, argument to fill will set
                            right margin, instead of repeat count
Accessing PEAK

    PEAK is accessible by the monitor command 'PEAK' 
    Command:  PEAK [filespec] [/Pn] [/Ln] [/Cn] [/R] [/N]
    with optional switches:

        Pn    display at page n of file
        Ln    display at line n of page specified 
        Cn    display at character n
        R     read in the file "Read Only" (no editing)
        N     do not delete nulls in file

Executing Functions by Name

    ESC X         Execute a function by name

Functions not Bound to a Key

    Beep                  Capitalize Token
    Center Line           Clear Mark
    Column Insert         Copy to Search        
    Creaux                Decrement Char
    Delete NULLS          Down Paragraph
    Fill Line             Fill to End of Paragraph
    Goto Column           Force Left Margin
    Increment Char        Indent Column Down
    Indent Line Up        Indent Region
    Insert Octal          Name Macro
    Nothing               Repeat Query Change
    Set Append Kill       Set Creaux Esc Char
    Set Right Margin      Set Right Margin
    Set Terminal Type     Show Column
    Show Octal            Token LC
    Token UC              Unbind Key
    Unindent Region       Unname Macro
    Up Paragraph          Window Bar
    XOFF Synch

Special Characters

    ESC X is special ESC <char> ESC
                  Define "Special" character
    ESC X not special ESC <char> ESC
                  Character no longer "Special"
    ESC ;         Search for "special" character
    ESC :         Reverse search for "special"
                  character

Token Definitions

    The following definitions are for the commands ESC F,
        ESC B, ESC D, ESC H:

    ESC X is token ESC <char> ESC     Defines "token"
    ESC X not token ESC <char> ESC    Make char not a "token"
    ESC X is number ESC <char> ESC    Make char part of a number
    ESC X not number ESC <char> ESC   Make char not part of a number
    ESC X is delim ESC <char> ESC     Makes char a delimiter
    ESC X not delim ESC <char> ESC    Makes char not a delimiter
    2PEAK.TUT     04-Apr-84 13:20:00  TIVHAY    Welcome user to PEAK.  You are looking at the PEAK tutorial.
Please note:  PEAK is intended for Tymshare internal use only.

PEAK commands generally involve the CONTROL key (sometimes labelled
CTRL or CTL) or the META key (sometimes labelled EDIT).  Rather than
write out META or CONTROL each time we want you to prefix a character,
we'll use the following abbreviations:

 ^ <chr>  means hold the CONTROL key while typing the character <chr>
          Thus, ^F would be: hold the CONTROL key and type F.
 ESC <chr>  means hold the META or EDIT key down while typing <chr>.
          If there is no META or EDIT key, type ESC, release it,
          then type the character <chr>.  "ESC" stands for the
          key labelled "ESC" or "ALT".
(Important note: if you must exit at some point, type ^X ^C.)

The characters ">>" at the left margin indicate directions for you to
try using a command.  For instance:

>>  Now type ^V (View next screen) to move to the next screen.  (Go ahead,
    do it by depressing the control key and V together).  From now on, you
    will be expected to do this whenever you finish reading the screen.

Note that there is an overlap of one line when going from screen to
screen.  Having the last line of the previous screen at the top of the
new screen helps to provide some continuity when moving through the
file.

The first thing that you need to know is how to move around from
place to place in the file.  You already know how to move forward a
screen, with ^V.  To move backwards a screen, type ESC V (depress the
META key and type V, or type ESC V if you don't have a META or EDIT
key).

>>  Try typing ESC V and then ^V to move back and forth a few times.

SUMMARY
-------
The following commands are useful for viewing screenfuls:

        ^V        Move forward one screenful.
        ESC V     Move backward one screenful.


BASIC CURSOR CONTROL
--------------------
Getting from screenful to screenful is useful, but how do you
reposition yourself within a given screen to a specific place?
There are several ways you can do this.  One way (not the best, but
the most basic) is to use the commands previous, backward, forward
and next.  As you can imagine these commands (which are given to
PEAK as ^P, ^B, ^F, and ^N  respectively) move the cursor from
where it currently is to a new place in the given direction.  Here,
in a more graphical form are the commands:

 
                          Previous line, ^P
                                  :
                                  :
   Backward, ^B .... Current cursor position .... Forward, ^F
                                  :
                                  :
                          Next line, ^N

You'll probably find it easy to think of these by letter.  P for
previous, N for next, B for backward and F for forward.  These are
the basic cursor positioning commands and you'll be using them ALL
the time so it would be of great benefit if you learn them now.


>> Do a few ^N's to bring the cursor down to this line.

>> Move into the line with ^F's and then up with ^P's.
   See what ^P does when the cursor is in the middle of the line.


Lines are separated by a pair of characters, a Return and a Linefeed,
but PEAK almost always makes them look like one character.  You
can think of it as a Newline.


>> Try to ^B at the beginning of a line.  Do a few more ^B's.
   Then do ^F's back to the end of the line and beyond.

If moving by characters is too slow, you can move by words.  ESC F
(Meta-F) moves forward a word and ESC B moves back a word.

>> Type a few ESC F's and ESC B's.  Intersperse them with ^F's and ^B's.

Notice the parallel between ^F and ^B on the one hand, and ESC F and
ESC B on the other hand.  Very often Meta characters are used for
operations related to English text whereas Control characters operate
on the basic textual units that are independent of what you are
editing (characters, lines, etc).


When you go off the top or bottom of the screen, the text beyond
the edge is shifted onto the screen so that your instructions can
be carried out while keeping the cursor on the screen.


>> Try to move the cursor off the bottom of the screen with ^N and
   see what happens.



Notice that you are now on a new screen.  This is similar to typing
the ^V command, with one exception.  ^V always repositions the
cursor to the top line on the screen.  Moving past the edge (either
the top or the bottom) scrolls the text so that some of the text on
either side of the cursor is still visible.

>>  Type some ^P's to move off the top of the screen now.  Remember
    to watch where the cursor is positioned when you are done.


^A and ^E move to the beginning or end of a line.  

>> Try a couple of ^A's, and then a couple of ^E's. 

See how repeated ^A's or ^E's do nothing.

The location of the cursor in the text is also called "point".  To
paraphrase, the cursor shows on the screen where point is located in
the text.

Here is a summary of simple moving operations including the
character and word moving commands:


        ^F        Move forward a character
        ^B        Move backward a character
        ESC F     Move forward a word
        ESC B     Move backward a word

        ^N        Move to next line
        ^P        Move to previous line



>> Try typing these commands a few times to try them out.
   Once you feel comfortable, continue to the next group of cursor
   positioning commands below.



Please note:  All commands in PEAK can be given arguments which cause
them to be executed repeatedly.  The way you give a command a repeat
count is by typing ^U and then the digits before you type the command.
If you have a META or EDIT key, you can omit the ^U if you hold down
the META or EDIT key while you type the digits.  This is easier, but we
recommend the ^U method because it works on any terminal.

For instance, ^U 8 ^F moves forward eight characters.  If ^U is not
given an argument, it has a value of 4.
        

>> Try giving a suitable argument to ^N or ^P to come as close
   as you can to this line in one jump.


If you mis-type a numeric argument or the beginning of a command that
you don't want to finish, you can use ^G to discard your command.
Notice that the terminal "beeps" at you.  This is to let you know that
your command has been aborted.  ^G is the Abort command, and will get
you out of the middle of most command sequences.



>> Type ^U 100 to make a numeric arg of 100, then type ^G.
   Now type ^F.  How many characters does it move?
   If you have typed an ESC by mistake, you can get rid of it
   with a ^G.


The command ESC ! (Meta Exclamation-Point) will position the
current line at the top of screen.  This is also known as the 
"Scroll line to Top" function.

>>  Move the cursor down to this line and type ESC !.  The line will
    scroll to the top of the screen.

^Z will scroll the screen up one line, ESC Z will scroll the screen down 
one line.

>>  Try typing a ^Z, then a ESC Z.
    Now try using a numberic argument with ^Z.


There are also commands to position the cursor at more specific places
within the file.  Some of these will also reposition text on the screen
depending upon the current location of the cursor.

Two simple cursor motion commands are ESC < (Meta Less-than), which moves
to the beginning of the text buffer, and ESC > (Meta Greater-than), which
moves to the end of the text buffer.  The buffer contains the temporary
copy of the file you are editing with PEAK.  If you need the
shift key to type a "<", then you must also use the shift key to type
ESC <.  Otherwise, you would be typing ESC , (Meta Comma), which is a totally
different PEAK command.

Some files are formatted into pages of text, usually separated by a
form-feed character which is designated in the text as "^L" on your
screen.  To position the cursor at the beginning of the current text
page, you type the ESC { (Meta Open-Set [Open curly bracket]) command.
To position the cursor at the end of the current text page use the
ESC } (Meta Close-Set) command.  You will find a "^L" at the end of the
next set of instructions.

>> Go to the beginning of this text page with ESC { and return with ESC }.

>> Now see how ESC < also takes you to the beginning.  Then use ESC } to
   return.

>> Type ^V or some ^N's to go past the page mark to the next screen.


A short summary of these commands follows:

	ESC <	move cursor to the beginning of the file
	ESC >	move cursor to the end of the file

	ESC {	move cursor to the beginning of text page
	ESC }	move cursor to the end of text page


Another thing which is useful is the "Redisplay Screen" command, which
you perform by typing ^L.  This clears the screen and then redisplays
what was on it.  


>>  Find the cursor and remember what text is near it.
    Then type a ^L.  Note that the screen is redrawn, and the cursor
    is still in the same place.



INSERTING AND DELETING
----------------------

If you want to type text, just do it.  Characters which you can see,
such as A-Z, 0-9, *, etc. are taken by PEAK as text and inserted
immediately.  Type <Return> (the carriage-return key) to insert a line
separator.

You can delete the last character you typed by typing <Rubout>.
<Rubout> is a key on the keyboard, which may be labelled "Delete" or
"Del" instead of "Rubout" on some terminals.  More generally, <Rubout>
deletes the character immediately before the current cursor position.


>> Do this now, type a few characters and then delete them
   by typing <Rubout> a few times.  Don't worry about this file
   being changed; you won't affect the master tutorial.  This is just
   a copy of it.



>> Now start typing text until you reach the right margin, and keep
   typing.  When a line of text gets too big for one line on the 
   screen, the line of text is "continued" onto a second screen line,
   The vertical bar at the right margin indicates a line which has
   been continued.

>> Use <Rubout>s to delete the text until the line fits on one screen
   line again.  The continuation line goes away.

>> Move the cursor to the beginning of a line and type <Rubout>.  This
   deletes the line separator before the line and merges the line onto
   the previous line.  The resulting line may be too long to fit, in
   which case it has a continuation line.

>> Type <Return> to insert the separator again.


Remember that most PEAK commands can be given a repeat count;  Note
that this includes characters which insert themselves.


>>  Try that now -- type ^U 8 * and see what happens.

>>  Now, type ^U 8 <Rubout>  and see what happens.

To insert a control character into your file you preceed it by a ^Q.
For example, to put a form feed (Control-L) into your file, you need
to type ^Q ^L.  

>>  Move the cursor to just below this line and type ^Q ^L.

>>  Now go back to the previous screen with ESC V or ^P and see the
    "^L" at the bottom of the previous page, and then return here.

You've now learned the most basic way of typing something in
PEAK and correcting errors.  You can delete by words or lines
as well.  Here is a summary of the delete operations:

        <Rubout>     delete the character just before the cursor
        ^D           delete the next character after the cursor
        ESC D        delete the next word after the cursor

        <Backspace>  delete the character just before the cursor
        ^H           delete the character just before the cursor
        ESC H        delete the word immediately before the cursor

        ^K           kill line from the cursor position 
	^W           kill from the cursor position to the mark


Notice that ^D vs ESC D and ^H vs ESC H extend the parallel started by
^F and ESC F.  Also, note that <Backspace> and ^H perform exactly the 
same function as a <Rubout>.  This is to facilitate using PEAK on
terminals which do not have easily accessible <Rubout> or <Delete> keys.

Now suppose you kill something, and then you decide that you want to
get it back?  Well, whenever you kill something, PEAK saves it for you.
To yank it back, use ^Y.  Note that you don't have to be in the same
place to do the ^Y; This is a good way to move text around.  Also note
that the difference between "killing" and "deleting" something is that
the "killed" things can be yanked back, and "deleted" things cannot.
Generally, the commands that can destroy a lot of text save it, while
the ones that attack only one character, or nothing but blank lines and
spaces, do not save.

For instance, type ^N a couple times to postion the cursor at some line
on this screen.

>> Do this now, move the cursor and kill that line with ^K.

Note that a single ^K kills the contents of the line, and the carriage
return, line feed at the end of the line.  This makes all the other
lines move up.  If you are in the middle of a line ^K will concatenate
the part of the line before the cursor with the next line.

The text that has just disappeared is saved so that you can
retrieve it.  To retrieve the last killed text and put it where
the cursor currently is, type ^Y.

>>  Try it; type ^Y to yank the text back.

Think of ^Y as if you were yanking something back that someone
took away from you.  Notice that if you do several ^K's in a row
the text that is killed is all saved together so that one ^Y will
yank all of the lines.

>>  Do this now, type ^K several times.
    Now to retrieve that killed text:

>>  Type ^Y.  Then move the cursor down a few lines and type ^Y
    again.  You now see how to copy some text.

What do you do if you have some text you want to yank back, and then
you kill something else?  ^Y would yank the more recent kill.  At
present, the previous kill is lost.  Each time you reposition the
cursor, or delete some text, the next time you kill something, the
previous contents of the kill buffer is lost.  This point is very
important to remember, because only one portion of text may be moved
at a time.

To "kill to a mark" you first have to set the mark.  The command to 
set a mark is ESC <Space>.  When you have set the mark, you can then
move the cursor to another position in the text either before or
after the mark and kill from that cursor position to the mark with
the command ^W.  This text can be restored with ^Y.

>>  Type ESC <Space>.  Note the message at the bottom of the screen
    "Mark 0 Set".  Then move the cursor down a few lines and "wipe" out
    the text from that point to the mark you have set with ^W.

>>  Now move the cursor and restore the text with ^Y.
FILES AND EXITING
-----------------

In order to make the text you edit permanent, you must write it to a
file.  If you exit PEAK with ^X ^C, the edit will go away.  When you
read in a file by your initial editing command, you actually read the
file into a buffer, and it is that buffer you are editing.  Therefore,
the changes don't become permanent until you write out the file.  This
is so you can avoid leaving a half-changed file around when you don't
want to.

If you look near the botton of the screen you will see a line that
starts with "PEAK" followed by your terminal type and a few other
things in parentheses.  (These other "things" are mode information flags
and will be explained later.)  At the end of the parentheses you will
find the filename "PEAK.TUT", and a percentage number.  This is the name
of your own temporary copy of the text of the PEAK tutorial; the file
you are now editing.  Whatever file you have read in, that file's name
will appear in that precise spot.  

The commands for writing out files are unlike the other commands you
have learned in that they consist of two characters.  They both start
with the character ^X.  There is a whole series of commands that
start with ^X.  Many of them have to do with files, buffers, and
related things, and all of them consist of ^X followed by some other
character.

The most common way to write out your file is to write it out when you
exit.  The command to exit and write out your edit is ^X ^F.  You
will see the words "Writing Modified Buffer" at the bottom of the 
screen if you have made changes to the buffer, or "No Buffers Modified"
if you have not.

EXTENDING THE COMMAND SET
-------------------------

There are many, many more PEAK commands than could possibly be put
on all the control and meta characters.  PEAK gets around this with
the X (eXtend) command.  This comes in two flavors:

        ^X          Character eXtend.  Followed by one character.
        ESC X       Named command eXtend.  Followed by a long name.

These are commands that are generally useful but used less than the
commands you have already learned about.  You have already seen two of
them:

        ^X ^F         Write file and exit.
        ^X ^C         Quit PEAK.  This does NOT save your file.


Named eXtend commands are commands which are used even less frequently,
or commands which are used only in certain modes.  These commands are
usually called "functions".  For example, the function Center Line,
which centers a line of text, can be entered as a function.  First, you
type ESC X, then PEAK prompts you at the bottom of the screen with
"Function:"  and you should type the name of the function you wish to
call, ending with ESC.  You only have to type enough letters to make the
function name unique.

>> Move the cursor to this line.

>> Type ESC X.  Note the prompt "Function:" at the bottom of the screen.
   Now type "Center Line" ESC and see what happens to the line.

MODE LINE
---------

For some commands, PEAK will "prompt" you for the next input.  This will
happen at the bottom of the screen on an line called the message line.  The
message line contains the bottom lines of the screen.  The line immediately
above this is called the MODE LINE.  The mode line says something like:

   PEAK 1.00 (Tym444 Normal,Wrap) filename  -nn%- *

This is a very useful "information" line.  You already know what the
filename means; it is the file you have read in.  What the --nn%-- means
is that nn percent of the file is above the cursor.  If you are
positioned at the top of the buffer it will say -Top- instead of -00%-.
If the cursor is positioned at the end of the file on the screen, it
will say -Bottom-.  When you modify a file, an asterisk "*" will appear
at the end of the mode line.

The part of the mode line inside the parentheses is tells you what
modes you are in.  The default modes are "Normal" and "Wrap".  Another
major mode is "Text" mode, which you can enter by ^X T.

>> Type ^X T.

Notice that the word "Text" is now in the mode line.

>> Type enough words to go well past the end of the line.

Notice that PEAK now inserts carriage returns for you.  Other commands
work the same as before.

>> Type ^X N.

Now you are back in "Normal" mode.  Notice that "Normal" is back on the
mode line.


CHECKPOINT
----------

While you are reading the tutorial, you may have noticed the word
[CheckPoint] in the bottom right corner of the screen.  When you are
modifying a file, and have not made any changes to the file for a
minute, the file is automatically copied into a backup file.  This
backup file can be useful if you want to "back up" in an edit.  You
can force a checkpoint if you feel unsure about changes you are about
to make.  The command to checkpoint a file is ^X ^S, and to back up to
the last checkpoint is ^X ^U.

>>  Type ^X ^S.  Notice the message "Checkpoint Complete" on the bottom
    of the screen.

>>  Set a mark with ESC <Space>, and then move the cursor down and wipe some
    text with ^W.

>>  Now back up with ^X ^U.  Notice the file is restored to the version
    at the time of the checkpoint.
SEARCHING
---------

PEAK can do searches for strings (these are groups of contiguous
characters or words) either forward through the text or backward
through it.  To search for the string means that you are trying to
locate it somewhere in the buffer and have PEAK show you where the
occurrences of the string exist.  You type the command ESC S followed by
your string to search for and terminate with an ESC character.  If you
type something incorrectly you can use <Rubout> or ^H to delete the
character(s) and then re-type it.  You will notice that PEAK types
"Search:"  and the string you type on the bottom of the screen.  After
the command

        ESC S text-string ESC

PEAK begins searching from the current cursor position until it finds
your specified string, and then it redisplays the screen at the current
point.  If the string is on the current screen, then only the cursor is
moved.


>>  Type ESC S and then the word 'search'.
    Note where the cursor is.

>>  Type <Rubout> four times, and see what happens to the word 'search'.

>>  Now type 'arch' ESC to complete the word 'search' and start
    the string search.  Note where the cursor is positioned now.

>>  Now, type ^S and notice that the second occurrence of
    the string "search" is now located by the cursor.  
    ESC S ESC also will search for the last string typed.

You may also type numeric arguments using ^U as in other PEAK commands.
If you want to abort in the middle of typing the search string, type
^G.  Note then the prompt is replaced with the message "Search Aborted".

The ESC S searches for any occurrence of the search string AFTER the
current cursor position.  But what if you want to search for something
earlier in the text?  To do this you type ESC R for Reverse Search,
which works exactly the same as ESC S except the direction of the search
is reversed.  ^R, or ESC R ESC will repeat the reverse search.

GETTING MORE HELP
-----------------

In this tutorial we have tried to supply just enough information to get
you started using PEAK.  There are many other commands in PEAK including
commands to use multiple buffers and multiple windows.  For additional
documentation see the guide "(SYSNEWS)PEAK.TXT".

There is a brief list of commands and their functions available
internally to PEAK.

>>  Type the command ESC ?  (Meta Question) for the brief summary now,
    while you are still in this tutorial.  Then, you will remember how
    to get it when you need a quick refresher course.

(SYSNEWS)PEAK.KEY lists all key bindings by key.

FINIS
-----
Remember, to simply exit use ^X ^C.

This tutorial is meant to be understandable to all new users, so if
you found something unclear, don't sit and blame yourself - complain!

Comments on this document should be sent to (LOIS) on system 33.
     2PEAK.TXT     |30-Apr-84 12:17:00  NOCTUK    PEAK Reference Guide               Version 2.0                       Page 1


BASIC INFORMATION

    This is a brief guide to the screen editor PEAK.  For every PEAK
    command there is a short description followed by the PEAK function
    name enclosed in brackets.  The commands are grouped by topic.

Other Documentation

    Other available documentation include (sysnews)peak.key which
    contains a list of commands by key bindings and (sysnews)peak.cht
    which is a chart (132 characters wide) of bindable keys with the
    PEAK default function bindings.  Peak.cht can be printed out or
    copied to your directory and used to keep track of additional
    bindings.

Naming Conventions

    In this guide "^" means to hold the CONTROL key down while typing
    the next character, "ESC" means to type the ESCAPE key and then the
    next character.  Portions of commands in brackets are optional.

PEAK Tutorial

    The on-line tutorial, (sysnews)peak.tut, is designed for the new PEAK
    user.  To use the tutorial, type "peak (sysnews)peak.tut" (for monitors
    previous to "L", type "r peak" and then "^X ^R (sysnews)peak.tut".)

Use of PEAK

    PEAK is intended for Tymshare internal use only.

Accessing PEAK

    PEAK is accessible by the monitor command 'PEAK'.  The complete
    command is PEAK [filename] [/Pn] [/Ln] [/Cn] [/R] [/N] where /Pn,
    /Ln and /Cn specify the page, line and character number on which to
    start editing, /R will read in the file "Read Only" (no modification
    allowed),and /N will not delete nulls in the file.

    The monitor command 'PEAK' is not available in monitors previous to
    P034L.  To set up PEAK as a default editor on a system with an
    earlier monitor, see the instructions on page 17.
    
Terminal Type

    If you do not have tty class set, PEAK will ask for your terminal
    type.  If you are not sure what your terminal type is, typing "?"
    at the "Terminal type?"  prompt will give a list of supported
    terminals.  (To set your terminal type see page 17.)
PEAK Reference Guide               Version 2.0                       Page 2


PEAK COMMANDS

Moving Around - Basic Cursor Movement

    ^F              Move forward                                  [Forward]
    ^B              Move backward                                [Backward]
    ^A              Move to beginning of line           [Beginning of Line]
    ^E              Move to end of line                       [End of Line]
    ^N              Move to next line                                [Down]
    ^P              Move to previous line                              [Up]
    ESC F           Move forward over token                 [Forward Token]
    ESC B           Move backward over token               [Backward Token]

    You can think of a "token" as being a word or a number.  To have other
    characters included with the word or number, define them as tokens or
    numbers with the "Is Token" or "Is Number" command (see page 10).
    Your "peak.ini" file is a good place to define token characters.

    ESC {           Move to top of page                       [Top of Page]
    ESC }           Move to bottom of page                 [Bottom of Page]

Moving Around in the Window

    Unless you have split the screen into two windows (see page 5), 
    "window" is synonymous with "screen" in the following commands.

    ESC ,           Move to top of window                   [Top of Window]
    ESC .           Move to end of window                [Bottom of Window]
    ^V              Move to next window                    [Forward Window]
    ESC V           Move to previous window               [Backward Window]
    ^Z              Scroll window up                     [Scroll Window Up]
    ESC Z           Scroll window down                 [Scroll Window Down]
    ESC !           Move line to top of window      [Line to Top of Window]

Moving Around in the Buffer

    ESC <           Move to top of buffer                   [Top of Buffer]
    ESC >           Move to bottom of buffer             [Bottom of Buffer]

    PEAK does not edit the file itself; it reads the file into a buffer and
    all editing is done there.

Setting the Argument

    ^U [n]          Set argument to n (default 4)                [Argument]

    (See the detailed explanation on page 14)
PEAK Reference Guide               Version 2.0                       Page 3

   
Setting "Marks"

    ESC <space>     Set a "mark" in the buffer                   [Set Mark]

    Up to ten marks can be set.  All mark commands can be given an argument
    to specify which mark will be referenced by the command.  For example,
    "ESC <space>" sets mark 0, "^U 5 ESC <space>" sets mark 5.

    ESC G           Go to a mark                                [Goto Mark]
    ^X S            Exchange the point and mark                 [Swap Mark]

    "Point" is the present position of the cursor.

    ESC X Clear Mark ESC
                    Clear mark                                 [Clear Mark]
Deleting

    ^D              Delete character                               [Delete]
    ^H              Delete previous character             [Delete Backward]
    ESC D           Delete token                     [Delete Token Forward]
    ESC H           Delete previous token           [Delete Token Backward]
    ^K              Kill line                                   [Kill Line]
    ESC K           Kill to end of line                 [Kill Partial Line]

    ^K kills the line from point to end of line including the crlf at the
    end of the line, ESC K kills either the line from point to end of line,
    or the crlf.  Note:  ESC K will not kill a form feed, ^K will.  Giving
    ESC K a large argument will kill to the end of the page and stop there.

    ^W              Kill to a mark                            [Wipe Region]
    ^Y              Recover killed text                [Insert Kill Buffer]

    All text killed by successive kill commands will be in the kill buffer.
    After issuing any other command, or inserting any character, a
    subsequent kill operation will delete the previous contents of the kill
    buffer and replace it with the most recent kill.

    To append a subsequent kill to the kill buffer, give the following
    command before doing the kill:

    ESC X Set Append Kill ESC     Append next kill to kill buffer
                                                          [Set Append Kill]

    If the amount of text killed will overflow the size of the kill
    buffer PEAK will prompt you as to what action to take.  "A(bort)" will
    cancel the kill, "P(roceed)" will wipe out all of the text, and
    "S(ave)" will wipe out exactly the amount of text that will fit in the
    kill buffer.  Note you only have to type a single letter response and
    PEAK will fill in the rest of the word for you.

PEAK Reference Guide               Version 2.0                       Page 4


Inserting

    All normally printing characters insert themselves when typed.  This
    includes RETURN and TAB.  To insert any other character you must
    "quote" it by preceeding it with ^Q.
        
    ^Q              Insert the next character                       [Quote]

Searching/Replacing

    ESC S           Search                                         [Search]
    ESC R           Reverse search                         [Reverse Search]

    The complete command is "ESC S <string> ESC".

    ^S              Repeat last search                       [Search Again]
    ^R              Repeat last reverse search       [Reverse Search Again]

    ESC M           Multiple string search                [Multiple Search]

    "ESC M <string1> ESC <string2> ESC ... <stringn> ESC ESC" is the 
    complete command; n is any number up to 10.  You can repeat the search
    with "ESC M ESC".

    ESC =           Show search String                 [Show Search String]
    ESC )           Search for matching close parenthesis    [Match Parens]
    ESC (           Reverse search for matching open parenthesis 
                                                             [Match Parens]
    ESC X Copy to Search ESC
                    Copy region from point to mark into search string
                                                           [Copy to Search]

Substitution

    ESC C           Change                                         [Change]

    The complete command is "ESC C <string1> ESC <string2> ESC".

    ESC Q           Query change                             [Query Change]

    Responses to the query change command are: "Y","y", or <space> - yes,
    change this string;  "." - change this string and stop; "^G" - stop.
    Any other character continues searching without replacing the target 
    string.
    
    ESC X Repeat Query Change ESC
                    Repeat last query change          [Repeat Query Change]

    Note that an argument to a substitution command is a repeat count (see
    page 14); however, the default is to repeat execution of the command
    until the end of the file rather than a single execution.
PEAK Reference Guide               Version 2.0                       Page 5


Indentation

    ESC I           Indent a line (add leading whitespace)    [Indent Line]
    ESC U           Unindent a line (remove leading whitespace) 
                                                            [Unindent Line]
    ESC X Indent Region ESC 
                    Indent region from point to mark 0      [Indent Region]
    ESC X Unindent Region ESC  
                    Unindent region from point to mark 0  [Unindent Region]

    Indentation width for these four commands is set by the environment
    variable IndentWidth; variable SwapPMRegion determines the
    location of the point after the region commands (see page 12).

    ESC X Force Left Margin ESC
                    Indent line to the column specified by the argument
                                                        [Force Left Margin]
    If no argument is given, the value of the left margin is used.

    ^J              Start new line at current indentation 
                                                    [Open Line with Indent]
    ESC X Indent Line Up ESC   
                    Create new line above at current indentation
                                                           [Indent Line Up]
    ESC X Indent Column Down ESC   
                    Create new line indented to the current column
                                                       [Indent Column Down]
                                                     
Manipulating Buffers

    ^X <            Move to previous buffer                   [Last Buffer]
    ^X >            Move to next buffer                       [Next Buffer]
    ^X !            Recover checkpoint file       [Recover CheckPoint File]
                        (See page 16)
    ^X ^N           Build a scratch buffer                     [New Buffer]
    ^X ^K           Delete this buffer                      [Delete Buffer]
    ^X ^S           Checkpoint this buffer                     [Checkpoint]
    ^X ^U           Recover last checkpoint            [Recover Checkpoint]

    You can force a checkpoint by ^X ^S, and then edit, knowing you can 
    return to the state of the file at the checkpoint by ^X ^U.  The file
    will be automatically checkpointed if there have been no changes for 
    the number of seconds set as the checkpoint interval, or if you move
    to another file in the buffer chain.

Manipulating Windows

    ^X 2            Use 2 windows                            [Split Window]
    ^X 1            Use 1 window                           [Unsplit Window]
    ^X ^O           Go to other window                     [Switch Windows]
    ^X G            Enlarge window                            [Grow Window]

    Windows may be two places in one file, or two different files

    ESC X Window Bar ESC
                    Set character(s) for window bar            [Window Bar]
PEAK Reference Guide               Version 2.0                       Page 6


Finishing Up

    ^X ^F           Write files and exit                           [Finish]
    ^X ^C           Exit without writing files                  [Safe Exit]
    ^X ^E           Write files and return to caller        [Finish to RPG]

Reading/Writing Files

    ^X ^R           Read a file into a new buffer               [Read File]

    The complete command is "^X ^R <filespec> ESC".  Switches /Pn, /Ln
    /Cn, /N and /R are the same as in accessing PEAK.

    ^X ^I           Insert a file into the current buffer     [Insert File]
    ^X ^W           Write the current buffer                   [Write File]

    "^X ^W ESC" writes out the current buffer with the current filespec.

Locking Files

    ^X -            Lock file (prevents modifications)        [Lock Buffer]
    ^X +            Clear file lock                         [Unlock Buffer]

Other Things of General Interest

    ^G              Abort command                           [Abort Command]

    Very useful command that aborts whatever command you have begun to type

    ^L              Repaint the screen                     [Refresh Window]

    ESC ?           Display buffer chain and on-line help            [Help]
    ^X ?            Display name of function bound to key  [Query Function]
    ESC ~           Clear "buffer modified" flag          [Unmodify Buffer] 
    ^X "            Display string on message line (" terminates) 
                                                            [Start Message]
    ^X ^T           Show date and time                  [Date Time Message]

Modes

    ^X N            Put PEAK in "Normal" mode                 [Normal Mode]
    ^X T            Put PEAK in "Text" mode                     [Text Mode]

    In "Text" mode PEAK will automatically insert carriage returns to keep 
    your text within your defined left and right margins.

    ESC O           Toggle "Overwrite" flag         [Toggle Overwrite Flag]
    ESC W           Toggle "Wrap" flag                   [Toggle Wrap Flag]

    Characters inserted in "overwrite" mode will replace the following
    text.  "Wrap" controls whether overlong lines wrap to the next line or
    disappear off the screen.  In either case a vertical bar will appear on
    the rightmost column on the screen to indicate an overlong line.
PEAK Reference Guide               Version 2.0                       Page 7


Fancier Text Manipulation

    ESC ^W          Copy text between point and mark to kill buffer
                                                              [Copy Region]
    ^O              Open the line                               [Open Line]
    ESC X Center Line ESC
                    Centers line within set margins           [Center Line]
    ESC X Show Column ESC
                    Column number appears on message line     [Show Column]
    ESC X Column Insert ESC
                    Fill to specified column with specified character(s)
                                                            [Column Insert]

    Complete command: ESC X Column Insert ESC <character(s)> ESC

    ESC X Goto Column ESC
                    Move to column given in argument          [Goto Column]

    Complete command: ^U [n] ESC X Goto Column ESC

    ^T              Twiddle (swap) the last two characters      [Transpose]
    ESC ^J          Right justify line from point to end of line
                                                       [Right Justify Line]
    ^X W            Delete whitespace           [Delete Whitespace Forward]

    Deletes whitespace from point to first character forward on line.

    ^X V            Delete preceeding whitespace
                                               [Delete Whitespace Backward]

    ESC X Down Paragraph ESC
                    Move to next paragraph boundary        [Down Paragraph]
    ESC X Up Paragraph ESC
                    Move to previous paragraph boundary      [Up Paragraph]

    A  paragraph boundary is the beginning or end of a paragraph.

Case Commands

    ^^              Toggle case of character                  [Toggle Case]
    ESC ^           Toggle case of word                      [Toggle Token]
    ESC X Capitalize Token ESC    
                    Capitalize token                     [Capitalize Token]
    ESC X Token LC ESC            
                    Make token all lower case                    [Token LC]
    ESC X Token UC ESC            
                    Make token all upper case                    [Token UC]
PEAK Reference Guide               Version 2.0                       Page 8


Fill Commands

    ESC P           Fill paragraph                         [Fill Paragraph]
    ESC X Fill Line ESC
                    Fill Line                                   [Fill Line]
    ESC X Fill to End of Paragraph ESC
                    Fill from point to end of paragraph
                                                 [Fill to End of Paragraph]

    ESC P fills the paragraph using the current left and right margins.
    "Fill" will reformat the text of the paragraph so that the maximum
    number of words possible appears on each successive line.

    The indentation of the first line of the paragraph in relation to the
    second line of the paragraph will be preserved in filling.  This
    enables the use of crowns.

    The environment variable VariableFill will determine the location of
    the point upon completion of ESC P, and also the result of giving an
    argument to the command.  If the value of VariableFill is 0, an
    argument to ESC P will be a repeat count, and the point will be on the
    beginning of the line after the last paragraph filled after execution
    of the command.  This is the default.

    If VariableFill is non zero, an argument will set the right margin and
    the point will be following the last character of the current paragraph
    after execution of the command.  This makes successive filling of the
    same paragraph with different right margins easy to accomplish.

    ESC X Fill to End of Paragraph ESC will fill from the point to the end
    of the current paragraph (ESC P fills from the beginning of the
    paragraph to the end of the paragraph).  The value of VariableFill
    determines the behavior of arguments and the location of the point upon
    completion in the same way as ESC P.

    ESC X Fill Line ESC will fill to the end of the current line.

Setting Margins

    ESC X Set Right Margin ESC
                   Set right margin at point or to value of argument
                                                         [Set Right Margin]
    ESC X Set Left Margin ESC
                   Set left margin at point or to value of argument
                                                          [Set Left Margin]

    Margins are used for "text" mode, fill, justify, and center commands.
    Margins may also be set by the environment variables RightMargin and
    LeftMargin (see page 12).

PEAK Reference Guide               Version 2.0                       Page 9


Macros and Key Bindings

    ^X D            Define a macro                           [Define Macro]
    ^X E            Define a macro by example     [Define Macro by Example]
    ^X X            Execute current macro                   [Execute Macro]
    ^X M            Bind macro to key                          [Bind Macro]

    Keyboard macros can be defined in two ways.  The command "^X D" allows
    you to define a macro before it is executed.  The first character you
    type will be the delimiter which will be used at the end to terminate
    the definition of the macro.  The command line at the bottom of the 
    screen will display your macro as you type it in, and you can edit it 
    with ^H if necessary.  To include a ^H in your macro you will have to 
    "quote" it with ^Q.

    The command "^X E" will define a macro to be all the commands you 
    execute until you type a ^G.

    To save the macro for later use it can either be bound to a key using 
    "^X M" or can be "named" to a name of your choice using the command
    "ESC X Name Macro ESC name ESC". 

    The present macro can be executed by "^X X".  A bound macro can be 
    executed by using the bound key, and a named macro is executed in the 
    same manner as an unbound function, using "ESC X name ESC".  Arguments
    work as expected.  Execution of the macro is aborted at the end of the 
    file.

    ESC X Unbind Key ESC key
                    Remove most recent macro binding to key   [Unbind Key]
    ESC X Unname Macro ESC name
                    Remove most recent macro binding to name
                                                            [Unname Macro]

    When a macro is bound to a key, the previous binding of the key is
    remembered.  If you then unbind the key using "ESC X Unbind Key ESC
    key" the old binding is restored.  Similarly named macros can be
    unnamed with "ESC X Unname Macro ESC name ESC".

    A bound macro can be displayed in the message line by "^X ?".

    ^X B            Bind function to key                    [Bind Function]
    ^X [            Push key binding onto stack              [Push Binding]
    ^X ]            Pop key binding off stack                 [Pop Binding]

Command Files

    ^X ^L           Execute command file                     [Command File]
    ^X |            Start comment (for command file) (| terminates)      
                                                            [Start Comment]
PEAK Reference Guide               Version 2.0                      Page 10


Defining Special Characters

    ESC X is special ESC <char> ESC
                    Defines <char> as "special" character 
    ESC X not special ESC <char> ESC
                    <char> is no longer "special"

    These two commands define (or cancel definitions) for use with the
    following two special character search commands.

Special Character Searching

    ESC ;           Search for "special" character         [Special Search]
    ESC :           Reverse "special" search       [Reverse Special Search]

Defining Tokens

    The following definitions apply to ESC B, ESC F, ESC H and ESC D
    commands:

    ESC X is delim ESC <char> ESC
                    Defines <char> as a delimiter, which is the opposite
                    of a "token" for these commands.
    ESC X is number ESC <char> ESC
                    Defines <char> as "number".                    
    ESC X is token ESC <char> ESC
                    Defines <char> as "token".                    
    ESC X not delim ESC <char> ESC
                    <char> no longer a delimter.
    ESC X not number ESC <char> ESC
                    <char> no longer a "number".
    ESC X not token ESC <char> ESC
                    <char> no longer a "token".

Executing Functions by Name

    ESC X           Execute a function by name           [Execute Function]

    The complete form is "ESC X <function name> ESC".  Only enough letters
    of the function name need to typed to make that function unique.  If
    you do not type enough to make it unique, the error message "is
    ambiguous" will appear on the message line, otherwise the function name
    will be completed when you type the final ESC.

    All functions in PEAK have a function name.  The function names have
    been given in brackets for all commands.  Some functions are not bound
    to keys, and must be accessed by name.  They are listed on the
    following page.

    Any of the unbound functions can be bound to a key using the "^X B"
    command.  If an unbound function is used frequently, it can be bound
    to a key in your "peak.ini" file (see page 15).
PEAK Reference Guide               Version 2.0                      Page 11


    Functions Not Bound to a Key

    Beep                 Ring bell
    Capitalize Token     Upper case letter at point, rest of token lower case
    Center Line          Center current line within set margins
    Clear Mark           Clear mark
    Column Insert        Fill to specified column with specified character(s)
    Copy to Search       Copy region into search string
    Creaux               Build an aux circuit and record into buffer
    Decrement Char       Decrement ASCII value of character after point
    Delete NULLs         Delete NULLs in file
    Down Paragraph       Move down to next paragraph end or beginning
    Fill Line            Fill to end of current line
    Fill to End of Paragraph  Fill to end of current paragraph
    Force Left Margin    Indent line to left margin or argument given
    Goto Column          Move to column given in argument or end of line
    Increment Char       Increment ASCII value of character after point
    Indent Column Down   Create a new line indented to current column
    Indent Line Up       Create a new line above at current indentation
    Indent Region        Indent region from point to mark 0
    Insert Octal         Insert character with ASCII value of octal
    Is Delim             *Define character as a delimiter
    Is Number            *Define character as number
    Is Special           Define "special" character for ESC : and ESC ;
    Is Token             *Define character as a token
    Name Macro           Give present macro a name
    Not Delim            *Define character as not a delimiter
    Not Number           *Define character as not a number
    Not Special          Not a "special"character for ESC :, ESC ;
    Not Token            *Define character as not a token
    Nothing              Do nothing
    Repeat Query Change  Repeat last query change 
    Set Append Kill      Append next kill to kill buffer
    Set CreAux Esc Char  Set escape character for aux circuit (see page 13)
    Set Left Margin      Set left margin at point or to argument
    Set Right Margin     Set right margin at point or to argument
    Set Terminal Type    Set the terminal type to given type
    Show Column          Display number of column after point
    Show Octal           Display octal value of character after point
    Token LC             Make token all lower case
    Token UC             Make token all upper case
    Unbind Key           Remove most recent macro binding to key
    Unname Macro         Remove most recent macro binding to name
    Unindent Region      Unindent region from point to mark 0
    Up Paragraph         Move to previous paragraph end or beginning
    Window Bar           Set character(s) for window bar
    XOFF Synch           Allow XON/XOFF handshaking

    *for token commands ESC B, ESC F, ESC D, ESC H.

PEAK Reference Guide               Version 2.0                      Page 12


Information Strings

    ^X I            Insert information string   [Insert Information String]

    Will insert an information string into the file.  Complete form is
    "^X I <I-Str> ESC".  Presently defined information strings are:

        Date        Present date as dd-mmm-yy (29-Feb-84)
	Time        Current time as hh:mm:ss (17:15:19)
	Username    Logged in username in uppercase (NAME)

Environment Variables

    ^X =            Query the value of a variable          [Query Variable]
        The complete form is "^X = <variable name> ESC"
    ^X _            Assign the argument to the variable     [Bind Variable]
        The complete form is "^Un^X _ <variable name> ESC"

    Only enough letters of the environment variable to make it unique
    need to be typed;  Current environment variables and defaults are:

    Variable         Default       Purpose
    --------         -------       -------

    BreakPageOnFF         1        When nonzero, page will break on ff
    CheckpointInterval   60        Time in seconds for checkpointing
    EscapeAs$             1        When nonzero, ESC printed as $
    ExactCaseMatch        0        Controls case matching in searches;
                                     when nonzero, matching is exact
    IndentWidth           2        Indentation width for indent commands
    LeftMargin            1        Margin control for "fill paragraph"
    Multiplier            4        Default for "Argument" command
    OverWriteOnInsert     0        When nonzero, overwrites
    RightMargin          72        Margin control in "text" mode
    SwapPMRegion          0        If zero, location of point does not
                                    change after indent and unindent region,
                                    insert file and insert kill buffer
    WrapLongLines         1        When nonzero, long lines will wrap
    TabWidth              8        Controls tab stops
    UseTabs               1        For indent command; will change spaces
                                     to TABs where possible if nonzero
                                   Also will insert spaces for TAB if zero
    VariableFill          0        When nonzero, argument to "fill 
                                     paragraph" will set right margin,
                                     instead of setting repeat count
PEAK Reference Guide               Version 2.0                      Page 13


Auxiliary Circuits

    ESC X Creaux ESC
                    Build aux circuit and record into buffer       [Creaux]

    ESC X Creaux ESC will build an auxiliary circuit to the specified
    username:system.  It defaults to the current system and logged in
    username.  The login must be a legal TYMNET login, or the circuit will
    be zapped.  All output of the aux circuit session will be recorded in
    the current buffer.  Logging out will zap the circuit, and the output
    then may be edited.

    ESC X Set Creaux Esc Char ESC
                    Set aux circuit escape character  [Set Creaux Esc Char]

    Redefine the Creaux escape character.  The complete command is 
    ESC X Set Creaux Esc Char ESC <char>.  The PEAK default definition for
    the Creaux escape character is ^X.

    There are three special commands for use during an aux circuit session,
    all of which are preceeded by the Creaux escape character:

    <esc char> Q    Quit from aux circuit session, but retain circuit.

    <esc char> Z    Zap the aux circuit.

    <esc char> C    Change the Creaux escape character - the next character
                    received will be the new value.

    After quitting from an aux circuit session with ^X Q, a subsequent
    command to create an aux circuit with ESC X Creaux ESC will resume
    the previous aux circuit session.

    To send the character defined as the Creaux escape character through it
    is sent twice:

    <esc char> <esc char>  Send the escape character through.

PEAK Reference Guide               Version 2.0                      Page 14


FURTHER INFORMATION AND EXPLANATIONS

Setting the Argument

    Every command is passed a numeric argument which, unless set
    explicity, is zero.  The argument usually sets the repeat count for
    the command (the default of zero causes a single execution of the
    command).

    For some commands the argument will pass a value to the command.  The
    argument for commands dealing with marks is used to specify which of
    the ten marks to use.  The argument with the fill commnds will set
    the right margin if the value of the VariableFill environment
    variable is non zero (see page 8).  An argument to the ^X _
    command will set the value of the envrionment variable specified.

    To set the argument type ^U followed by a number.  The next command
    typed will be passed that number.  If no number is typed a default
    "multiplier" will be used.  The default value of the multiplier is 4.
    Hence the command string ^U10^F will send the argument 10 to ^F,
    which in turn will cause it to move forward over 10 characters.  The
    string ^U^F would send the default argument of 4.

    The current value of the argument will be displayed on the message
    line when the ^U command is given.  For example, the default
    number of 4 will be shown when ^U is typed.  If ^U is followed
    by the number 10, the message line will then display "Arg: 10".

    Arguments can be multiplied.  If an argument is passed to ^U it
    will multiply it against the next argument given.  The string
    ^U10^U3^N first sends an argument of 10 to ^U, which multiplies
    that against 3, and passes 30 to ^N, which will then move down
    30 lines.  Likewise, ^U^U^N will move down 16 lines.

    The multiplier may be changed to some number other than 4 by using
    the assign environment variable command "Un^X _ Multiplier ESC".
PEAK Reference Guide               Version 2.0                      Page 15


Peak.ini

    When PEAK starts up it looks for a file named "PEAK.INI" on your
    logged in directory (NOT the GFD'd directory) for special
    initialization commands.  A PEAK.INI should start by locking the file
    so that stray characters in PEAK.INI won't cause inadvertent
    modifications to the buffer.  PEAK.INI must end by unlocking the file
    if it has been locked, with NO carriage return following.

    A sample PEAK.INI, which sets the indentation width to 6, defines a
    macro to go to the top of the next page, and binds the macro to
    Meta-N and Meta-n, is:

        ^X-
        ^X| Lock file |

        ^X| Sample PEAK.INI |

        ^X| set the indentation width to 6 |
        ^U6^X_IndentWidth$

        ^X| define a macro to get to the top of the next page |
        ^Xd/$}^N/

        ^X| bind the macro to Meta-N and Meta-n |
        ^Xm$N
        ^Xm$n

        ^X| Unlock file|
        ^X+             

    NOTE:  There is NO carriage return at the end of the last line.

Backup Files

    PEAK will write a file with the extension "bak" for each file you
    edit.  When you write out your edited buffer with either ^X^W or
    ^X^F, PEAK renames the original file to <filename>.bak, after
    deleting the old <filename>.bak (if one exists), and then writes 
    out the current edit.

    Thus the .bak file normally will contain a copy of the file before 
    you began the current edit.  However, if you write out the file in
    the middle of your edit with a ^X^W, the .bak file will contain
    the file at the state of the previous write.

    Should you be editing more than one file with the same name (but 
    different extensions) read into different buffers, the .bak file
    will contain a backup for only one of the files.
PEAK Reference Guide               Version 2.0                      Page 16


Status and Message Lines

    The status line at the bottom of the editing window gives the following
    information:  Editor name  Version number (Terminal type  Major mode
    [+],  [Wrap]  [Over])  [<]  File name  [>]  - Cursor position in file -
    [*]  [$]  [Mail.]  with:
        Major mode  Text or Normal
        +           Executed peak.ini
        Wrap        Wrap flag set
        Over        Overwrite flag set
        <           Previous buffer(s) exist in buffer chain
        >           Subsequent buffer(s) exist in buffer chain
        *           Buffer modified flag
        $           File read only
        Mail.       XEXEC mail waiting

    Cursor position is given in percent of file before the cursor, or
    Top or Bottom.

    Below the status line, the message line gives prompts and information
    from PEAK.

Continuing PEAK after Attaching to Detached Job

    If you are dropped in the middle of an edit, have detach-on-disconnect
    set and it was not a host crash, you can continue your edit without
    losing anything when you are able to log in again.  Attach to your
    detached job, ESC (or ^C if you are in PDP10 mode), continue, and
    then ^L.  The ^L not only refreshes the screen, but also will reset 
    your terminal characteristics for the duration of the edit.

Recovery from Checkpoint

    If the system crashes in the middle of the edit, and there is a 
    checkpoint file, you can recover your edit to the point of the
    checkpoint.  (If you have just lost your line, and have a detached
    job, proceed as above to recover all your edit).

    Check your directory for the checkpoint file, which will be of the
    form 003PEA.001, where 003 is your old job number, and 001 is the
    buffer number.  It is wise at this point to check your present job
    number (by the command "who.")  and if you should have the same job
    number you MUST rename the checkpoint file to another name before
    attempting recovery.

    It is usually a good idea to rename the checkpoint file to something
    easier to remember.  Then invoke PEAK by either the command "peak" or
    "r peak" (for monitors K and earlier).  Immediately upon entering
    PEAK give the command "^X !".  PEAK will prompt for the checkpoint
    file name.  Your old edit will then be restored to the point at which
    it was checkpointed.
PEAK Reference Guide               Version 2.0                      Page 17


SETTING UP PEAK AS DEFAULT EDITOR:

    PEAK can be set up as the default editor on a system by:

      -ctest addpro editor=(sys)peak  

    You can now access PEAK with 

      -ed <filename>

    or

      -mod <filename>

    If you want to make this permanent give the following command after
    the first ctest command:

      -ctest makini

    This will create a file "rpg.ini" on your directory which will be read 
    to set up the editor when you give a command.

    Once PEAK is set up as the default editor, the file name is remembered
    for subsequent editing or compiling commands.

SETTING UP TERMINAL TYPE:

    So PEAK will not ask for your terminal type you can type

      -tty class <terminal type>

    where terminal type is one of those PEAK recognizes.  To get a list
    of supported terminal types, type a "?" at the Terminal type? prompt
    from PEAK.

SWITCHES:

    If PEAK is set up as a default editor, the file switches can be given
    by using "%" instead of "/".  For example

      -mod foo%p6

    would read in file "foo" and place you at page 6 of the file.

EDITOR:

    PLEASE NOTE:  If PEAK is set up as the default editor, commands that
    normally access the editor EDITOR will all go to PEAK.  In order to
    use EDITOR the user will have to enter

      -r editor

    and then use APPEND or READ to create or modify a file.  Since these
    commands do not bring the file identifier into EDITOR, the file must
    be then written out with the file name specified using WRITE, or EXIT.
 
      2PEAK.WSH     À10-May-83 23:18:13  CEWMAF    This is the state of the PEAK "A/B/C" priority list as of Version 1.0
(circa 22-Nov-1982):

!    [A+]	A kill-line which takes crlfs with it.
!    [A+]	Preserve file protections.
!    [A+]	PEAK Exec command support (interface w/ RPG).
!    [A+]	Should lonely CRs show as "&" (as they do now) or as "^m"?

    [B]		Support "big" files (> 400 pages).
    [C]		"Push" to another frame.
    [B-]	Read region from file.			Enlarge kill buffer.
    [B-]	Write region to file.			Enlarge kill buffer.
    [C]		Iteration structures for macros (?)	Underlying Language

    [C]		Macro files.
    [C]		Load macros from buffer.
    [?]		Allow editing in kill buffer
    [B]		"Oops" command to recover last position.
    [?]		Recover Line (?)
    [A]		Fill / Justify commands.
    [B]		Incremental search commands.
!    [C+]	Case-matching substitute (?)
    [A]		Show absolute page/line #s of the line at the top of the
		  window. 
    [A]		Goto page/line.
    [C]		^u^l to redisplay the current line only.
    [B]		Detabify / Tabify region commmands.
    [B]		Honor "notice to quit" interrupts.
    [C]		Aux-circuit as a buffer.
    [C]		Ciphering.
    [?]		Super-region (for confining the domain of such things as
		  search and replacement).
    [?]		Pattern-search (akin to c128 mode of SOS or Unix/Vi
		  search strings).
    [?]		TOPS-20 terminal support (^s^s^q = ^s to PEAK)
!    [A]	Recovery from crashed checkpoint files.
    [?]		Commands should produce a trace in the message line.
    [?]		Left Margin should work correctly everywhere.
    [?]		$x?<esc> - help-like list of binding names.
-    [?]	A1200 Terminal support.
    [?]		Matched delimiter pairs (begin ...end).
    [?]		Force character to UC/LC.
    [?]		Force redisplay (by pause?) (<TJB)
    [?]		Move window <- or -> in the display (like TV Edit's
		  line-wrap policy).
!    [A+]	Delete whitespace backward (1.1(110)) >@o