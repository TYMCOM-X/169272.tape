	TITLE CBRT V.002 SINGLE PRECISION CUBE ROOT
	SUBTTL DECEMBER 1,1970 BY RE NEWMAN
;
;   THIS ROUTINE CALCULATES THE SINGLE PRECISION CUBE ROOT
;   OF A SINGLE PRECISION ARGUMENT BY ONE NEWTON-RAPHSON ITERATION
;   USING A PADE 1ST ORDER APPROXIMATION AS A STARTER.
;
;	METHOD:
;	1) SIGN OF ARG IS RECORDED AND MAGNITUDE TAKEN
;	2) ARG IS FACTORED INTO  THE FORM (2**N)*F
;	   WHERE F IS A FRACTION >=1/2
;	3) N IS FACTORED INTO THE FORM L-K
;	   WHERE L IS A MULTIPLE OF 3 AND
;	   K IS 0,1,OR 2
;	4) THE FRACTION M=(2**-L)*F IS THEN IN THE RANGE 1/8<=M<1.
;	  THE FIRST ESTIMATE X0 OF M**(1/3)
;	  CALCULATED WITH A PEPE APPROXIMATION:
;		X0=C0-C1/(M+B1)
;	  WHERE THE CONSTANTS DEPEND ON WHETHER L=0,1,2
;	5) X0 IS THEN USED AS THE INPUT ESTIMATE OF ONE
;	   NEWTON-RAPHSON ITERATION:
;		M**(1/3)=X1=X0/2+(3/2*M)/(2*X0**2+(M/X0))
;	6) THE CUBE ROOT IS THEN FOUND BY:
;	   X**(1/3)=2**(L/3)*M**(1/3)
;
;
;	METHOD IS SUGGESTED IN THE ARTICLE:
;		COMPUTATION OF SIN,COS,AND N**(1/M)
;		USING AN ELECTRONIC COMPUTER BY EG KOGBETLIANTZ
;		IBM JOURNAL APRIL 1959
;
;	METHOD IS ACCURATE TO 27 BINARY BITS AND ABOUT 8 DIGITS
;	AVERAGE TIME 60,000 CALLS IS 2.86 MILLSECONDS
;
;   ACCUMULATOR ASSIGNMENTS
	A0=0
	A1=1
	A2=2
	A3=3
	A16=16
	ENTRY CBRT
CBRT:	0
	MOVEM A1,SAC1	;SAVE AC1
	SETZM SIGN	;CLEAR SIGN FLAGS;FOR ARG
	SETOM SIGE	;AND EXP 1'S=NEG
	MOVM  A1,@(A16) ;GET MAGNITUDE OF ARG
	JUMPE A1,CB2	;RETURN ZERO FOR ZERO ARG
	CAME  A1,@(A16)	;SKIP IF ARG IS POSITIVE
	SETOM SIGN	;SET FLAG IF ARG IS NEG
	MOVEM A2,SAC2	;SAVE AC2
	SETZ  A2,	;CLEAR AC2
	MOVEM A3,SAC3	;SAVE AC3;NEEDED FOR LONG ARITH
	SETZ A3,	;CLEAR AC3
	SETZ A0,	;CLEAR AC0
	ASHC  A1,-33	;LEAVE EXPONENT IN AC1
	ASH   A2,-10	;RT JUSTIFY MIN AC2
	SUBI A1,200	; ADJUST EXCESS EXPONENT ZERO=200(8)
	MOVE A0,A1	;GET SET FOR IDIVI
	JUMPL A0,PADE	;JUMP IF EXP IS NEG
	SETZM SIGE	;SET EXP SIGN FLAG TO POSITIVE
 	ADDI  A0,2	;IT WAS POS ADD 2 
PADE:	IDIVI A0,3	;REM IS PUT IN A1 WITH NEG SIGN
	MOVEM A0,EXP	;SAVE EXPONENT
	SKIPN SIGE	;WAS EXP NEG?
	SUBI A1,2	;NO ADJUST REM
	FSC  A2,200(A1)	;SUPPLY EXP TO M
	MOVEM A2,SAVM	;SAVE M FOR N-R
	FADL A2,B1(A1)	;A2=M+B1(R)
	MOVE A0,C1(A1)	;GET DIVIDEND
	FDV	A0,A2	;A0=A0/A2
	MOVE A2,C0(A1)	;LOAD C0(R)
	FSBL  A2,A0	;M(1/3)=X0=C0-C1/(M+B1)
NEWTON: MOVEM A2,SAVX0	;SAVE INIT ESTIMATE X0
	MOVE A0,SAVM	;A0=M
	FSC  A0,-1	;A0=M/2
	FAD  A0,SAVM	;A0=M+M/2=NUMERATOR
	MOVE A1,SAVM	;A1=M
	FDV  A1,A2	;A1=M/X0
	FMPL A2,A2	;X0*X0
	FSC	A2,1	;A2=2*A0**2
	FAD A2,A1	;A2=DENOM
	FDV A0,A2	;A0=NUM/DEN
	MOVE A2,SAVX0	;A2=X0
	FSC A2,-1	;A2=X0/2
	FADL A2,A0	;X1=A2
	MOVE A1,EXP	;GET EXPONENT
	FSC A2,(A1)	;COMBINE PARTS, CBRT IN A2
	MOVE A0,A2	;ANS MUST BE IN AC0
	SKIPE SIGN	;WAS ARG POS
	MOVN A0,A0	;NEG ANS WHEN ARG WAS NEG
	MOVE A2,SAC2	;RESTORE AC2
	MOVE A3,SAC3	;RESTORE AC3
	SKIPA
CB2:	SETZ A0,	;ANS=0 IF ARG = 0
	MOVE A1,SAC1	;RESTORE AC1
	JRA A16,1(A16)	;RETURN
SAC1:	Z	;AC1 STORAGE
SIGN:	Z	;FLAG FOR SIGN OF ARG
SIGE:	Z	;FLAGE FOR SIGN OF EXPONENT
SAC2:	Z	;AC2 STORAGE
SAC3:	Z	;AC3 STORAGE
EXP:	Z	;CALCULATED EXP OF ANS
SAVM:	Z	;STORE PADE M
SAVX0:	Z	;STORE X0
	1.12625 ;R=-2 1/8<=M<1/4
	1.418986;R=-1 1/4<=M<1/2
C0:	1.78781	;R=0 1/2<=M<1.0
	.3016708	;R=-2
	.7601607	;R=-1
C1:	1.91548		;R=0
	.35714		;R=-2
	.71428		;R=-1
B1:	1.42856	;R=0
	PRGEND
	TITLE	MAX	V.32(415)
	SUBTTL	22-MAY-72	ED YOURDON/TWE/DMN/KK
;***COPYRIGHT 1969,1970,1971,1972 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

;FROM V.005.
;AMAX1, MAX1, AMAX0, AND MAX0 CALCULATE THE MAXIMUM OF A
;STRING OF ARGUMENTS, THE FIRST ADDRESS OF WHICH IS IN
;ACCUMULATOR Q.

;THE ROUTINES ARE CALLED IN THE FOLLOWING MANNER:
;	JSA	Q,AMAX1 OR MAX1 OR AMAX0 OR MAX0
;	EXP	A
;	EXP	B
;	ETC
;FOR AMAX1 AND MAX1, A,B,... ARE REAL.  THE ANSWER
;RETURNED IS REAL FOR AMAX1 AND INTEGER FOR MAX1.
;FOR AMAX0 AND MAX0, A,B,... ARE INTEGER.  THE ANSWER 
;RETURNED IS REAL FOR AMAX0 AND INTEGER FOR MAX0.

;THE ANSWER IS RETURNED IN ACCUMULATOR A.

	ENTRY	AMAX1,MAX1,AMAX0,MAX0
	SEARCH	DEF40
IFN KA10,<EXTERN	IFIX,FLOAT>

A=0
B=1
Q=16
P=17

	SIXBIT/AMAX1/
AMAX1:	0			;ENTRY TO AMAX1 ROUTINE.
	PUSHJ	P,MAX.		;FIND THE MAXIMUM AND
	JRA	Q,(Q)		;RETURN.

	SIXBIT/MAX0/
MAX0:	0			;ENTRY TO MAX0 ROUTINE.
	PUSHJ	P,MAX.		;FIND THE MAXIMUM AND
	JRA	Q,(Q)		;RETURN.

	SIXBIT/MAX1/
MAX1:	0			;ENTRY TO MAX1 ROUTINE.
	PUSHJ	P,MAX.		;FIND THE MAXIMUM AND
IFN KI10,<FIX	0,SAVARG>
IFN KA10,<JSA	Q,IFIX		;FIX THE
	EXP	SAVARG		;RESULT AND>
	JRA	Q,(Q)		;RETURN.

	SIXBIT/AMAX0/
AMAX0:	0			;ENTRY TO AMAX0 ROUTINE.
	PUSHJ	P,MAX.		;FIND THE MAXIMUM AND
IFN KI10,<FLTR	0,SAVARG>
IFN KA10,<JSA	Q,FLOAT		;FLOAT THE
	EXP	SAVARG		;RESULT AND>
	JRA	Q,(Q)		;RETURN.

MAX.:	MOVE	A,@(Q)		;PICK UP FIRST ARG.
	AOJA	Q,MAX.2		;INCREMENT POINTER TO NEXT ADDRESS.

MAX.1:	CAMGE	A,@B		;IS CURRENT ARG > NEXT ARG?
	MOVE	A,@B		;NO, PUT ARG IN A.

MAX.2:	MOVE	B,(Q)		;NEXT ARG ADDR TO B.
	TLC	B,(<JUMP>)	;IS THE OPCODE OF THE
	TLNN	B,777000	;NEXT ARG A JUMP?
	AOJA	Q,MAX.1		;YES, LOOP.
	MOVEM	A,SAVARG	;ANSWER IN A AND SAVARG.
	POPJ	P,		;EXIT.

SAVARG:	0
	PRGEND

	TITLE	MIN	V.32(415)
	SUBTTL	22-MAY-72	ED YOURDON/TWE/KK/DMN

;FROM V.005.
;AMIN1, MIN1, AMIN0, AND MIN0 CALCULATE THE MINIMUM OF A
;STRING OF ARGUMENTS, THE FIRST ADDRESS OF WHICH IS IN
;ACCUMULATOR Q.

;THE ROUTINES ARE CALLED IN THE FOLLOWING MANNER:
;	JSA	Q,AMIN1 OR MIN1 OR AMIN0 OR MIN0
;	EXP	A
;	EXP	B
;	ETC
;FOR AMIN1 AND MIN1, A,B,... ARE REAL.  THE ANSWER
;RETURNED IS REAL FOR AMIN1 AND INTEGER FOR MIN1.
;FOR AMIN0 AND MIN0, A,B,... ARE INTEGER.  THE ANSWER 
;RETURNED IS REAL FOR AMIN0 AND INTEGER FOR MIN0.

;THE ANSWER IS RETURNED IN ACCUMULATOR A.

	ENTRY	AMIN1,MIN1,AMIN0,MIN0
	SEARCH	DEF40
IFN KA10,<EXTERN	IFIX,FLOAT>

A=0
B=1
Q=16
P=17

	SIXBIT/AMIN1/
AMIN1:	0			;ENTRY TO AMIN1 ROUTINE.
	PUSHJ	P,MIN.		;FIND THE MINIMUM AND
	JRA	Q,(Q)		;RETURN.

	SIXBIT/MIN0/
MIN0:	0			;ENTRY TO MIN0 ROUTINE.
	PUSHJ	P,MIN.		;FIND THE MINIMUM AND
	JRA	Q,(Q)		;RETURN.

	SIXBIT/MIN1/
MIN1:	0			;ENTRY TO MIN1 ROUTINE.
	PUSHJ	P,MIN.		;FIND THE MINIMUM AND
IFN KI10,<FIX	0,SAVARG>
IFN KA10,<JSA	Q,IFIX		;FIX THE
	EXP	SAVARG		;RESULT AND>
	JRA	Q,(Q)		;RETURN.

	SIXBIT/AMIN0/
AMIN0:	0			;ENTRY TO AMIN0 ROUTINE.
	PUSHJ	P,MIN.		;FIND THE MINIMUM AND
IFN KI10,<FLTR	0,SAVARG>
IFN KA10,<JSA	Q,FLOAT		;FLOAT THE
	EXP	SAVARG		;RESULT AND>
	JRA	Q,(Q)		;RETURN.

MIN.:	MOVE	A,@(Q)		;PICK UP FIRST ARG.
	AOJA	Q,MIN.2		;INCREMENT POINTER TO NEXT ADDRESS.

MIN.1:	CAMLE	A,@B		;IS CURRENT ARG < NEXT ARG?
	MOVE	A,@B		;NO, PUT ARG IN A.

MIN.2:	MOVE	B,(Q)		;NEXT ARG ADDR TO B.
	TLC	B,(<JUMP>)	;IS THE OPCODE OF THE
	TLNN	B,777000	;NEXT ARG A JUMP?
	AOJA	Q,MIN.1		;YES, LOOP.
	MOVEM	A,SAVARG	;ANSWER IN A AND SAVARG.
	POPJ	P,		;EXIT.

SAVARG:	0
	PRGEND

	TITLE	ACOS	V.027
	SUBTTL	10-JULY-1970	KAREN KOLLING/DMN

;FROM V.022
;FLOATING POINT SINGLE PRECISION ARCCOSINE FUNCTION

;ACOS(X) IS CALCULATED IN THE FOLLOWING MANNER:
;	IF X > 0,	ACOS(X)=ATAN((SQRT(1-X^2))/X)
;	IF X < 0,	ACOS(X)=PI + ATAN((SQRT(1-X^2))/X)
;	IF X = 0,	ACOS(X)=PI/2

;THE RANGE OF DEFINITION FOR ACOS IS -1.0 TO +1.0.
;ARGUMENTS OUTSIDE OF THIS RANGE WILL CAUSE AN ERROR MESSAGE
;TO BE TYPED AND WILL RETURN AN ANSWER OF ZERO.

;THE CALLING SEQUENCE FOR ACOS IS:

;	JSA	16,ACOS
;	EXP	ARG


	ENTRY	ACOS
	EXTERN	ATAN,SQRT,TYPER.

	SIXBIT/ACOS/
ACOS:	0			;ENTRY TO ACOS ROUTINE.
	MOVM	0,@(16)		;GET /ARG./ IN AC 0.
	CAMLE	0,ONE		;IS MAGNITUDE OF ARG. GT 1.0?
	JRST	TOOLRG		;YES, GO TO ERROR RETURN.
	JUMPE	0,ZERARG	;IF ARG=0, GO TO ZERARG.
	FMPR	0,0		;X^2 IN AC 0.
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP, IF NECESSARY.
	MOVNS	0		;-X^2 IN AC 0.
	FAD	0,ONE		;1.0-X^2 IN AC 0.
	MOVEM	0,TEMPSV	;ARG TO LOC NE 0 OR 1.
	JSA	16,SQRT		;CALC. SQRT(1.0-X^2).
	ARG	TEMPSV		;ADDRESS OF ARG FOR SQRT ROUTINE.
	FDVR	0,@(16)		;(SQRT(1.0-X^2))/X IS IN AC 0.
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP, IF NECESSARY.
	MOVEM	0,TEMPSV	;ARG TO LOC NE 0 OR 1.
	JSA	16,ATAN		;FIND ATAN(SQRT(1.0-X^2)/X).
	EXP	TEMPSV		;ADDRESS OF ARG. FOR ATAN ROUTINE.
	SKIPL	@(16)		;SKIP IF ORIGINAL ARG < 0.
	JRA	16,1(16)	;RETURN.
	FAD	0,PII		;ANSWER IS PI - ORIGINAL ANSWER.
	JRA	16,1(16)	;RETURN.
ZERARG:	MOVE	0,PI2		;ANSWER IS PI/2.
	JRA	16,1(16)	;RETURN
TOOLRG:	MOVE	0,[XWD	[ASCIZ /ACOS OF ARG > 1.0 IN MAGNITUDE/],7]
	PUSHJ	17,TYPER.	;ERROR MESSAGE
	SETZ	0,		;SET ANSWER TO ZERO.
	JRA	16,1(16)	;RETURN.
ONE:	201400000000		;1.0
PI2:	201622077325
PII:	202622077325
TEMPSV:	0
	PRGEND
	TITLE	ASIN  V.027 
	SUBTTL	10-JULY-1970	ED YOURDON/KK/DMN

;FROM V.022
;FLOATING POINT SINGLE PRECISION ARCSINE FUNCTION
;THE ARCSINE IS CALCULATED WITH THE FOLLOWING ALGORITHM:

;	ASIN(X) = ATAN(X/SQRT(1-X^2))

;THE RANGE OF DEFINITION FOR ASIN IS (-1.0,1.0)
;OTHER ARGUMENTS WILL CAUSE AN ERROR MESSAGE TO BE
;TYPED AND AN ANSWER OF ZERO TO BE RETURNED.

	A=	0
	B=	1
	Q=	16

	ENTRY	ASIN
	EXTERN	ATAN,SQRT,TYPER.

	SIXBIT/ASIN/
ASIN:	0			;ENTRY TO ASIN ROUTINE
	MOVM	B,@(Q)		;GET MAGNITUDE OF ARG. IN B
	CAMLE	B,ONE		;IS THE MAGNITUDE OF THE ARG. LE 1.0?
	JRST	TOOLRG		;NO, GO TO ERROR RETURN.
	MOVN	A,@(Q)		;GET THE NEGATIVE OF ARG
	FM(Q)		;CALCULATE -(X^2)
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP, IF NECESSARY.
	FAD	A, ONE		;CALCULATE 1-(X^2)
	JUMPE	A, ASIN1	;WAS X EITHER -1.0 OR 1.0?
	MOVEM	A,ASIN2		;NO,
	JSA	Q, SQRT		;CALCULATE SQRT(1-X^2)
	EXP	ASIN2		;ADDRESS OF ARGUMENT OF SQRT
	MOVE	B,@(Q)		;GET THE ARGUMENT BACK AGAIN
	FDV	B, A		;CALCULATE X/SQRT(1-X^2)
	MOVEM	B,ASIN2		;THEN
	JSA	Q, ATAN		;CALCULATE ATAN(X/SQRT(1-X^2))
	EXP	ASIN2		;ADDRESS FOR ATAN ROUTINE
	JRA	Q, 1(Q)		;EXIT

ASIN1:	MOVE	A, PIOT		;ANSWER IS EITHER PI/2 OR-PI/2
	SKIPG	@(Q)		;WAS ORIGINAL ARGUMENT POSITIVE?
	MOVNS	A		;NO, GET -PI/2
	JRA	Q, 1(Q)		;EXIT

TOOLRG:	MOVE	A,[XWD	[ASCIZ /ASIN OF ARG > 1.0 IN MAGNITUDE/],8]
	PUSHJ	17,TYPER.	;ERROR MESSAGE
	SETZ	A,		;SET ANSWER TO ZERO.
	JRA	16,1(16)	;RETURN.		
ASIN2:	0			;STORAGE FOR ARGUMENT
PIOT:	201622077325		;PI/2
ONE:	1.0
	PRGEND
	TITLE	ATAN2 V.32(302)
	SUBTTL	22-SEPT-71	/TWE/KK/DMN
;FROM	V0.27	17-JUL-70
;FROM	V.021	29-OCT-69


;FLOATING POINT SINGLE PRECISION ARCTANGENT OF TWO ARGUMENTS
;RETURNS ARCTANGENT OF A/B
;IF ARGUMENT IS IN 2ND QUADRANT, ATAN2(A/B) = PI + ATAN(A/B)
;IF ARGUMENT IS IN 3RD QUADRANT, ATAN2(A/B) = ATAN(A/B) - PI
;IF A/B OVERFLOWS (OR DIVIDE CHECK), THEN RETURN
;	+PI/2 IF A>=0, AND
;	-PI/2 IF A<0.
;IF A/B UNDERFLOWS, THEN RETURN
;	0 IF B>=0, AND
;	+PI IF B<0 AND A >=0,
;	-PI IF B<0 AND A<0.

;THERE IS NO RESTRICTION ON THE ARGUMENTS

;THE ROUTINE IS CALLED  IN THE FOLLOWING MANNER:
;	JSA	Q, ATAN2
;	EXP	A
;	EXP	B
;THE ANSWER IS RETURNED IN ACCUMULATOR A.

	ENTRY	ATAN2
	EXTERN	ATAN,TYPER.

	A=	0
	B=	1
	Q=	16

	EXTERNAL OVPC.
	SIXBIT/ATAN2/
ATAN2:	0			;ENTRY POINT TO ATAN2 ROUTINE
	MOVE	A, @(Q)		;PICK UP FIRST ARGUMENT
	MOVE	B, @1(Q)	;PICK UP SECOND ARGUMENT
	MOVEM	A,SAVEA		;SAVE 1ST ARG.
	MOVEM	B, SAVEB	;SAVE 2ND ARG.
	JUMPE	B,DIVCHK	; INTERCEPT IF DIVCHK WILL OCCUR
	FDVR	A, B		;FORM A/B
	JFCL	11,OVUNFO	; SUPPRESS ERROR MESSAGE FROM OVTRAP IF NECESSARY.
	MOVEM	A,TEMP		;ARG TO NE 0 OR 1.
	JSA	Q, ATAN		;CALCULATE ATAN (A/B)
	EXP	TEMP		;ADDRESS FOR ATAN ROUTINE
	SKIPL	SAVEB		;IF B>0, SGN(ATAN2)=SGN(A)
	JRA	Q, 2(Q)		;EXIT
	JUMPGE	A, ATAN2A	;IS A POSITIVE?
	FADR	A, PII		;NO, SECOND QUADRANT, ADD PI
	JRA	Q, 2(Q)		;EXIT

ATAN2A:	FSBR	A, PII		;YES,3RD QUADRANT, SUBTRACT PI
	JRA	Q, 2(Q)		;EXIT
OVUNFO:	MOVE	A,OVPC.		;PICK UP FLAGS.
	TLNE	A,000100	;SKIP IF OVERFLOW.
	JRST	UNDER		;O'E GO TO UNDERFLOW CASE.
DIVCHK:	JUMPE	A,UNDER-1	; IF BOTH ARGS 0 THEN RETURN 0
	MOVE	A,HALFPI	;ANSWER SET TO PI OVER TWO.
	SKIPGE	SAVEA		;SKIP IF ANS IS TO BE POSITIVE.
	MOVNS	A		;SET ANSWER NEGATIVE.
	JRA	Q,2(Q)		;RETURN.
UNDER:	JUMPL	B,.+5		;IF B >=0,
	MOVEI	0,4		;RETURN AN
	PUSHJ	17,TYPER.	;ERROR MESSAGE AND
	MOVEI	A,0		;RETURN ANSWER OF 0.
	JRA	Q,2(Q)		;RETURN.
	MOVE	A,PII		;SET ANSWER TO PI
	SKIPGE	SAVEA		;SKIP IF 1ST ARG WAS >= 0.
	MOVNS	A		;O'E, SET ANSWER NEGATIVE.
	JRA	Q,2(Q)		;RETURN.

PII:	202622077325		;3.141592653589793238462643...
HALFPI:	201622077325
SAVEA:	0
SAVEB:	0
TEMP:	0
	PRGEND
	TITLE	ATAN  V.022
	SUBTTL	18-DECEMBER-1969	ED YOURDON/KK

;FROM V.005.
;FLOATING POINT SINGLE PRECISION ARCTANGENT FUNCTION
;ATAN(X) = X(B0+A1(Z+B1-A2(Z+B2-A3(Z+B3)**-1)**-1)**-1)
;WHERE Z=X^2, IF 0<X<=1

;IF X>1, THEN ATAN(X) = PI/2 - ATAN(1/X)
;IF X>1, THEN RH(D) =-1, AND LH(D) = -SGN(X)
;IF X<1, THEN RH(D) = 0, AND LH(D) =  SGN(X)

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, ATAN
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	ENTRY	ATAN

	A=	0
	B=	1
	C=	2
	D=	3
	Q=	16

	SIXBIT/ATAN/
ATAN:	0			;ENTRY TO ARCTANGENT ROUTINE
	MOVE	A, @(Q)		;PICK UP THE ARGUMENT IN A
ATAN1:	MOVM	B, A		;GET ABSF OF ARGUMENT
	CAMG	B, A1		;IF X<2^-33, THEN RETURN WITH...
	JRA	Q, 1(Q)		;ATAN(X) = X
	MOVEM	D, D1		;SAVE ACCUMULATOR D
	HLLO	D, A		;SAVE SIGN, SET RH(D) = -1
	CAML	B, A2		;IF A>2^33, THEN RETURN WITH
	JRST	AT4		;ATAN(X) = PI/2
	MOVEM	C, C1		;SAVE ACCUMULATOR C
	MOVSI	C, 201400	;FORM 1.0 IN C
	CAMG	B, C		;IS ABSF(X)>1.0?
	TRZA	D, -1		;IF B .LE. 1.0, THEN RH(D) = 0
	FDVM	C, B		;B IS REPLACED BY 1.0/B
	TLC	D, (D)		;XOR SIGN WITH .G. 1.0 INDICATOR
	MOVEM	B, C3		;SAVE THE ARGUMENT
	FMP	B, B		;GET B^2
	MOVE	C, KB3		;PICK UP A CONSTANT
	FAD	C, B		;ADD B^2
	MOVE	A, KA3		;ADD IN NEXT CONSTANT
	FDVM	A, C		;FORM -A3/(B^2 + B3)
	FAD	C, B		;ADD B^2 TO PARTIAL SUM
	FAD	C, KB2		;ADD B2 TO PARTIAL SUM
	MOVE	A, KA2		;PICK UP -A2
	FDVM	A, C		;DIVIDE PARTIAL SUM BY -A2
	FAD	C, B		;ADD B^2 TO PARTIAL SUM
	FAD	C, KB1		;ADD  B1 TO PARTIAL SUM
	MOVE	A, KA1		;PICK UP A1
	FDV	A, C		;DIVIDE PARTIAL SUM BY A1
	FAD	A, KB0		;ADD B0
	FMP	A, C3		;MULTIPLY BY ORIGINAL ARGUMENT
	TRNE	D, -1		;CHECK .G. 1.0 INDICATOR
	FSB	A, PIOT		;ATAN(A) = -(ATAN(1/A)-PI/2)
	SKIPA	C, C1		;RESTORE ACCUMULATOR C AND SKIP
AT4:	MOVE	A, PIOT		;GET PI/2 AS ANSWER
	SKIPGE	D		;LH(D) = -SGN(B) IF B>1.0
	MOVNS	A		;NEGATE ANSWER
	MOVE	D, D1		;RESTORE ACCUMULATOR
	JRA	Q, 1(Q)		;EXIT
A1:	145000000000		;2**-33
A2:	233000000000		;2**33
KB0:	176545543401		;0.1746554388
KB1:	203660615617		;6.762139240
KB2:	202650373270		;3.316335425
KB3:	201562663021		;1.448631538
KA1:	202732621643		;3.709256262
KA2:	574071125540		;-7.106760045
KA3:	600360700773		;-0.2647686202
C1:	0
C3:	0
D1:	0
PIOT:	201622077325		;PI/2
	PRGEND
TITLE	SQRT	V.30.0.142
SUBTTL	29-APR-71	TONY LAUCK/TWE/DMN

;FLOATING POINT SINGLE PRECISION SQUARE ROOT FUNCTION
;THE SQUARE ROOT OF THE ABSOLUTE VALUE OF THE ARGUMENT IS
;CALCULATED. THE ARGUMENT IS WRITTEN IN THE FORM
;	X=	F*(2**2B)	WHERE 0<F<1
;SQRT(X) IS THEN CALCULATED AS (SQRT(X))*(2**B)
;SQRT(F) IS CALCULATED BY A LINEAR APPROXIMATION, THE NATURE
;OF WHICH DEPENDS ON WHETHER 1/4 < F < 1/2 OR 1/2 < F < 1,
;FOLLOWED BY TWO ITERATIONS OF NEWTON'S METHOD.

;THE CALLING SEQUENCE FOR THE SQUARE ROOT IS AS FOLLOWS:
;	JSA	Q, SQRT
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A.

	A=0
	B=1
	Q=16

IFNDEF KA10,<PDP6==0
	KA10==1
	KI10==0>

	IFN <PDP6+KA10+KI10-1>,<PRINTX DEFINE PROCESSOR SWITCHES>

EXTERN TYPER.
	ENTRY SQRT
SQRT:	0			;ENTRY TO SQUARE ROOT ROUTINE
	SKIPG	B,@(Q)		;PICK UP ARG. CHECK IF > 0
	JRST	SQRT4		;NO, HANDLE NON-POSITIVE ARGUMENT

SQRTP:	MOVEI	A,0		;GET EXPONENT TO A
	LSHC	A,^D9
	SUBI	A,201		;GET TRUE EXPONENT + 1
	ROT	A,-1		;DIVIDE BY 2
	HRRM	A,SQRT2		;AND STORE FOR FLOATING SCALE INST.
	LSH	B,-^D9		;RESTORE POSITION OF FRACTION IN B
	JUMPL	A,SQRT3		;JUMP IF FRACTION > .5

				;FRACTION <.5
	FSC	B,177		;AND FIX UP EXPONENT .25 < F < .5
	MOVEM	B,F		;SAVE FRACTION
				;COMPUTE LINEAR APPROX #1
	IFE	PDP6,<
	FMPRI	B,200640
	FADRI	B,177465
	>
	IFN	PDP6,<
	FMP	B,[200640000000]
	FAD	B,[177465000000]
	>

SQRT1:	MOVE	A,F		;1ST ITERATION OF NEWTON
	FDV	A,B		; F/APPROX
	FAD	B,A		; APPROX  +  F/APPROX
	FSC	B,-1		; .5*( APPROX  +  F/APPROX)
	MOVE 	A,F		;2ND ITERATION OF NEWTON
	FDV	A,B		; F/APPROX
	FADR	A,B		; APPROX + F/APPROX
SQRT2:	FSC	0		;HALVE AND SCALE EXPONENT
	JRA	Q,1(Q)		;RETURN

				;HERE ON F >= .5
SQRT3:	FSC	B,200		;AND FIX UP EXPONENT .5 <= F < 1
	MOVEM	B,F		;SAVE FRACTION
				;COMPUTE LINEAR APPROX #2
	IFE	PDP6,<
	FMPRI	B,200450
	FADRI	B,177660
	>
	IFN	PDP6,<
	FMP	B,[200450000000]
	FAD	B,[177660000000]
	>
	JRST	SQRT1		;NOW GO ITERATE
SQRT4:	JUMPE	B,ZERO
	MOVE	A,[XWD [ASCIZ /ATTEMPT TO TAKE SQRT OF NEGATIVE ARG/],6]
	PUSHJ	17,TYPER.
	MOVM	B,@(Q)		;GET MAGNITUDE
	JRST	SQRTP		;POSITIVE NOW

ZERO:	MOVEI	A,0		;HERE ON NON-POSITIVE ARG. RETURN ZERO
	JRA	Q,1(Q)

F:	BLOCK	1		;STORE FRACTION HERE

	PRGEND
TITLE	SINH	V.027
SUBTTL	15-JUL-70	KAREN KOLLING/DMN
;FROM	V.021 19-NOV-69

;FLOATING POINT SINGLE PRECISION HYPERBOLIC SINE FUNCTION.

;SINH IS CALCULATED AS FOLLOWS:
;	IF ABS(X)>88.029,
;		SINH(X)=(EXP[ABS(X)-LN(2)])*SIGN(X)
;	IF ABS(X)<=0.10,
;		SINH(X)=X+(X**3)/6+(X**5)/120
;	FOR ALL OTHER VALUES OF X,
;		SINH(X)=1/2[EXP(X)-1/EXP(X)]

;THE CALLING SEQUENCE IS:
;	JSA	Q,SINH
;	EXP	ARG

;THE ANSWER IS RETURNED IN AC 0.

	ENTRY SINH
	EXTERN EXP,TYPER.

	SIXBIT/SINH/
SINH:	0			;ENTRY TO HYPERBOLIC SINE ROUTINE.
	MOVE	0,@(16)		;PICK UP THE ARG.
	MOVEM	2,SAVE2		;SAVE AC 2.
	MOVEM	0,ARGTMP	;SAVE ARG.
	MOVM	2,0		;GET MAGNITUDE OF ARG IN AC 2.
	CAMLE	2,EIGHT8	;IF ABS(X)>88.029,
	JRST	OV88		;THEN GO TO OV88.
	CAMG	2,ONE10T	;IF ABS(X)<=0.10,
	JRST	SERIES		;THEN GO TO SERIES.
	JSA	16,EXP		;FIND EXP(ABS(X)).
	EXP	2		;ABS(X) IS IN AC 2.
	HRLZI	1,576400	;PUT -1.0 IN AC 1.
	FDVR	1,0		;CALC. -EXP(-ABS(X)).
	FADR	0,1		;CALC. EXP(ABS(X))-EXP(-ABS(X)).
	FDVRI	0,202400	;CALC. THIS/2.0
	SKIPGE	ARGTMP		;ANSWER IS POSITIVE.
	MOVNS	0,0		;ANSWER IS NEGATIVE.
	MOVE	2,SAVE2		;RESTORE AC 2.
	JRA	16,1(16)	;EXIT.
SERIES:	FMPR	2,2		;CALC. X^2.
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP.
	MOVEM	2,SX2		;SAVE X^2 IN SX2.
	FDVR	2,ONE120	;CALC.X^2/120
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP.
	FADR	2,ONESIX	;CALC. (X^2/120)+1/6
	FMPR	2,SX2		;MULTIPLY IT BY X^2.
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP.
	FADRI	2,201400	;ADD 1.0.
	FMPR	0,2		;MULTIPLY BY X.
	MOVE	2,SAVE2		;RESTORE AC 2.
	JRA	16,1(16)	;EXIT.
OV88:	FSBR	2,LN2BE		;CALC.ABS(X)-LN(2)
	CAMG	2,EIGHT8	;OVERFLOW?
	JRST	EXPP		;NO,GO TO CALC.
	MOVEI	0,3		;SET UP ARG FOR ERROR MESSAGE.
	PUSHJ	17,TYPER.	;TYPE ERROR MESSAGE.
	HRLOI	0,377777	;SET ANS.=INFINITY.
	JRST	EXPP+2		;GO TO SET SIGN OF ANS.

EXPP:	JSA	16,EXP		;CALC. EXP
	EXP	2		;ARG. FOR EXP ROUTINE IS IN AC 2.
	SKIPGE	ARGTMP		;RETURN ANS. >0 IF X>0.
	MOVNS	0		;O'E, ANS. <0.
	MOVE	2,SAVE2		;RESTORE AC 2.
	JRA	16,1(16)	;EXIT.

SAVE2:	0
LN2BE:	200542710300		;LN(2)
EIGHT8:	207540074636		;88.029
ARGTMP:	0
ONE10T:	0.10
SX2:	0
ONE120:	207740000000		;120.0
ONESIX:	0.16666667
	PRGEND
TITLE	COSH	V.032(400)
SUBTTL	16-APR-72	ED YOURDAN/KK/DMN
;FROM	V.021	26-AUG-69

;FLOATING POINT SINGLE PRECISION HYPERBOLIC COSINE FUNCTION.

;COSH(X) IS CALCULATED AS FOLLOWS:
;	IF ABS(X) <= 88.029,
;		COSH(X) = 1/2(EXP(X) + 1.0/EXP(X))
;	IF ABS(X) > 88.029 AND (ABS(X)-LN(2)) <= 88.029,
;		COSH(X) = EXP(ABS(X)-LN(2))
;	IF (ABS(X)-LN(2)) > 88.029,
;		COSH(X)=377777777777
;		AND AN ERROR MESSAGE IS RETURNED.

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	16,COSH
;	EXP	ARG
;THE ANSWER IS RETURNED IN AC 0.

	EXTERN	EXP,TYPER.
	ENTRY	COSH



	SIXBIT/COSH/
COSH:	0			;ENTRY TO HYPERBOLIC COSINE ROUTINE.
	MOVE	0,@(16)		;PICK UP THE ARGUMENT.
	MOVEM	2,SAVE2		;SAVE AC 2.
	MOVM	2,0		;PUT ABS(X) IN AC 2.
	CAMLE	2,EIGHT8	;IF ABS(X) > 88.029,
	JRST	OV88		;GO TO OV88.
	JSA	16,EXP		;O'E, CALC. EXP(ABS(X))
	EXP	2		;ARG FOR EXP ROUTINE IS IN AC 2.
	MOVSI	2,201400	;PUT 1.0 IN AC 2.
	FDVR	2,0		;CALC. 1.0/EXP(ABS(X)).
	FADR	0,2		;CALC. EXP(ABS(X)) + EXP(-ABS(X)).
	FDVRI	0,202400	;DIVIDE THIS BY 2.0.
	MOVE	2,SAVE2		;RESTORE AC 2.
	JRA	16,1(16)	;RETURN.

OV88:	FSBR	2,LN2BE		;FORM ABS(X)-LN(2).
	CAMG	2,EIGHT8	;OVERFLOW?
	JRST	EXPP		;NO,GO AHEAD.
	MOVEI	0,3		;YES, SET UP FOR ERROR MESSAGE.
	PUSHJ	17,TYPER.	;TYPE OUT ERROR MESSAGE.
	HRLOI	0,377777	;ANSWER = +INFINITY.
	MOVE	2,SAVE2		;RESTORE AC 2.
	JRA	16,1(16)	;RETURN.

EXPP:	JSA	16,EXP		;CALC. EXP(ABS(X)-LN(2)).
	EXP	2		;ARG FOR EXP ROUTINE IS IN AC 2.
	MOVE	2,SAVE2		;RESTORE AC 2.
	JRA	16,1(16)	;RETURN.

SAVE2:	0
EIGHT8:	207540074636	;88.029
LN2BE:	200542710300	;LOG(2) BASE E.

	PRGEND
	TITLE	TANH  V.021
	SUBTTL	22-SEPTEMBER-1969	ED YOURDON/KK

;FLOATING POINT SINGLE PRECISION HYPERBOLIC TANGENT ROUTINE

;THIS ROUTINE CALCULATES THE TANH BY THE FOLLOWING ALGORITHM:
;IF ABSF(X) <.00034, THEN TANH(X) = X
;IF ABSF(X) >12.0, THEN TANH(X) = 1.0*SIGN(X)
;IF 0.17 <= X < 12.0, THEN TANH IS CALCULATED AS
;	TANH(X) = 1.0 - 2(1.0 + EXP(2*X))**-1
;IF .00034 <= X < 0.17, THEN TANH IS CALCULATED AS
;TANH(X) = F(A+F^2(B+C(D+F^2)**-1))**-1
;WHERE X = 4*LOG(E)  (BASE 2)

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, TANH
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	ENTRY	TANH
	EXTERN	EXP

	A=	0
	B=	1
	Q=	16


	SIXBIT/TANH/
TANH:	0			;ENTRY TO TANH ROUTINE
	MOVE	A, @(Q)		;PICK UP THE ARGUMENT
	MOVM	B, A		;GET ABSF(ARGUMENT)
	CAMGE	B, T1		;RETURN TANH(X)=X IF 
	JRA	Q, 1(Q)		;ABSF(X) .LE. .00034
	CAMLE	B, T2		;RETURN TANH(X) = 1.0 IF
	JRST	TH5		;ARGUMENT GREATER THAN 12.0
	CAMGE	B, T3		;USE RATIONAL APPROXIMATION IF
	JRST	TH3		;ARGUMENT IS LESS THAN 0.17
	MOVEM	A,SAVEA		;SAVE ARG. 
	FMPRI	B,202400	;GET 2*ARG.
	MOVEM	B,TM1		;ARG TO NE 0 OR 1.
	JSA	Q, EXP		;CALCULATE EXP(2X)
	EXP	TM1		;ADDRESS FOR EXP ROUTINE
	MOVSI	B, 201400	;FORM 1.0
	FAD	A, B		;1 + EXP(2X)
	FDVM	B, A		;(1 + EXP(2X))**-1
	FMPRI	A,202400	;2*(1 + EXP(2X))**-1
	FSBRM	B, A		;1 - 2*(1 + EXP(2X))**-1
	SKIPGE	SAVEA		;SKIP AHEAD IF ARG WAS >=0.
	MOVNS	A		;OTHERWISE,NEGATE THE ANSWER.
	JRA	Q, 1(Q)		;EXIT

TH3:	FMP	A, T7		;FORM 4*X*LOG(E) BASE 2
	MOVEM	A, TM1		;SAVE IT IN TM1
	FMP	A, A		;SQUARE IT
	MOVEM	A, TM2		;SAVE IT
	FAD	A, T4		;FORM F^2 + T4
	MOVE	B, T5		;GET T5 IN ACCUMULATOR B
	FDV	B, A		;T5/(F^2 + T4)
	FAD	B, T6		;T6 + T5/(F^2 + T4)
	FMP	B, TM2		;MULTIPLY BY F^2
	FAD	B, T7		;ADD T7 (4*LOG(E) BASE 2)
	MOVE	A, TM1		;GET F IN ACCUMULATOR A
TH5:	FDV	A, B		;DIVIDE F BY PARTIAL SUM
	JRA	Q, 1(Q)		;EXIT

T1:	165544410070		;0.00034
T2:	204600000000		;12.0
T3:	176534121727		;0.17
T4:	211535527022		;349.6699888
T5:	204704333567		;14.1384514018
T6:	173433723376		;0.01732867951
T7:	203561250731		;5.7707801636

TM1:	0
TM2:	0
SAVEA:	0
	PRGEND
TITLE EXP1	32(341)	23-NOV-1971
SUBTTL EXP	B/KK/DMN/TWE/DMN

;SINGLE PRECISION INTEGER TO INTEGER EXP FUNCTION.

;EXP CALCULATES I**J, WHERE
;	J=Q(0) + Q(1)*2 + Q(2)*4 + ..., WHERE Q(I)=0 OR 1.

;THE CALLING SEQUENCE FOR THE ROUTINES IS:
;	PUSHJ	17,EXP1.N	WHERE N=0,2,4, OR 6.
;THE BASE IS IN AC N AND THE EXPONENT IS IN AC N+1.
;THE ANSWER IS RETURNED IN AC N.

	EXTERN	TYPER.
	ENTRY	EXP1.0,EXP1.2,EXP1.4,EXP1.6

A=0
B=1
C=2
D=3
E=4
F=5
G=6
H=7
P=17



	SIXBIT/EXP1.6/
EXP1.6:	MOVE	A,G		;SET UP BASE.
	MOVE	B,H		;SET UP EXPONENT.
	PUSHJ	P,EXP1.0	;GO TO MAIN ROUTINE.
	MOVEM	A,G		;STORE ANSWER.
	POPJ	P,		;RETURN.

	SIXBIT/EXP1.4/
EXP1.4:	MOVE	A,E		;SET UP BASE.
	MOVE	B,F		;SET UP EXPONENT.
	PUSHJ	P,EXP1.0	;GO TO MAIN ROUTINE.
	MOVEM	A,E		;STORE ANSWER.
	POPJ	P,		;RETURN.

	SIXBIT/EXP1.2/
EXP1.2:	MOVE	A,C		;SET UP BASE.
	MOVE	B,D		;SET UP EXPONENT.
	PUSHJ	P,EXP1.0	;GO TO MAIN ROUTINE.
	MOVEM	A,C		;STORE ANSWER.
	POPJ	P,		;RETURN.

	SIXBIT/EXP1.0/
EXP1.0:	JUMPE	B,[MOVEI A,1		;BASE**0 RETURNS 1
		POPJ P,]
	JUMPN	A,BASNT0	;GO AHEAD IF BASE NE 0.
	JUMPGE	B,IEXP4		;RETURN IF BASE=0, EXP >= 0.
IOVFL:	MOVEI	0,1		;O'E, SET UP
	PUSHJ	17,TYPER.	;ERROR MESSAGE AND
	HRLOI	0,377777	;ANS.= INFINITY
	POPJ	17,		;AND RETURN.

BASNT0:	JUMPL	B,[TRNN B,1	;TEST FOR EXP<0.  IS EXP ODD?
		MOVMS A		;EXP IS EVEN. GET ABS(BASE)
		CAIE A,1	;IS BASE +-1?
		CAMN A,[-1]
		POPJ P,		;YES, RETURN +-1
		MOVEI A,0	;NO, RETURN 0
		POPJ P,]
	PUSH	P,C		;SAVE A WORKING AC.
	MOVEI	C,1		;INITIALIZE ANSWER TO 0.
	MOVEM	C,SAVEC		;INITIALIZE FLAG WORD TO > 0.
	JUMPG	A,IEXP2		;GO TO CALC. IF ANSWER WILL BE > 0.
	TRNN	B,1		;IS EXP ODD OR EVEN?
	JRST	IEXP2		;EXP IS EVEN, ANS WILL BE > 0.
	SETCMM	SAVEC		;EXP IS ODD, BASE < 0, ANS WILL BE <0. 
	JRST	IEXP2		;GO TO CALC.

IEXP1:	IMUL	A,A		;
	JFCL	1,OVER		;TRANSFER TO OVER IF OVERFLOW.
	LSH	B,-1		;DIVIDE B BY 2.
IEXP2:	TRZE	B,1		;CHECK LAST BIT OF B.
	IMUL	C,A		;
	JFCL	1,OVER		;TRANSFER TO OVER IF OVERFLOW.
	JUMPG	B,IEXP1		;GO TO RETURN IF B HAS BECOME 0.
IEXP3:	MOVE	A,C		;PUT ANSWER IN AC A.
IEXP3A:	POP	P,C		;RESTORE AC C.
IEXP4:	POPJ	P,		;RETURN.

OVER:	PUSHJ	P,IOVFL		;SET ANSWER TO + INFINITY.
	SKIPL	SAVEC		;SKIP IF ANS IS TO BE < 0.
	JRST	IEXP3A		;GO TO RETURN.
	MOVNS	A,A		;SET UP -
	SUBI	A,1		;INFINITY
	JRST	IEXP3A		;GO TO RETURN.

SAVEC:	0

	LIT
	PRGEND

TITLE	EXP3	V.32(377)
SUBTTL	19-APR-72	/DMN
;FROM	V.021	22-SEP-69

;SINGLE PRECISION FORTRAN IV EXP.3 FUNCTIONS
;THESE ROUTINES CALCULATE A FLOATING POINT NUMBER RAISED TO A
;FLOATING POINT POWER. THE CALCULATION IS
;	A**B= EXP(B*LOG(A))

;IF THE EXPONENT IS AN INTEGER < 2**35 IN MAGNITUDE, THE
;RESULT WILL BE COMPUTED USING "EXP2.0" AND THE ANSWER 
;WILL HAVE THE CORRECT SIGN. (REMEMBER THAT THE "INTEGER"
;HAS ONLY 27 SIGNIFCANT BITS.)
;SINCE NEGATIVE NUMBERS RAISED TO NON-INTEGER POWERS YIELD
;COMPLEX ANSWERS, THE MAIN ALGORITHM CALCULATES
;	EXP(B*LOG(ABSF(A)))

;THE CALLING SEQUENCE FOR THE ROUTINES IS AS FOLLOWS:
;	PUSHJ	P, EXP3.'N'
;WHERE N IS EITHER 0,2,4, OR 6. THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE
;IS CALLED. THE RESULT IS RETURNED IN ACCUMULATOR N.

EXTERNAL	ALOG,EXP,EXP2.0,TYPER.
ENTRY		EXP3.0,EXP3.2,EXP3.4,EXP3.6

;ACCUMULATOR DEFINITIONS
	A=	0
	B=	1
	C=	2
	D=	3
	E=	4
	F=	5
	G=	6
	H=	7
	Q=	16
	P=	17


	SIXBIT/EXP3.6/
EXP3.6:	MOVE	A, G		;SET UP ACCUMULATOR A
	MOVE	B, H		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP3.0	;GO TO MAIN ROUTINE.
	MOVE	G,A		;ANSWER IN CORRECT AC.
	POPJ	P,		;EXIT

	SIXBIT/EXP3.4/
EXP3.4:	MOVE	A, E		;SET UP ACCUMULATOR A
	MOVE	B, F		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP3.0	;GO TO MAIN ROUTINE.
	MOVE	E,A		;ANSWER IN CORRECT AC.
	POPJ	P,		;EXIT

	SIXBIT/EXP3.2/
EXP3.2:	MOVE	A, C		;SET UP ACCUMULATOR A
	MOVE	B, D		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP3.0	;GO TO MAIN ROUTINE.
	MOVE	C,A		;ANSWER IN CORRECT AC.
	POPJ	P,		;EXIT

	SIXBIT/EXP3.0/
EXP3.0:	JUMPE	B,[MOVSI A,(1.0)	;BASE**0, RETURNS 1
		POPJ P,]
	JUMPN	A,EXP30A	;GO AHEAD IF BASE NE 0.
	JUMPGE	B,EXP3A		;EXIT IF BASE = 0, EXP >= 0,
	MOVEI	A,3		;O'E, RETURN AN
	PUSHJ	17,TYPER.	;ERROR MESSAGE AND
	HRLOI	A,377777	;ANS.=+INFINITY
	POPJ	17,		;AND EXIT.

EXP30A:	PUSH	P,C		;SAVE AC C
	PUSH	P,D		;SAVE AC D
	MOVM	D,B		;SET EXP. POSITIVE.
	MOVEI	C,0		;CLEAR AC C TO ZERO
	LSHC	C,11		;SHIFT 9 PLACES LEFT
	SUBI	C,200		;TO OBTAIN SHIFTING FACTOR
	PUSH	P,E		;SAVE AC E.
	JUMPLE	C,EXP3GO	;IS C > 0
	HRR	E,C		;SET UP E AS AN INDEX REG.
	MOVEI	C,0		;CLEAR OUT AC C
	LSH	D,-1		;RIGHT ADJUST EXP TO BIT 1.
	ASHC	C,(E)		;SHIFT LFT BY CONTENTS OF E
	JFCL	EXP3GO		;IF OVERFLOW, GO TO EXP3GO.
	JUMPN	D,EXP3GO	;IS EXPONENT AN INTEGER ?
	JUMPGE	B,.+2		;YES, WAS  IT NEG. ?
	MOVNS	C		;YES, NEGATE IT
	MOVE	B,C		;MOVE INTEGER INTO B
	PUSHJ	P,EXP2.0	;OBTAIN RESULT USING EXP2.0
	JRST	EXPPOP		;RETURN TO RESTORE ACS C&D&E.

EXP3GO:	MOVM	E,A		;GET ABS(BASE) IN NE 0 OR 1.
	MOVE	D,A		;SAVE SIGN OF A
	MOVE	C,B		;SAVE AC B.
	JSA	Q,ALOG		;CALCULATE LOG OF A
	EXP	E		;ADDRESS FOR LOG ROUTINE.
	FMPRM	A, C		;CALCULATE B*LOG(A)
	JSA	Q, EXP		;CALCULATE EXP(B*LOG(A))
	EXP	C		;ADDRESS OF B*LOG(A)
	JUMPGE	D,EXPPOP	;SHOULD SIGN BE NEGATIVE?
	MOVN	A,A		;YES, NEGATE RESULT
EXPPOP:	POP	P,E		;RESTORE AC E.
	POP	P,D		;RESTORE AC D.
	POP	P,C		;RESTORE AC C.
EXP3A:	POPJ	P,		;EXIT

	LIT
	PRGEND
TITLE EXP2	V32(415)
SUBTTL		22-MAY-72	/DMN

;SINGLE PRECISION EXP.2 FUNCTIONS
;THESE ROUTINES CALCULATE A FLOATING POINT NUMBER TO A FIXED
;POINT POWER. THE CALCULATION IS A**B, WHERE B IS OF THE FORM

;	B=Q(0) + Q(1)*2 + Q(2)*4 + ...WHERE Q(I)=0 OR 1

;THERE ARE NO RESTRICTIONS ON THE BASE OR EXPONENT

;THE CALLING SEQUENCES FOR THE ROUTINES ARE AS FOLLOWS:
;	PUSHJ	P, EXP2.'N'
;WHERE N IS EITHER 0,2,4, OR 6. THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE IS
;CALLED. THE ANSWER IS RETURNED IN ACCUMULATOR N.

	ENTRY	EXP2.0,EXP2.2,EXP2.4,EXP2.6
	SEARCH	DEF40
	EXTERN	OVPC.,ALOG,EXP,TYPER.
IFN KA10,<EXTERN	FLOAT>

;ACCUMULATOR DEFINITIONS
	A=	0
	B=	1
	C=	2
	D=	3
	E=	4
	F=	5
	G=	6
	H=	7
	P=	17


	SIXBIT/EXP2.6/
EXP2.6:	MOVE	A, G		;SET UP ACCUMULATOR A
	MOVE	B, H		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP2.0	;GO TO MAIN ROUTINE.
	MOVEM	A, G		;MOVE ANSWER TO CORRECT AC.
	POPJ	P,		;RETURN

	SIXBIT/EXP2.4/
EXP2.4:	MOVE	A, E		;SET UP ACCUMULATOR A
	MOVE	B, F		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP2.0	;GO TO MAIN ROUTINE.
	MOVEM	A, E		;MOVE ANSWER TO CORRECT AC.
	POPJ	P,		;RETURN

	SIXBIT/EXP2.2/
EXP2.2:	MOVE	A, C		;SET UP ACCUMULATOR A
	MOVE	B, D		;SET UP ACCUMULATOR B
	PUSHJ	P, EXP2.0	;GO TO MAIN ROUTINE.
	MOVEM	A, C		;MOVE ANSWER TO CORRECT AC.
	POPJ	P,		;RETURN

	SIXBIT/EXP2.0/
EXP2.0:	JUMPE	B,[MOVSI A,(1.0)		;BASE**0, RETURNS 1
		POPJ P,]
	JUMPN	A,EXP2A		;GO AHEAD IF BASE NE 0.
	JUMPGE	B,FEXP4		;EXIT IF BASE =0, EXP >= 0,
	MOVEI	0,3		;O'E, SET UP
	PUSHJ	17,TYPER.	;AN ERROR MESSAGE AND
	HRLOI	0,377777	;AN ANSWER OF INFINITY.
	POPJ	17,		;RETURN.

EXP2A:	MOVEM	C,SAVEC  	;SAVE A WORKING ACCUMULATOR.
	MOVSI	C, 201400	;GET 1.0 IN ACCUMULATOR C.
	MOVEM	A,SAVEA		;STORE BASE IN SAVEA.
	MOVEM	B,SAVEB		;STORE EXP. IN SAVEB.
	JUMPGE	B, FEXP2	;IS EXPONENT POSITIVE?
	MOVMS	B		;NO, MAKE IT POSITIVE
	JFCL	MININF		;IF EXP WAS 400000,,0 GO TO MININF.
	PUSHJ	P, FEXP2	;CALL MAIN PART OF PROGRAM.
INV:	MOVSI	B, 201400	;GET 1.0 IN B.
	FDVM	B, A		;FORM 1/(A**B) FOR NEG. EXPONENT.
	POPJ	P,		;RETURN.

FEXP1:	FMP	A, A		;FORM A**N, FLOATING POINT.
	JFCL	OVER		;IF OVER/UNDERFLOW, GO TO OVER.
	LSH	B, -1		;SHIFT EXPONENT FOR NEXT BIT.
FEXP2:	TRZE	B, 1		;IS THE BIT ON?
	FMP	C, A		;YES, MULTIPLY ANSWER BY A**N.
	JFCL	OVER		;IF OVER/UNDERFLOW, GO TO OVER.
	JUMPN	B, FEXP1	;UPDATE A**N UNLESS ALL THROUGH.
FEXP3:	MOVE	A, C		;PICK UP RESULT FROM C.
FEXP3A:	MOVE	C,SAVEC		;RESTORE A WORKING ACCUMULATOR.
FEXP4:	POPJ	P,		;RETURN.

OVER:	MOVE	C,OVPC.		;PICK UP FLAGS.
	SKIPG	SAVEB		;JUMP TO INVERT IF
	JRST	INVERT		;EXP. WAS NEGATIVE.
	MOVEI	A,3		;A CONTAINS 3 UNLESS
	TLNE	C,(1B11)	;UNDERFLOW, IN WHICH CASE,
OUT:	ADDI	A,1		;A CONTAINS 4.
	PUSHJ	P,TYPER.	;TYPE ERROR MESSAGE.
	HRLOI	A,377777	;ANS. IS SET TO + INFINITY.
	TLNE	C,(1B11)	;SKIP IF OVERFLOW FLAG SET.
	SETZ	A,		;O'E, SET ANSWER TO 0.
OUT2:	SKIPL	SAVEA		;ANS. IS >= 0, IF
	JRST	FEXP3A		;A WAS >= 0.
	MOVE	B,SAVEB		;PICK UP THE EXP.
	TRNE	B,1		;ANS. IS < 0, IF A < 0 AND
	MOVNS	A		;THE EXP. WAS ODD.
	JRST	FEXP3A		;GO TO RETURN.

INVERT:	SUB	P,[XWD 1,1]	;ADJUST PDP.
	TLCN	C,(1B11)	;IF TRUE UNDERFLOW, GO
	JRST	ALOGRT		;TO ALOGRT.
	MOVEI	B,0		;SET UP ARG. FOR TYPER.
	JRST	OUT		;GO AND TYPE ERROR MESSAGE.

ALOGRT:	MOVM	C,SAVEA		;PICK UP ABS(BASE).
	JSA	16,ALOG		;CALC. LOG(ABS(A)).
	EXP	C		;ARG. IS IN AC C.
	MOVEM	A,C		;RESULTS TO C.
IFN KI10,<FLTR	0,SAVEB>
IFN KA10,<JSA	16,FLOAT	;MAKE EXP. A FLOATING
	EXP	SAVEB		;POINT NUMBER.>
	FMPRM	A,C		;CALC. B*ALOG(ABS(A)).
	JSA	16,EXP		;FIND EXP. OF THIS.
	EXP	C		;ARG IS IN AC C.
	JRST	OUT2		;GO AND TYPE ERROR MESSAGE.

MININF:	HRLOI	B,377777	;SET EXP = +INFINITY.
	PUSHJ	P,FEXP2		;GO TO MAIN ROUTINE.
	FMPR	A,SAVEA		;ANS. = ANS. TIMES A.
	JFCL	OVER		;GO TO OVER IF OVERFLOW.
	JRST	INV		;OTHERWISE, GO TO INV.


SAVEA:	0			;TEMP FOR A.
SAVEB:	0			;TEMP FOR B.
SAVEC:	0			;TEMP FOR C.

	LIT
	PRGEND
	TITLE	EXP  V.027
	SUBTTL	15-JUL-70	ED YOURDON/KK/DMN
;FROM	V.021	8-AUG-69

;FLOATING POINT SINGLE PRECISION EXPONENTIAL FUNCTION
;IF X<=-89.415..., THE PROGRAM RETURNS ZERO AS THE ANSWER
;IF X>=88.029..., THE PROGRAM RETURNS 377777777777 AS THE ANSWER
;THE RANGE OF THE ARGUMENT IS REDUCED AS FOLLOWS:
;EXP(X) = 2**(X*LOG(E)BASE2) = 2**(M+F)
;WHERE M IS AN INTEGER AND F IS A FRACTION
;2**M IS CALCULATED BY ALGEBRAICALLY ADDING M TO THE EXPONENT
;OF THE RESULT OF 2**F. 2**F IS CALCULATED AS

;2**F = 2(0.5+F(A+B*F^2 - F-C(F^2 + D)**-1)**-1

;THE ROUTINE HAS THE FOLLOWING CALLING SEQUENCE:
;	JSA	Q, EXP
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	A=	0
	B=	1
	C=	2
	D=	3
	Q=	16

	EXTERN TYPER.
	ENTRY	EXP



	SIXBIT/EXP/
EXP:	0			;ENTRY TO EXPONENTIAL ROUTINE
	MOVE	B, @(Q)		;PICK UP THE ARGUMENT IN B
	CAMGE	B,E77		;IS EXP. < -89.41...?
	JRST	OUT2		;YES, GO TO EXIT.
	CAMG	B,E7		;IS EXP. > +88.029...?
	JRST	EXP1		;GO TO STANDARD ALGORITHM.
	MOVEI	A,3		;SET UP ARG FOR ERROR MESSAGE.
	PUSHJ	17,TYPER.	;TYPE OUT ERROR MESSAGE.
	HRLOI	A, 377777	;GET LARGEST FLOATING NUMBER
	JRA	Q, 1(Q)		;EXIT

OUT2:	MOVEI	A,4		;SET UP ARG FOR ERROR MESSAGE.
	PUSHJ	17,TYPER.	;TYPE OUT ERROR MESSAGE.
	MOVEI	A,0		;ANSWER IS 0.
	JRA	Q,1(Q)		;EXIT


EXP1:	MOVEM	C, ES1		;SAVE ACCUMULATOR C
	MOVEM	D, ES3		;SAVE ACCUMULATOR D
	SETZM	ES2		;INITIALIZE ES2
	MULI	B, 400		;SEPARATE FRACTION AND EXPONENT
	TSC	B, B		;GET A POSITIVE EXPONENT
	MUL	C, E5		;FIXED POINT MULTIPLY BY LOG2(E)
	ASHC	C, -242(B)	;SEPARATE FRACTION AND INTEGER
	AOSG	C		;ALGORITHM CALLS FOR MULT. BY 2
	AOS	C		;ADJUST IF FRACTION WAS NEGATIVE
	HRRM	C, EX1		;SAVE FOR FUTURE SCALING
	JUMPG	D,ASHH		;GO AHEAD IF ARG > 0.
	TRNN	D,377		;ARE ALL THESE BITS 0?
	JRST	ASHH		;YES, GO AHEAD.
	ADDI	D,200		;NO, FIX UP.
ASHH:	ASH	D, -10		;MAKE ROOM FOR EXPONENT
	TLC	D, 200000	;PUT 200 IN EXPONENT BITS
	FADB	D, ES2		;NORMALIZE, RESULTS TO D AND ES2
	FMP	D, D		;FORM X^2
	MOVE	A, E2		;GET FIRST CONSTANT
	FMP	A, D		;E2*X^2 IN A
	FAD	D, E4		;ADD E4 TO RESULTS IN D
	MOVE	B, E3		;PICK UP E3
	FDV	B, D		;CALCULATE E3/(F^2 + E4)
	FSB	A, B		;E2*F^2-E3(F^2 + E4)**-1
	MOVE	C, ES2		;GET F AGAIN
	FSB	A, C		;SUBTRACT FROM PARTIAL SUM
	FAD	A, E1		;ADD IN E1
	FDVM	C, A		;DIVIDE BY F
	FAD	A, E6		;ADD 0.5
EX1:	FSC	A, 0		;SCALE THE RESULTS
	MOVE	C, ES1		;RESTORE ACCUMULATOR C
	MOVE	D, ES3		;RESTORE ACCUMULATOR D
	JRA	Q, 1(Q)		;EXIT

E1:	204476430062		;9.95459578
E2:	174433723400		;0.03465735903
E3:	212464770715		;617.97226953
E4:	207535527022		;87.417497202
E5:	270524354513		;LOG(E), BASE 2
E6:	0.5
E7:	207540074636		;88.029...
E77:	570232254037		;-89.415986
ES1:	0
ES2:	0
ES3:	0

	LIT
	PRGEND
	TITLE	ALOG  V.32(342)
	SUBTTL 23-NOV-71	/KK/DMN
;FROM	V.022	18-DEC-69

;FROM V.020.
;FLOATING POINT SINGLE PRECISION LOGARITHM FUNCTION
;LOG(ABSF(X)) IS CALCULATED BY THE SUBROUTINE, AND AN
;ARGUMENT OF ZERO IS RETURNED AS MINUS INFINITY.

;ALOG IS THE ENTRY POINT FOR LOGE(X), AND
;ALOG10 IS THE ENTRY POINT FOR LOG10(X).
;FOR LOGE(X), THE ALGORITHM IS:
;	LOGE(X) = (I + LOG2(F))*LOGE(2)
;	WHERE X = (F/2)*2^(I+1), AND LOG2(F) IS GIVEN BY
;	LOG2(F) = C1*Z + C3*Z^3 + C5*Z^5 - 1/2
;	AND Z = (F-SQRT(2))/(F+SQRT(2))
;FOR LOG10(X), THE ALGORITHM IS:
;	LOG10(X) = LOGE(X)*LOG10(E)

;THE CALLING SEQUENCE FOR THE ROUTINE IS AS FOLLOWS:
;	JSA	Q, ALOG OR ALOG10
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	A=	0
	B=	1
	Q=	16

	ENTRY ALOG,ALOG10
	EXTERN	TYPER.

	SIXBIT/ALOG10/
ALOG10:	0			;ENTRY TO LOG TO THE BASE 10 ROUTINE.
	MOVE	0,@(16)		;GET /X/ IN AC 0.
	JUMPE	0,LZERO		;CHECK FOR ZERO ARG.
	MOVEM	0,TEMP		;ARG TO LOC NE 0 OR 1.
	JSA	16,ALOG		;CALC THE LOG TO THE
	EXP	TEMP		;BASE E.
	FMPR	0,LOG10A	;MULTIPLY IT BY LOG10(E).
	JRA	16,1(16)	;EXIT.

LOG10A:	177674557305
TEMP:	0

	SIXBIT	/ALOG/
ALOG:	0			;ENTRY TO LOG TO THE BASE E ROUTINE.
	MOVE	A, @(Q)		;GET ABSF(X)
	JUMPG	A,ALOGOK	;ARG IS GREATER THAN 0
	JUMPE	A, LZERO	;CHECK FOR ZERO ARGUMENT
	MOVE	A,[[ASCIZ /ATTEMPT TO TAKE LOG OF NEGATIVE ARG/],,11]
	PUSHJ	17,TYPER.
	MOVM	A,@(Q)		;GET ABSF(X)
ALOGOK:	CAMN	A, ONE		;CHECK FOR 1.0 ARGUMENT
	JRST	ZERANS		;IT IS 1.0 RETURN ZERO ANS.
	ASHC	A, -33		;SEPARATE FRACTION FROM EXPONENT
	ADDI	A, 211000	;FLOAT THE EXPONENT AND MULT. BY 2
	MOVSM	A, LS		;NUMBER NOW IN CORRECT FL. FORMAT
	MOVSI	A, 567377	;SET UP -401.0 IN A
	FADM	A, LS		;SUBTRACT 401 FROM EXP.*2
	ASH	B, -10		;SHIFT FRACTION FOR FLOATING
	TLC	B, 200000	;FLOAT THE FRACTION PART
	FAD	B, L1		;B = B-SQRT(2.0)/2.0
	MOVE	A, B		;PUT RESULTS IN A
	FAD	A, L2		;A = A+SQRT(2.0)
	FDV	B, A		;B = B/A
	MOVEM	B, LZ		;STORE NEW VARIABLE IN LZ
	FMP	B, B		;CALCULATE Z^2
	MOVE	A, L3		;PICK UP FIRST CONSTANT
	FMP	A, B		;MULTIPLY BY Z^2
	FAD	A, L4		;ADD IN NEXT CONSTANT
	FMP	A, B		;MULTIPLY BY Z^2
	FAD	A, L5		;ADD IN NEXT CONSTANT
	FMP	A, LZ		;MULTIPLY BY Z
	FAD	A, LS		;ADD IN EXPONENT TO FORM LOG2(X)
	FMP	A, L7		;MULTIPLY TO FORM LOGE(X)
	JRA	16,1(16)	;EXIT
LZERO:	MOVEI	A,3		;SET UP AC 0 FOR TYPER.
	PUSHJ	17,TYPER.	;GO TO TYPER.
	MOVE	A,MIFI		;PICK UP MINUS INFINITY
	JRA	Q, 1(Q)		;EXIT
ZERANS:	MOVEI	A, 0		;MAKE ANSWER ZERO
	JRA	16,1(16)	;EXIT

;CONSTANTS

ONE:	201400000000
L1:	577225754146		;-0.707106781187
L2:	201552023632		;1.414213562374
L3:	200462532521		;0.5989786496
L4:	200754213604		;0.9614706323
L5:	202561251002		;2.8853912903
L7:	200542710300		;0.69314718056
MIFI:	400000000001		;LARGEST NEGATIVE FLOATING NUMBER

LS:	0
LZ:	0

	PRGEND
	TITLE	SIN	V.32(340)
	SUBTTL	23-NOV-71	ED YOURDAN/KK/DMN

;FROM V.020
;FLOATING POINT SINGLE PRECISION SINE AND COSINE FUNCTION

;IF THE ARGUMENT IS IN DEGREES, THE PROPER ENTRY POINTS ARE
;SIND AND COSD, WHILE IF THE ARGUMENT IS IN RADIANS, THE
;PROPER ENTRY POINTS ARE SIN AND COS.
;COSD CALLS SIND TO CALCULATE SIND(PI/2+X)
;COS CALLS SIN TO CALCULATE SIN (PI/2+X)
;SIND CALLS SIN AFTER A CONVERSION FROM DEGREES TO RADIANS.

;THIS ROUTINE CALCULATES SINES AFTER REDUCING THE ARGUMENT TO
;THE FIRST QUADRANT AND CHECKING THE OVERFLOW BITS TO DETERMINE
;THE QUADRANT OF THE ORIGINAL ARGUMENT.
;000 - 1ST QUADRANT
;001 - 2ND QUADRANT
;010 - 3RD QUADRANT
;011 - 4TH QUADRANT
;THE ALGORITHM USES A MODIFIED TAYLOR SERIES TO CALCULATE 
;THE SINE OF THE NORMALIZED ARGUMENT.

;THE ROUTINES ARE CALLED IN THE FOLLOWING MANNER:
;	JSA	Q,SIN		(OR COS,SIND, OR COSD)
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	ENTRY SIN,COS,SIND,COSD
A=0
B=1
C=2
Q=16

	SIXBIT/COSD/
COSD:	0			;ENTRY TO COSINE DEGREES ROUTINE.
	MOVE	B,@(Q)		;PICK UP THE ARG.
	FADR	B,CD1		;ADD 90 DEGREES.
	FDVR	B,SCD1		;CONVERT TO RADIANS.
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP.
	JRST	S1		;ENTER SINE ROUTINE.

	SIXBIT/SIND/
SIND:	0			;ENTRY TO SINE DEGREES ROUTINE.
	MOVE	B,@(Q)		;PICK UP THE ARG.
	FDVR	B,SCD1		;CONVERT TO RADIANS
	JFCL			;SUPPRESS ERROR MESSAGE ON UNDERFLOW.
	JRST	S1		;ENTER SINE ROUTINE.

	SIXBIT/COS/
COS:	0			;ENTRY TO COSINE RADIANS ROUTINE.
	MOVE	B,@(Q)		;PICK UP THE ARG.
	FADR	B,PIOT		;ADD PI/2.
	JRST	S1		;ENTER SINE ROUTINE.


	SIXBIT/SIN/
SIN:	0			;ENTRY TO SINE RADIANS ROUTINE.
	MOVE	B,@(Q)		;PICK UP THE ARG.
S1:	MOVEM	B,SX		;SAVE THE ARG.
	MOVMS	B		;GET ABS OF ARG.
	CAMG	B,SP2		;SIN(X)=X IF X<2^-9.
	JRST	S3A		;EXIT WITH ARG. IN A.
	MOVEM	C,SC		;SAVE AC C.
	FDV	B,PIOT		;DIVIDE X BY PI/2.
	CAMG	B,ONE		;IS X/(PI/2) < 1.0 ?
	JRST	S2		;YES,ARG IN 1ST QUADRANT ALREADY.
	MULI	B,400		;NO,SEPARATE FRACTION AND EXP.
	LSH	C,-202(B)	;GET X MODULO 2PI.
	TLZ	C,(1B0)		;SUPRESS ERROR MESSAGE FROM OVTRAP.
	MOVEI	B,200		;PREPARE FLOATING FRACTION.
	ROT	C,3		;SAVE THREE BITS TO DETERMINE QUADRANT.
	LSHC	B,33		;ARGUMENT NOW IN THE RANGE (-1,1).
	FAD	B,SP3		;NORMALIZE THE ARGUMENT.
	JUMPE	C,S2		;REDUCED TO 1ST QUAD IF BITS 000.
	TLCE	C,1000		;SUBTRACT 1.0 FROM ARG IF BITS ARE
	FSB	B,ONE		;001 OR 011.
	TLCE	C,3000		;CHECK FOR FIRST QUADRANT, 001.
	TLNN	C,3000		;CHECK FOR THIRD QUADRANT, 010.
	MOVNS	B		;001,010.
S2:	SKIPGE	SX		;CHECK SIGN OF ORIGINAL ARG.
	MOVNS	B		;SIN(-X)=-SIN(X).
	MOVEM	B,SX		;STORE REDUCED ARG.
	FMPR	B,B		;CALCULATE X^X
	MOVE	A,SC9		;GET 1ST CONSTANT.
	FMP	A,B		;MULTIPLY BY X^2
	FAD	A,SC7		;ADD IN NEXT CONSTANT.
	FMP	A,B		;MULTIPLY BY X^2.
	FAD	A,SC5		;ADD IN NEXT CONSTANT.
	FMP	A,B		;MULTIPLY BY X^2.
	FAD	A,SC3		;ADD IN NEXT CONSTANT.
	FMP	A,B		;MULTIPLY BY X^2.
	FAD	A,PIOT		;ADD IN LAST CONSTANT.
S2B:	FMPR	A,SX		;MULTIPLY BY X.
	SKIPA	C,SC		;RESTORE AC C.
S3A:	MOVE	A,SX		;ANSWER IN X.
	JRA	Q,1(Q)		;EXIT.

SC3:	577265210372
SC5:	175506321276
SC7:	606315546346
SC9:	164475536722

SP2:	170000000000
SP3:	0
SX:	0
CD1:	90.0
SCD1:	206712273406
PIOT:	201622077325
SC:	0
ONE:	1.0
	END
  :@0E