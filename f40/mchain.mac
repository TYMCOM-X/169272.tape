CHNSPC==14
CHNREL==6

IFNDEF F40,<F40==1>     ;NONZERO SAYS F40 VERSION, ZERO SAYS SFORTRAN VERSION

%CHNVR==<CHNSPC,,CHNREL>

SALL

DEFINE TITL(SP,RL)<
IFE F40,<TITLE SFOCHN VERSION SP'.'RL - SFORTRAN MIGHTYCHAIN>
IFN F40,<TITLE F40CHN VERSION SP'.'RL - F40 MIGHTYCHAIN>
>

TITL(\CHNSPC,\CHNREL)

SUBTTL  WHAT THIS WORLD NEEDS IS A GOOD TWO DOLLAR ROOM AND A GOOD TWO DOLLAR BROOM

ENTRY CHAIN.,OVERLAY
IFN F40,<ENTRY CHAIN,CHNMN.>
INTERN %CHNVR,CHNIN.
EXTERN .JBFF,JOBHCU,JOBJDA,.JBREL,.JBSA,.JB41,.JBREN,.JBDDT
EXTERN OVTAB.
IFN F40,<EXTERN FORSE.,EXIT.,ALLIO.,NMLST.,TPFCN.,DISAB.,ENAB.>
IFE F40,<EXTERN $SAVEA,$STRCH,$MOVDSA,$FIXBUF,$ISGET,$SGET,$SREMO,NCNER.>
IFE F40,<EXTERN $OFFALT,$ONALT,RSTOR.,IGNOV.,RSAVE.>
IFE F40,<SAVEAC==$SAVEA>
SEXTERN DDTCH.
IFN F40,<SEXTERN DYNDV.,UUOH.,SAVEAC,DEBCH.,BUFHD.,LINK.,X22OV.>
IFE F40,<SEXTERN $MEMORY,$ACTOC,$DEAOC>
IFN F40,<INTERN $JBNM$>
IFE F40,<EXTERN $JBNM$>
DEFINE DISABLE<
 IFE F40,<JSP P,$OFFALT>
 IFN F40,<
        MOVE    P,STKPTR
        PUSHJ   P,DISAB.
 >
>
DEFINE ENABLE<
 IFE F40,<JSP P,$ONALT>
 IFN F40,<
        MOVE    P,STKPTR
        PUSHJ   P,DISAB.
 >
>

;ACCUMULATORS
A=1     ;A AND UP GET USED IN SIMPL CALLS
B=2
C=3
D=4
E=5
F=6
G=7
H=10
SEG=11  ;TREE TABLE POINTER
L=16
P=17

;ENTRIES IN OVERLAY FILE HEADER (BLOCK 1)
OVFVER==1       ;VERSION NUMBER WE EXPECT TO SEE - MUST MATCH OVFHVR
OVFHLN==2       ;LENGTH OF HEADER
OVFHVR=OVFHDR+0 ;VERSION NUMBER OF OVERLAY FILE ITSELF
OVFHDT=OVFHDR+1 ;DATE-TIME OF OVERLAY FILE FOR CONSISTENCY CHECK WITH SAVE FILE

;ENTRIES IN OVERLAY TABLE
OVFLG=OVTAB.    ;LH: FLAGS
SEGCNT=OVTAB.   ;RH: # OF SEGMENTS (NOT COUNTING ROOT)
OVFDAT=OVTAB.+1 ;DATE-TIME WE EXPECT FOR OVERLAY FILE - MUST MATCH OVFHDT
TRETAB=OVTAB.+2 ;BEGINNING OF TREE TABLE

;WORDS IN TREE TABLE ENTRY
SEGNAM==0       ;SIXBIT NAME OF FIRST SUBROUTINE IN SEGMENT
SEGLOC==1       ;IOWD SEGMENT SIZE,SEGMENT BASE
SEGFLG==2       ;BITS 0-5: SEGMENT FLAGS
SEGBLK==2       ;BITS 6-17: SEGMENT'S BLOCK # IN .OVL FILE (FOR USETI)
SEGLNK==2       ;RH: BACK LINK IN TREE TABLE
SEGSUB==3       ;LH: LOC OF FIRST SUBROUTINE IN SEGMENT
SEGCMP==3       ;RH: # OF WORDS IN COMPRESSED SEG
ENTSIZ==4       ;NUMBER OF WORDS IN A TREE TABLE ENTRY

;FLAGS IN OVFLG
CLSCHN==400000  ;CLOSE CHAIN FILE AFTER EACH OVERLAY (SET BY LOADER)
FILOPN==200000  ;CHAIN FILE IS CURRENTLY OPEN

;FLAGS IN SEGFLG
INCOR==400000   ;SEGMENT IS IN CORE
NEWIN==200000   ;SEGMENT WILL BE IN CORE WHEN WE FINISH
IFN F40,<
MAINPG==100000  ;SEGMENT CONTAINS A MAIN PROGRAM
>

;RANDOM SHIT

.GTPRG==3       ;GETTAB FOR SAVE-FILE NAME
.GTFPN==-25     ;GETTAB FOR SAVE-FILE PPN

ZAP==0          ;ZAP IS USED WHERE AN INSTRUCTION WILL BE MODIFIED

DEFINE OP(A)<<A>B62>    ;9-BIT OPCODE RIGHT JUSTIFIED

;INITIALIZATION ENTRY CALLED BY FORSE OR SFOLIB/FOROTS
CHNIN.: MOVE    A,.JBFF
        SUBI    A,1
        MOVEM   A,OLDTOP        ;INITIALIZE OLD SEGMENT TOP
        JSR     GENFNM          ;INITIALIZE OVERLAY FILE NAME
IFE F40,<
        JRST    (P)
>
IFN F40,<
        POPJ    P,
>

IFE F40,<

;AUTOMATIC OVERLAY ROUTINE CALLED BY UUO HANDLER
CHAIN.: MOVEI   [ASCIZ/BAD CALL/]
        MOVE    A,SAVEAC+P
        MOVE    A,(A)           ;LOC+1 OF UUO
        LDB     SEG,[POINT 4,-1(A),12]
        LDB     A,[POINT 4,-1(A),17]
        LSH     SEG,4           ;COMPUTE SEG # WHICH IS IN A AND X FIELDS
        OR      SEG,A
        CAILE   SEG,@SEGCNT     ;SEE IF WITHIN BOUNDS
        JSR     ERR
        IMULI   SEG,ENTSIZ
        MOVEI   SEG,TRETAB(SEG) ;GET POINTER INTO TREE TABLE
        JSR     GITSEG          ;GET SEGMENT IN CORE IF NECESSARY
        MOVEI   [ASCIZ/BAD CALL/]
        MOVE    P,SAVEAC+P      ;USER'S PDL PTR
        MOVE    A,(P)           ;A= USER FLAGS,,LOC+1 OF UUO
        HRRZ    B,-1(A)         ;B= LOC OF INST. REPLACED BY UUO (ORIGINAL SUBROUTINE CALL)
        CAMLE   B,.JBREL
        JSR     ERR             ;BETTER BE IN CORE
        HLRZ    C,(B)           ;C= OPCODE AND AC FROM SUBROUTINE CALL
        CAIE    C,(PUSHJ P,)    ;BETTER BE OUR FAVORITE CALL
        JSR     ERR
        HRR     A,(B)           ;FINE, MAKE A= USER FLAGS,,SUBROUTINE LOC (FOOR JRSTF)
        PUSH    P,A             ;LIBINT EXPECTS IT ON TOP OF USER STACK
        MOVEM   P,SAVEAC+P      ;STACK TOP-1 IS ORIGINAL CALL PC, STACK TOP IS OUR FAKEOUT
        JRST    RSTOR.          ;LET LIBINT DO THE REST (RESTORE REGS, GO TO USER)

;CALL OVERLAY('NAME')
OVERLA: MOVEM   17,SAVEAC+17
        MOVEI   17,SAVEAC
        BLT     17,SAVEAC+16
        SOS     IGNOV.
        SETOM   RSAVE.
        MOVE    [POINT 6,SXTXT]
        MOVEM   SXPTR
        MOVEI   6
        MOVEM   SXCNT
        SETZM   SXTXT
        MOVEI   A,SCR
        MOVEI   B,1
        JSP     P,$ISGET
STRLP:  MOVEI   A,SCR
        JSP     P,$SGET         ;GET STRING ARG A CHAR AT A TIME AND
        JUMPE   A,STRDON
        SUBI    A,40            ;CONVERT IT TO SIXBIT
        IDPB    A,SXPTR
        SOSLE   SXCNT
        JRST    STRLP
STRDON: MOVEI   A,1
        JSP     P,$SREMO        ;CLEAN UP STRING STACK
        MOVE    A,SXTXT
        JSR     FINDSG          ;FIND SEGMENT NAME
        HLRZ    A,SEGSUB(SEG)   ;GET LOC OF FIRST SUBROUTINE IN SEG
        SKIPN   A
        JSR     ERR             ;IT BETTER BE THERE
        MOVEM   A,USRSUB        ;SAVE IT FOR LATER
        JSR     GITSEG          ;GET SEGMENT IN CORE IF NECESSARY
        MOVE    P,SAVEAC+P      ;IT'S IN CORE, RETURN TO USER
        HLLZ    A,(P)
        HLLM    A,USRSUB        ;USER FLAGS FOR JRSTF
        MOVSI   17,SAVEAC
        BLT     17,17           ;RETURN FROM CALL OVERLAY('NAME')
        SETZM   RSAVE.
        AOS     IGNOV.
        JRSTF   @USRSUB

>

IFN F40,<

;AUTOMATIC OVERLAY ROUTINE CALLED BY OVERLAY HANDLER
CHAIN.: MOVEI   [ASCIZ/BAD CALL/]
        HRRZ    A,UUOH.
        MOVEM   A,USRLOC        ;LOC+1 OF UUO
        LDB     SEG,[POINT 4,-1(A),12]
        LDB     A,[POINT 4,-1(A),17]
        LSH     SEG,4           ;COMPUTE SEG # WHICH IS IN A AND X FIELDS
        OR      SEG,A
        CAILE   SEG,@SEGCNT     ;SEE IF WITHIN BOUNDS
        JSR     ERR
        IMULI   SEG,ENTSIZ
        MOVEI   SEG,TRETAB(SEG) ;GET POINTER INTO TREE TABLE
        JSR     GITSEG          ;GET SEGMENT IN CORE IF NOT ALREADY
        MOVEI   [ASCIZ/BAD CALL/]
        MOVE    A,USRLOC
        HRRZ    A,-1(A)         ;GET ADDRESS OF REPLACED INSTRUCTION
        CAMLE   A,.JBREL        ;CHECK FOR LEGAL
        JSR     ERR
        HRRZ    B,(A)           ;GET JUMP ADDRESS
        HRRM    B,USRLOC        ;NOW USRLOC= FLAGS,,E FROM INSTRUCTION
        LDB     B,[POINT 4,(A),12]      ;GET AC FIELD
        LDB     C,[POINT 9,(A),8]       ;GET OPCODE
        CAIN    C,OP(JSA)
        JRST    IJSA
        CAIN    C,OP(JSR)
        JRST    IJSR
        LSH     B,5
        MOVEI   A,<(PUSH)>(B)
        CAIN    C,OP(PUSHJ)
        JRST    IJMP
        MOVEI   A,<(MOVE @)>(B)
        CAIN    C,OP(JSP)
        JRST    IJMP
        MOVEI   A,(JFCL)
        CAIE    C,OP(JRST)
        JSR     ERR
IJMP:   HRLM    A,IJMP1         ;SAVE THEM
        MOVSI   17,SAVEAC
        BLT     17,17           ;RESTORE USER'S ACS
        EXCH    16,SAVEAC+16
        MOVE    17,SAVEAC+17
        XCT     IJMP1           ;DO SOMETHING WITH OLD PC
        JRSTF   @USRLOC         ;DO THE JUMP

IJSA:   MOVSI   A,-3
        DPB     B,[POINT 4,IJSA1(A),12] ;SAVE AC IN THREE PLACES
        AOBJN   A,.-1
        MOVSI   17,SAVEAC
        BLT     17,15           ;RESTORE USER'S ACS
        EXCH    16,SAVEAC+16
        MOVE    17,SAVEAC+17
IJSA1:  MOVEM   ZAP,@USRLOC     ;PLACE (AC) IN LOCATION E
        HRLZ    ZAP,USRLOC      ;PLACE E IN AC LEFT
        HRR     ZAP,UUOH.       ;PLACE PC IN AC RIGHT
IJSA2:  AOS     USRLOC
        JRSTF   @USRLOC         ;JUMP TO E+1

IJSR:   MOVE    A,UUOH.
        MOVEM   A,@USRLOC       ;PLACE FLAGS,,PC IN LOCATION E
        MOVSI   17,SAVEAC
        BLT     17,15           ;RESTORE USER'S ACS
        EXCH    16,SAVEAC+16
        MOVE    17,SAVEAC+17
        JRST    IJSA2           ;JUMP TO E+1

;CALL OVERLAY('NAME')
OVERLA: 0
        MOVEM   P,SAVEP
        MOVEI   A,0
        MOVEI   B,6
        MOVE    C,(L)
        HRLI    C,(POINT 7,0)
        MOVE    D,[POINT 6,A]
OCVNM:  ILDB    C
        JUMPE   OCVNM1
        SUBI    40
        IDPB    D               ;CONVERT NAME TO SIXBIT
        SOJG    B,OCVNM
OCVNM1: JSR     FINDSG          ;LOOK UP THE SEGMENT NAME
        HLRZ    A,SEGSUB(SEG)   ;GET LOC OF FIRST SUBROUTINE IN SEG
        SKIPN   A
        JSR     ERR             ;IT BETTER BE THERE
        MOVEM   A,USRSUB        ;SAVE IT FOR LATER
        JSR     GITSEG          ;GET SEGMENT IN CORE IF NOT ALREADY THERE
        HRL     L,USRSUB
        MOVE    P,SAVEP
        MOVE    OVERLA
        MOVEM   @USRSUB
        AOS     USRSUB
        JRST    @USRSUB

;CALL CHAIN('NAME')
CHAIN:  0
        MOVEI   A,0
        MOVEI   B,6
        MOVEI   D,(L)
        LDB     [POINT 9,(D),8]
        CAIN    OP(JUMP)    SEARCH FOR LAST ARGUMENT
        AOJA    D,.-2           ;THIS WAY ALLOW NEW CALLING SEQUENCE
        MOVE    C,-1(D)         ;AND DEC'S OLD CALLING SEQUENCE
        HRLI    C,(POINT 7,0)
        MOVE    D,[POINT 6,A]
CVNM:   ILDB    C
        JUMPE   CVNM1
        SUBI    40              ;CONVERT ASCIZ TO SIXBIT
        IDPB    D
        SOJG    B,CVNM          ;NEVER MORE THAN 6
CVNM1:  SETZM   .JBSA           ;FOR ERROR CHECKING
        JSR     FINDSG          ;FIND THE SEGMENT NAME
MNCHN:  JSR     GITSEG          ;GET SEGMENT IN CORE IF NECESSARY
        MOVSI   A,FILOPN
        ANDCAM  A,OVFLG         ;ZAP FILE-OPEN FLAG
        XCT     CLS             ;(MAIN PROGRAM PROBABLY DOES A RESET)
        MOVEI   [ASCIZ/NO MAIN PROGRAM/]
        HRRZ    A,.JBSA
        JUMPN   A,(A)
        JSR     ERR

;INITIALIZATION FOR MAIN PROGRAM OVERLAY - JOBSA IS SET TO CHNMN.+1
CHNMN.: 0                       ;SEG PTR FOR FIRST MAIN PROGRAM - SET UP BY LOADER
        RESET.                  ;MAKE FORSE HAPPY
        HRRZ    SEG,CHNMN.      ;GET SEG PTR FOR INITIAL MAIN PROGRAM
        JRST    MNCHN           ;GO GET IT

>;END OF IFN F40


;GENERATES OVERLAY FILE LOOKUP BLOCK
GENFNM: 0
        SKIPN   A,$JBNM$        ;LH = SIXBIT JOB NUMBER IF TEMP FILE, 0 IF SAVE FILE
        JRST    FNMSVF          ;ZERO, WE'RE RUNNING FROM A SAVE FILE
        HRRI    A,'OVL'         ;NONZERO, SET UP NNNOVL.TMP
        MOVEM   A,OVLFIL
        MOVSI   A,'TMP'
        MOVEM   A,OVLFIL+1
        SETZM   OVLFIL+3        ;NO PPN FOR TEMP FILE
        JRST    FNMDON
FNMSVF: HRROI   A,.GTPRG        ;<SAVE-FILE-NAME>.OVL[<SAVE-FILE-PPN>]
        GETTAB  A,              ;PROGRAM NAME
         HALT
        MOVEM   A,OVLFIL
        MOVSI   A,'OVL'
        MOVEM   A,OVLFIL+1
        HRROI   A,.GTFPN
        GETTAB  A,              ;SAVE-FILE PPN
         HALT
        MOVEM   A,OVLFIL+3
FNMDON: JRST    @GENFNM


;CALLED WITH SEGMENT NAME IN A (SIXBIT), RETURNS SEGMENT'S TRETAB PTR IN SEG
FINDSG: 0
        HRRZ    B,SEGCNT
        MOVEI   SEG,TRETAB+ENTSIZ
FNDNM:  CAMN    A,SEGNAM(SEG)   ;LOOK FOR THE NAME
        JRST    @FINDSG         ;FOUND IT!
        ADDI    SEG,ENTSIZ      ;NO, TRY NEXT
        SOJG    B,FNDNM
        MOVEM   A,OVLFIL        ;FAKE OUT ERROR PRINTER
        SETZM   OVLFIL+1
        MOVEI   [ASCIZ/NO SEGMENT NAMED /]
        JSR     FILERR


;BRINGS ANY NEEDED OVERLAY SEGMENT(S) INTO CORE, UPDATES TABLES
GITSEG: 0
        SKIPGE  SEGFLG(SEG)     ;IS THE SEGMENT ALREADY IN CORE?
        JRST    @GITSEG         ;YES, THAT WAS EASY!
        MOVEM   SEG,TOPSEG
; Close unit 5 (terminal) 
; (I don't know whether I need to save all registers for the UUO,
;  but it can't hurt to save them...DJF)
	MOVEM	17,REGS+17	;Save register 17
	MOVEI	17,REGS		;Source=0, Destination=REGS
	MOVE	17,REGS+17	;Restore register 17
	BLT	17,REGS+16	;Save registers 0-16
	MOVEI	0,5		;CLOSE(5)
	35B8			; via FCALL.
	MOVSI	17,REGS		;Source=REGS, Destination=0
	BLT	17,17		;Restore registers 0-17
	JRST	GETSE1
REGS:	BLOCK	20		;For saving registers 0-17
GETSE1:
; (End of fix...DJF)
        DISABLE
        MOVE    SEG,TOPSEG
        HLRZ    A,SEGLOC(SEG)
        MOVN    A,A
        ADD     A,SEGLOC(SEG)
        HRRZM   A,NEWTOP        ;NEW PROGRAM TOP
        SUB     A,OLDTOP
        HRREM   A,OVLDIS        ;DISPLACEMENT FROM OLD TOP TO NEW
        MOVE    A,OVFLG
        TLNN    A,FILOPN        ;IS A FILE OPEN?
        JSR     OPNFIL          ;NO, OPEN ONE UP
        JSR     MRKNEW          ;TURN ON NEWIN BIT FOR NEW SEGMENTS
IFE F40,<
        MOVSI   (JRST(P))
        JSP     P,$DEAOC        ;TELL DEBUGGER TO KILL OVERLAY BREAKPOINTS
>
        JSR     JUGDYN          ;JUGGLE DYNAMIC STORAGE
        JSR     RDSEGS          ;READ IN ALL NEEDED SEGMENTS
        SKIPL   A,OVFLG         ;DONE WITH I/O, SHOULD WE RELEASE CHANNEL?
        TLOA    A,FILOPN        ;NO, SET FILE-OPEN AND SKIP
        XCT     CLS             ;YES, CLOSE IT
        MOVEM   A,OVFLG         ;SAVE FLAGS
        MOVE    P,STKPTR
        MOVE    A,OVLBEG
        MOVSI   (POPJ P,)
        PUSHJ   P,DDTCH.        ;TELL DDT WHAT'S HAPPENING
IFN F40,<
        PUSHJ   P,DEBCH.        ;DITTO FOR FDEBUG
>
IFE F40,<
        MOVSI   (JRST(P))
        JSP     P,$ACTOC        ;TELL DEBUGGER TO REINSTATE OVERLAY BREAKPOINTS
>
        JSR     FIXMRK          ;CLEAN UP THE IN-CORE BITS
        ENABLE
        JRST    @GITSEG         ;WHEW!


;OPENS UP THE OVERLAY FILE
OPNFIL: 0
        JSR     GETCHN          ;GET A CHANNEL NUMBER
        MOVE    A,[OVLFIL,,OVFBLK]
        BLT     A,OVFBLK+3      ;COPY FILE NAME INTO LOOKUP BLOCK
        MOVEI   [ASCIZ/CAN'T OPEN FILE /]
        XCT     OPN             ;OPEN DEVICE
        SIXBIT  'DSK'
        0
         JSR    FILERR
        XCT     LOOK            ;FIND FILE NAME
         JSR    FILERR
        JSR     CHKHDR          ;CHECK .SAV/.OVL CONSISTENCY
        JRST    @OPNFIL


;FINDS AN UNUSED I/O CHANNEL AND SETS UP I/O INSTRUCTIONS
GETCHN: 0
        MOVEI   [ASCIZ'NO I/O CHANNELS AVAILABLE']
IFN F40,<
        MOVEI   A,17            ;GET THE HIGHEST AVAILABLE CHANNEL
TRYCHN: SKIPE   DYNDV.(A)       ;SEE WHAT FORSE THINKS ABOUT IT
        JRST    NXTCHN          ;MY MY IT'S BUSY
        CAMG    A,JOBHCU        ;FORSE DON'T WANT IT, SEE WHAT MONITOR THINKS
        SKIPN   JOBJDA(A)       ;SHOULD BE EITHER ABOVE JOBHCU OR UNMARKED IN JOBJDA
        JRST    GOTCHN          ;GOODIE IT'S REALLY FREE
NXTCHN: SOJGE   A,TRYCHN        ;NO LUCK, TRY NEXT ONE
        JSR     ERR             ;RAN OUT, TOO BAD
GOTCHN: SKIPL   OVFLG           ;FOUND A CHANNEL, WILL WE BE KEEPING IT OPEN?
        SETOM   DYNDV.(A)       ;YES, TELL FORSE ABOUT IT
>
IFE F40,<
        MOVEI   A,0             ;CAN'T THINK OF ANYTHING BETTER, SO USE 0
        SKIPE   JOBJDA
        JSR     ERR
>
        DPB     A,[POINT 4,OPN,12]
        DPB     A,[POINT 4,LOOK,12]
        DPB     A,[POINT 4,SETI,12]
        DPB     A,[POINT 4,READ,12]
        DPB     A,[POINT 4,READHD,12]
        DPB     A,[POINT 4,CLS,12]
        JRST    @GETCHN


;TESTS OVERLAY FILE HEADER FOR CONSISTENCY WITH CORE IMAGE
CHKHDR: 0
        XCT     READHD          ;READ IN OVERLAY FILE HEADER
        JRST    HDOK
         MOVEI  [ASCIZ/ERROR READING FILE /]
         JSR    FILERR
HDOK:   MOVEI   [ASCIZ/INCORRECT FILE FORMAT IN /]
        MOVE    A,OVFHVR
        CAIE    A,OVFVER        ;MUST HAVE CORRECT VERSION NUMBER
        JSR     FILERR
        MOVEI   [ASCIZ/THIS CORE IMAGE DOES NOT MATCH OVERLAY FILE /]
        MOVE    A,OVFHDT
        CAME    A,OVFDAT        ;DATE-TIME FOR .OVL AND .SAV MUST MATCH
        JSR     FILERR
        JRST    @CHKHDR


;TURNS NEWIN ON FOR SEGMENTS WHICH WILL BE IN CORE AFTER OVERLAY IS PERFORMED
MRKNEW: 0
        MOVE    SEG,TOPSEG      ;HIGHEST IN-CORE SEGMENT
MRK1:   MOVSI   A,NEWIN
        ORB     A,SEGFLG(SEG)   ;THIS ONE WILL BE IN
        TLNN    A,INCOR
        HRRZ    B,SEGLOC(SEG)   ;B WILL BE THE HIGHEST LOCATION UNAFFECTED BY THE OVERLAY
        HRRZ    SEG,SEGLNK(SEG) ;RUN DOWN THE PATH BACK TO THE ROOT
        JUMPN   SEG,MRK1
        MOVEM   B,OVLBEG
        JRST    @MRKNEW

IFE F40,<

;JUGGLES DYNAMIC STORAGE TO MAKE ROOM FOR OVERLAY
JUGDYN: 0
        MOVE    A,OVLDIS        ;GET DISPLACEMENT FROM OLD TO NEW
        ADDM    A,$MEMOR        ;LET DEBUGGER KNOW IT MOVED
        JSP     P,$FIXBUF       ;LET IOCS FIX UP ITS I/O BUFFERS
        MOVE    A,OVLDIS
        JSP     P,$MOVDSA       ;MOVE DYNAMIC STORAGE
        MOVE    [ASCIZ/INSUFFICIENT CORE/]
        SKIPN   A
        JSR     ERR             ;DIDN'T HAVE ROOM
        MOVE    A,OVLDIS
        JSP     P,$STRCH        ;FIX UP STRING LIBRARY
        MOVE    A,NEWTOP
        MOVEM   A,OLDTOP        ;OLD IS NOW NEW
        JRST    @JUGDYN
>
IFN F40,<

;JUGGLES DYNAMIC STORAGE TO MAKE ROOM FOR OVERLAY
JUGDYN: 0
        MOVSI   A,(JRA L,(L))
        SKIPLE  OVLDIS          ;IF MOVING UP, THEN CALL 1022 FIXUP ROUTINE
        JSA     L,X22OV.        ;TO MOVE ITS DYNAMIC AREA (WHICH IS ABOVE I/O BUFFERS)
        JUMP    OVLDIS

;MOVE I/O BUFFERS TO THE TOP OF THE NEW SEGMENT AND FIX THEM UP.
;THE BUFFERS ARE MOVED DOWN INTO A BLOCK, THE LOWEST BUFFERS BEING
;MOVED FIRST.  IF THE NEW SEGMENT IS SHORTER THAN THE OLD ONE, THIS
;BLOCK BEGINS AT THE TOP OF THE NEW SEGMENT.  IF THE NEW SEGMENT IS
;LONGER, THE BLOCK BEGINS AT THE TOP OF THE OLD SEGMENT AND IS THEN
;MOVED UP TO THE TOP OF THE NEW SEGMENT AFTER THE BUFFERS HAVE
;BEEN COMPACTED.  THIS IS DONE TO AVOID PROBLEMS WITH BUFFERS
;GETTING CLOBBERED AS THEY ARE SHUFFLED AROUND.
;THIS CODE ASSUMES THAT ALL BUFFER HEADERS ARE IN THE BUFHD. ARRAY AND
;THAT THE BUFFERS WITHIN A SINGLE RING ARE CONTIGUOUS.
;IT IS ALSO ASSUMED THAT THE FIRST WORD OF INACTIVE HEADERS IS ZERO
;AND THAT BIT 17 OF THE BYTE POINTER IN A HEADER IS ZERO (IT IS USED
;TEMPORARILY AS A FLAG).

        SETZM   LINK.           ;ZAP FORSE'S FREE BUFFER CHAIN
        MOVE    A,NEWTOP
        CAMG    A,OLDTOP
        SKIPA   B,A             ;B=TOP (AND RIGHT NOW BOTTOM) OF BUFFER BLOCK-1
        MOVE    B,OLDTOP        ;(LOWER OF OLD AND NEW TOPS)
        MOVNM   B,BUFDIS
        ADDM    A,BUFDIS        ;(FUTURE BUFFER BLOCK LOC)-(CURRENT BLOCK LOC)
ADJLP:  HRREI   C,-1
        MOVSI   D,-40
ADJCK:  HRRZ    E,BUFHD.(D)     ;GET BUFFER PTR FOR THIS HEADER
        MOVE    F,BUFHD.+1(D)
        TLNN    F,1             ;IF NOT ALREADY DONE
        CAMG    E,OLDTOP        ;AND IN DYNAMIC AREA, MIGHT BE LOWEST BUFFER
        JRST    ADJNF           ;FAILED ONE TEST
        JUMPL   C,.+2           ;ALSO MUST BE FIRST ONE FOUND
        CAIGE   E,@BUFHD.(C)    ;OR LOWER THAN CURRENT LOWEST ONE
        HRRZ    C,D             ;YUP, C=LOWEST BUFFER SO FAR
ADJNF:  ADDI    D,2
        AOBJN   D,ADJCK         ;CHECK NEXT HEADER
        JUMPL   C,ADJFIX        ;JUMP IF NONE FOUND (ALL DONE)
        HRRZ    D,BUFHD.(C)     ;D WILL BE LOWEST BUFFER IN THIS RING
        HRRZ    E,D             ;E WILL BE HIGHEST
        HRRZ    F,E
ADJBFS: HRRZ    F,(F)           ;POINT F TO NEXT BUFFER IN RING
        CAMLE   D,F
        MOVE    D,F             ;D=LOWER OF TWO
        CAMGE   E,F
        MOVE    E,F             ;E=HIGHER OF TWO
        CAIE    F,@BUFHD.(C)
        JRST    ADJBFS          ;RUN THROUGH WHOLE RING
        MOVE    F,B
        ADD     F,BUFDIS
        SUB     F,D
        MOVEI   F,2(F)          ;(FUTURE RING LOCATION)-(CURRENT LOCATION)
        MOVEI   G,(C)
        IDIVI   G,6             ;CHANNEL #
        MOVSI   G,(G)           ;RIGHT PLACE FOR MOVBUF
        CAIG    H,2
        TLOA    G,20            ;INPUT
        TLO     G,40            ;OUTPUT
        HRRI    G,(F)
        MOVBUF  G,              ;TELL THE MONITOR ABOUT THE MOVE
        MOVEI   G,(D)           ;POINTER INTO RING
ADJBFL: MOVE    H,(G)
        ADDI    H,(F)           ;ADJUST EACH BUFFER IN RING
        HRRM    H,(G)
        SUBI    H,(F)
        MOVEI   G,(H)
        CAIE    G,(D)
        JRST    ADJBFL
        MOVE    G,BUFHD.(C)
        ADDI    G,(F)           ;ADJUST POINTERS IN HEADER
        HRRM    G,BUFHD.(C)
        MOVE    G,BUFHD.+1(C)
        ADDI    G,(F)
        HRRM    G,BUFHD.+1(C)
        MOVSI   G,1
        ORM     G,BUFHD.+1(C)   ;MARK THIS RING AS ALL DONE
        LDB     G,[POINT 17,(E),17]     ;SIZE FIELD FROM HIGHEST BUFFER
        ADD     G,B
        ADD     G,E
        SUB     G,D
        MOVEI   H,2(G)          ;HIGHEST LOC TO BE BLTTED INTO
        MOVEI   [ASCIZ/INSUFFICIENT CORE/]
        CAMG    H,.JBREL
        JRST    .+4
        SKIPN   [X22OV.]        ;BETTER BE ROOM IF 1022 IS PRESENT
        CORE    H,              ;EXPAND CORE IF NECESSARY
        JSR     ERR
        HRLZI   H,-1(D)
        HRRI    H,1(B)          ;SET UP BLT WORD
        CAIE    D,2(B)          ;SKIP IF ALREADY IN RIGHT PLACE
        BLT     H,2(G)
        MOVEI   B,2(G)          ;NEW TOP
        JRST    ADJLP
ADJFIX: MOVSI   C,-40
        MOVSI   D,1
        ANDCAM  D,BUFHD.+1(C)   ;CLEAN UP HEADERS
        ADDI    C,2
        AOBJN   C,.-2
        MOVE    C,B
        ADD     C,BUFDIS        ;DESIRED TOP OF CORE
        HRRZM   C,.JBFF         ;SAVE AS .JBFF (REALLY ONE TOO SMALL)
        AOS     .JBFF
        MOVEI   D,(C)
        MOVEI   [ASCIZ/INSUFFICIENT CORE/]
        SKIPE   [X22OV.]
        JRST    .+3             ;THERE'S ALREADY ROOM IF 1022 EXISTS
        CORE    D,
        JSR     ERR
        SKIPN   BUFDIS
        JRST    ADJDON          ;DONE IF BUFFERS IN RIGHT PLACE
ADJMOV: MOVE    D,(B)
        MOVEM   D,(C)           ;NO, MOVE THEM UP
        SUBI    C,1
        CAMLE   C,NEWTOP
        SOJA    B,ADJMOV
ADJDON: MOVE    A,NEWTOP
        MOVEM   A,OLDTOP        ;ONCE NEW, NOW OLD TOP
        MOVSI   A,(JRA L,(L))
        SKIPGE  OVLDIS          ;IF MOVED BUFFERS DOWN, CALL 1022 FIXUP ROUTINE
        JSA     L,X22OV.        ;TO MOVE ITS AREA DOWN
        JUMP    OVLDIS
        JRST    @JUGDYN
>;END OF IFN F40


;DOES THE ACTUAL INPUT OF ALL NEEDED OVERLAY SEGMENTS
RDSEGS: 0
        MOVEI   SEG,TRETAB      ;RUN THROUGH TREE TABLE SEQUENTIALLY
        HRRZ    A,SEGCNT
        MOVEM   A,HWMANY
CHKSEG: HLRZ    A,SEGFLG(SEG)   ;GET FLAGS FOR SEGMENT
        TRNN    A,NEWIN         ;WILL IT BE IN CORE?
        JRST    NXTSEG          ;NOPE, IGNORE IT
        TRNN    A,INCOR         ;YES, IS IT ALREADY IN CORE?
        JSR     RD1SEG          ;NO, READ IT IN
        JSR     FX1SEG          ;IN ANY CASE FIX UP ITS SYMBOLS AND STUFF
NXTSEG: ADDI    SEG,ENTSIZ
        SOSL    HWMANY         ;TRY THE NEXT SEGMENT
        JRST    CHKSEG
        JRST    @RDSEGS


;READS ONE SEGMENT (IN SEG) INTO CORE AND EXPANDS IT
RD1SEG: 0
        LDB     C,[POINT 15,SEGBLK(SEG),17]     ;GET SEGMENT'S BLOCK NUMBER IN .OVL FILE
        XCT     SETI            ;POSITION FILE TO READ IT
	HLRE	D,SEGLOC(SEG)	;D gets -SIZE
	HRRZ	C,SEGLOC(SEG)	;C gets BASE
	SUBI	C,0(D)		;C gets BASE + SIZE
	HRRZ	D,SEGCMP(SEG)	;D gets CSIZE (COMPACTED SIZE)
	MOVN	D,D		;D gets -CSIZE
	ADD	C,D		;C gets BASE + SIZE - CSIZE
	HRL	C,D		;C gets -CSIZE,,BASE+SIZE-CSIZE
			;NOW WE HAVE IOWD FOR READING COMPRESSED SEG
			;AT THE TOP OF ITS CORE AREA
        MOVEI   D,0
        XCT     READ            ;READ THE SEGMENT
        JRST    EXPAND
        MOVEI   [ASCIZ/ERROR READING FILE /]
        JSR     ERR

;EXPAND THE ZERO-COMPRESSED SEGMENT
;SINCE SEGMENT WAS READ IN AT THE TOP OF ITS CORE AREA, THIS ALWAYS MOVES DOWN

EXPAND: HRRZ    D,SEGCMP(SEG)
        ADDI    D,(C)           ;D=HIGHEST LOC OF SEGMENT
        MOVEI   C,1(C)          ;C=LOC OF CURRENT IOWD
        MOVE    E,SEGLOC(SEG)
        MOVEI   E,1(E)          ;E=CURRENT LOC TO BE MOVED INTO
XPNLP:  MOVE    F,(C)           ;F=CURRENT IOWD
XPNLP1: CAIG    E,(F)
        SETZM   (E)             ;ZERO FIRST WORD IF ANY NEED TO BE ZEROED
        HRLZI   (E)
        HRRI    1(E)
        CAIGE   E,(F)
        BLT     (F)             ;ZERO REST OF BLOCK IF MORE THAN ONE WORD
        CAIL    C,(D)
        JRST    @RD1SEG         ;ALL DONE IF NO MORE NONZERO STUFF
        HLRE    G,F
        SUBM    F,G             ;G=HIGHEST LOC TO MOVE BLOCK INTO
        HRLZI   1(C)            ;FIRST LOC OF BLOCK TO BE MOVED
        HRRI    1(F)            ;LOC TO MOVE IT TO
        BLT     (G)             ;MOVE THE BLOCK TO ITS RIGHTFUL PLACE
        MOVEI   E,1(G)          ;SET E ONE PAST END OF BLOCK
        HLRE    F,F
        SUB     C,F             ;C=1 BELOW NEXT IOWD
        CAIGE   C,(D)           ;CHECK IF AT TOP
        AOJA    C,XPNLP         ;IF NOT DONE, CORRECT C AND CONTINUE
        MOVE    F,D             ;NO MORE NONZERO STUFF, THERE MIGHT STILL
        JRST    XPNLP1          ;BE ZEROES TO FILL IN.  SET UP FAKE IOWD AND DO IT.


;FIXES UP SYMBOLS AND MAIN PROGRAM STUFF FOR SEGMENT IN SEG
FX1SEG: 0
        HRRZ    C,SEGLOC(SEG)
        MOVE    C,1(C)          ;GET SYMBOL PTR FOR SEG (FIRST WORD)
IFN F40,<
        HLRZ    B,SEGFLG(SEG)   ;GET SEGMENT FLAGS
        CAIE    SEG,TRETAB      ;ALREADY SET UP IF ROOT
        TRNN    B,MAINPG        ;CHECK FOR MAIN PROGRAM IN SEGMENT
        JRST    NTMAIN
        MOVE    D,-2(C)         ;YUP, SET UP .JBSA, .JBREN, .JB41
        HLRZM   D,.JBSA
        HRRZM   D,.JBREN
        MOVE    D,-1(C)
        MOVEM   D,.JB41
        MOVE    D,.JBFF
        HRLM    D,.JBSA         ;SET UP RIGHT FREE LOCATION
NTMAIN:
>
        SKIPN   .JBDDT
        JRST    @FX1SEG
        SETZM   1(C)            ;ZAP ITS LINK IN CASE LAST ONE
        HLRE    D,C
        SUB     C,D             ;GET PTR TO TOP
        HRRZ    D,SEGLNK(SEG)   ;GET BACK LINK
        JUMPE   D,@FX1SEG       ;JUMP IF NONE
        HRRZ    D,SEGLOC(D)
        MOVE    D,1(D)          ;GET THAT SEGMENT'S SYMBOL PTR
        HRRZM   C,1(D)          ;AND SET THAT SEGMENT'S LINK TO THE NEW ONE
        JRST    @FX1SEG


;UPDATES IN-CORE BITS FOR EACH SEGMENT (SETS INCOR_NEWIN, NEWIN_0)
FIXMRK: 0
        MOVEI   SEG,TRETAB
        HRRZ    A,SEGCNT
FXMKLP: HLLZ    B,SEGFLG(SEG)
        TLZE    B,NEWIN         ;IS NEWIN ON? (TURN IT OFF)
        TLOA    B,INCOR         ;YES, SET INCOR ON
        TLZ     B,INCOR         ;NO, TURN INCOR OFF
        HLLM    B,SEGFLG(SEG)
        ADDI    SEG,ENTSIZ
        SOJGE   A,FXMKLP
        JRST    @FIXMRK


;ERROR PRINTING ROUTINE - MESSAGE PTR IN AC0.  DOESN'T RETURN - CALLED
;WITH JSR MERELY TO LOCATE CALLER FOR MCHAIN DEBUGGING
ERR:    0
        OUTSTR  [ASCIZ/
OVERLAY ERROR: /]
        OUTSTR  @
        JRST    GETOUT


;LIKE ERR EXCEPT PRINTS THE FILE NAME IN OVLFIL AFTER THE MESSAGE
FILERR: 0
        OUTSTR  [ASCIZ/
OVERLAY ERROR: /]
        OUTSTR  @
        MOVE    B,OVLFIL
        JSR     TYPSIX
        HLLZ    B,OVLFIL+1
        JUMPE   B,GETOUT
        OUTCHI  "."
        JSR     TYPSIX
GETOUT:
IFN F40,<
        EXIT
>
IFE F40,<
        OUTSTR  [BYTE(7)15,12]
        JRST    NCNER.
>


;TYPES SIXBIT TEXT IN A
TYPSIX: 0
TYPSX1: JUMPE   B,@TYPSIX
        MOVEI   A,0
        LSHC    A,6
        OUTCHI  " "(A)
        JRST    TYPSX1

OPN:    INIT    ZAP,16
LOOK:   LOOKUP  ZAP,OVLFIL
SETI:   USETI   ZAP,(C)
READ:   IN      ZAP,C
READHD: IN      ZAP,[IOWD OVFHLN,OVFHDR
                     0]
CLS:    RELEAS  ZAP,

IJMP1:  ZAP     UUOH.

OVLFIL: BLOCK   4               ;OVERLAY FILE NAME BLOCK
OVFBLK: BLOCK   4               ;COPY OF OVLFIL USED FOR ACTUAL LOOKUP
OVFHDR: BLOCK   OVFHLN          ;SPACE TO READ IN OVERLAY FILE HEADER
IFE F40,<
UUOH.:  BLOCK   1
SCR:    BLOCK   3
SXPTR:  BLOCK   1
SXTXT:  BLOCK   1
SXCNT:  BLOCK   1
>
IFN F40,<
SAVEP:  BLOCK   1               ;SAVE P FOR CALL OVERLAY
BUFDIS: BLOCK   1               ;DISPLACEMENT OF BUFFER BLOCK FROM ITS EVENTUAL POSITION
$JBNM$: BLOCK   1
USRLOC: BLOCK   1               ;USER FLAGS,,ADDRESS
>
TOPSEG: BLOCK   1               ;TRETAB PTR OF HIGHEST SEGMENT TO BE BROUGHT INTO CORE
OVLBEG: BLOCK   1               ;POINTER TO HIGHEST UNCHANGED LOC
USRSUB: BLOCK   1               ;LOC OF FIRST SUBROUTINE IN NEW OVERLAY (FOR 'CALL OVERLAY')
OLDTOP: BLOCK   1               ;TOP OF OLD OVERLAY CORE IMAGE (EXCLUDING DYNAMIC STORAGE)
NEWTOP: BLOCK   1               ;DITTO FOR NEW OVERLAY
OVLDIS: BLOCK   1               ;(NEW OVERLAY TOP)-(OLD OVERLAY TOP)
HWMANY: BLOCK   1               ;TEMP FOR RDSEGS (CONTAINS SEGMENT COUNT)

STKPTR: IOWD    10,STACK        ;THIS PRIVATE STACK IS NEEDED BECAUSE WE CALL SOME FORSE AND DDT ROUTINES VIA
STACK:  BLOCK   10              ;PUSHJ, AND THERE IS NO GUARANTEE OF THE AVAILABILITY OF A USER STACK

        END
   P :